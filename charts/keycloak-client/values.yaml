# Default values for keycloak-client.
# This is a YAML-formatted file.

# Client ID (REQUIRED)
# This is the unique identifier for the client in Keycloak
clientId: ""

# Client description
description: ""

# Realm reference (REQUIRED)
# Reference to the parent KeycloakRealm
# Note: The client's namespace must be in the realm's clientAuthorizationGrants list
realmRef:
  # Name of the KeycloakRealm CR
  name: ""

  # Namespace of the KeycloakRealm CR
  namespace: ""

# RBAC configuration
# Creates a RoleBinding to grant the operator access to this namespace
rbac:
  # Create RoleBinding (required for operator to read secrets in this namespace)
  create: true

  # Namespace where the operator is running
  operatorNamespace: keycloak-system

  # Name of the operator's ClusterRole for namespace access
  operatorClusterRoleName: keycloak-operator-namespace-access

  # Name of the operator's ServiceAccount
  # Default format: keycloak-operator-<namespace>
  # Override if your operator uses a different service account name
  operatorServiceAccountName: ""

# Client type configuration
publicClient: false
bearerOnly: false
protocol: openid-connect

# OAuth2/OIDC configuration
redirectUris: []
  # - "https://example.com/callback"
  # - "http://localhost:3000/callback"

webOrigins: []
  # - "https://example.com"
  # - "http://localhost:3000"

postLogoutRedirectUris: []
  # - "https://example.com/logout"

# Base URL for the client
baseUrl: ""
rootUrl: ""
adminUrl: ""

# Client authentication settings
clientAuthenticatorType: client-secret

# Access type settings
standardFlowEnabled: true
implicitFlowEnabled: false
directAccessGrantsEnabled: true
serviceAccountsEnabled: false

# Consent settings
consentRequired: false
displayOnConsentScreen: true

# Front-channel logout
frontchannelLogout: true

# Authorization settings
authorizationServicesEnabled: false

# Fine-grained authorization configuration (optional)
# Only used when authorizationServicesEnabled: true
authorizationSettings:
  # Policy enforcement mode: ENFORCING, PERMISSIVE, or DISABLED
  policyEnforcementMode: ENFORCING
  # Decision strategy: UNANIMOUS or AFFIRMATIVE
  decisionStrategy: UNANIMOUS
  # Allow remote resource management via Protection API
  allowRemoteResourceManagement: true

  # Authorization scopes (actions like read, write, delete)
  scopes: []
    # - name: read
    #   displayName: Read Access
    # - name: write
    #   displayName: Write Access
    # - name: delete
    #   displayName: Delete Access

  # Protected resources (APIs, documents, etc.)
  resources: []
    # - name: Documents API
    #   type: urn:my-api:resources:documents
    #   uris:
    #     - /api/documents/*
    #   scopes:
    #     - read
    #     - write
    #     - delete
    #
    # - name: Users API
    #   type: urn:my-api:resources:users
    #   uris:
    #     - /api/users/*
    #   scopes:
    #     - read
    #     - write

  # Authorization policies (WHO can access resources)
  policies:
    # SECURITY: Enable JavaScript policies (disabled by default)
    allowJavaScriptPolicies: false

    # Role-based policies
    rolePolicies: []
      # - name: admin-policy
      #   description: Grants access to users with admin role
      #   logic: POSITIVE
      #   roles:
      #     - name: admin
      #       required: false
      #   fetchRoles: true

    # User-based policies
    userPolicies: []
      # - name: specific-users-policy
      #   description: Grants access to specific users
      #   users:
      #     - alice
      #     - bob

    # Group-based policies
    groupPolicies: []
      # - name: engineering-policy
      #   description: Grants access to engineering group
      #   groups:
      #     - /engineering
      #     - /engineering/backend
      #   groupsClaim: groups

    # Client-based policies
    clientPolicies: []
      # - name: trusted-clients-policy
      #   description: Grants access to trusted clients
      #   clients:
      #     - trusted-service-a
      #     - trusted-service-b

    # Time-based policies
    timePolicies: []
      # - name: business-hours-policy
      #   description: Grants access during business hours
      #   hour: 9
      #   hourEnd: 17
      #   # Also supports: notBefore, notOnOrAfter, dayMonth, dayMonthEnd,
      #   # month, monthEnd, year, yearEnd, minute, minuteEnd

    # Regex-based policies
    regexPolicies: []
      # - name: email-domain-policy
      #   description: Grants access to users with specific email domain
      #   targetClaim: email
      #   pattern: ".*@example\\.com$"

    # Aggregate policies (combine other policies)
    aggregatePolicies: []
      # - name: admin-or-business-hours
      #   description: Grants access to admins OR during business hours
      #   decisionStrategy: AFFIRMATIVE
      #   policies:
      #     - admin-policy
      #     - business-hours-policy

    # JavaScript policies (requires allowJavaScriptPolicies: true)
    # WARNING: Requires 'upload-scripts' feature enabled in Keycloak
    javascriptPolicies: []
      # - name: custom-js-policy
      #   description: Custom JavaScript policy
      #   code: |
      #     var context = $evaluation.getContext();
      #     var identity = context.getIdentity();
      #     if (identity.getAttributes().containsValue('custom-attr', 'allowed')) {
      #       $evaluation.grant();
      #     }

  # Authorization permissions (tie policies to resources/scopes)
  # Permissions define WHAT can be accessed by linking policies to resources/scopes
  permissions:
    # Resource-based permissions (grant access to entire resources)
    resourcePermissions: []
      # - name: view-all-documents
      #   description: Allow viewing all documents
      #   decisionStrategy: UNANIMOUS
      #   resources:
      #     - Document Resource
      #   policies:
      #     - admin-policy
      #     - viewer-policy

    # Scope-based permissions (grant access to specific scopes)
    scopePermissions: []
      # - name: read-documents
      #   description: Allow reading documents
      #   decisionStrategy: AFFIRMATIVE
      #   resources:
      #     - Document Resource
      #   scopes:
      #     - read
      #   policies:
      #     - user-policy
      #
      # - name: write-admin-only
      #   description: Only admins can write
      #   scopes:
      #     - write
      #     - delete
      #   policies:
      #     - admin-policy

# Advanced settings
alwaysDisplayInConsole: false
fullScopeAllowed: true
includeInTokenScope: true

# Client settings
settings:
  # PKCE settings
  pkceCodeChallengeMethod: ""  # S256, plain, or empty for none

  # Token settings
  accessTokenLifespan: 0  # 0 = use realm default

  # Session settings
  clientSessionIdleTimeout: 0
  clientSessionMaxLifespan: 0

# Default client scopes
defaultClientScopes: []
  # - profile
  # - email

# Optional client scopes
optionalClientScopes: []
  # - address
  # - phone

# Service account roles (if serviceAccountsEnabled: true)
serviceAccountRoles:
  # Realm roles
  realmRoles: []
    # - view-users
    # - manage-users

  # Client roles (map of client ID to roles)
  clientRoles: {}
    # account:
    #   - view-profile
    #   - manage-account

# Protocol mappers
protocolMappers: []
  # - name: audience-mapper
  #   protocol: openid-connect
  #   protocolMapper: oidc-audience-mapper
  #   config:
  #     included.client.audience: "my-api"
  #     id.token.claim: "false"
  #     access.token.claim: "true"

# Authentication flow overrides
authenticationFlow:
  browserFlow: ""
  directGrantFlow: ""
  clientAuthenticationFlow: ""

# Secret management (for confidential clients)
# When manageSecret=true, operator creates/manages a Kubernetes secret
manageSecret: true

# Name of the Kubernetes secret to store client credentials
# If not specified, defaults to: <client-name>-credentials
secretName: ""

# Metadata to attach to the managed secret
# Only used when manageSecret is true
secretMetadata:
  labels: {}
  annotations: {}

# Regenerate the client secret on update
regenerateSecret: false

# Secret rotation configuration
# Enables automated rotation of client secrets
secretRotation:
  # Enable automated secret rotation
  enabled: false
  # Rotation period (e.g., '90d', '24h', '10s')
  # Supported units: s (seconds), m (minutes), h (hours), d (days)
  rotationPeriod: "90d"
  # Optional: Target time for rotation in 'HH:MM' format
  # If set, rotation waits until this time of day
  rotationTime: ""
  # IANA Timezone for rotation scheduling (e.g., 'America/New_York', 'UTC')
  timezone: "UTC"

# Extra Kubernetes manifests to deploy
# Useful for deploying ExternalSecrets, SealedSecrets, ConfigMaps, etc.
extraManifests: []
  # - apiVersion: v1
  #   kind: Secret
  #   metadata:
  #     name: client-credentials
  #   stringData:
  #     client-id: my-client
  #     client-secret: my-secret
  # - apiVersion: external-secrets.io/v1beta1
  #   kind: ExternalSecret
  #   metadata:
  #     name: client-credentials
  #   spec:
  #     secretStoreRef:
  #       name: vault-backend
  #       kind: SecretStore
  #     target:
  #       name: client-credentials
  #     data:
  #       - secretKey: client-secret
  #         remoteRef:
  #           key: /keycloak/clients/{{ .Values.clientId }}
  #           property: secret

# Common labels applied to all resources
commonLabels: {}

# Common annotations applied to all resources
commonAnnotations: {}
