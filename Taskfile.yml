version: '3'

vars:
  VERSION:
    sh: grep '^version = ' pyproject.toml | cut -d'"' -f2
  REVISION:
    sh: git rev-parse HEAD
  CREATED:
    sh: date -u +'%Y-%m-%dT%H:%M:%SZ'
  KEYCLOAK_VERSION: 26.5.2
  TEST_IMAGE_TAG: test
  TESTS: tests/integration/
  CLUSTER_NAME: keycloak-operator-test

env:
  UV_LINK_MODE: copy

tasks:
  default:
    desc: Show help
    cmd: task --list

  # ============================================================================
  # Development Setup
  # ============================================================================
  dev:hooks:
    desc: Install pre-commit hooks
    cmds:
      - uv run --group quality pre-commit install
      - uv run --group quality pre-commit install --hook-type commit-msg

  dev:setup:
    desc: Complete development setup
    cmds:
      - |
        for tool in uv docker kind helm yq jq; do
          if ! command -v $tool >/dev/null 2>&1; then
            echo "âŒ $tool is required but not installed."
            case $tool in
              uv) echo "   Install from https://astral.sh/uv" ;;
              docker) echo "   Install from https://docs.docker.com/get-docker/" ;;
              kind) echo "   Install from https://kind.sigs.k8s.io/" ;;
              helm) echo "   Install from https://helm.sh/docs/intro/install/" ;;
              yq) echo "   Install from https://github.com/mikefarah/yq" ;;
              jq) echo "   Install via your package manager" ;;
            esac
            exit 1
          fi
        done
        if ! command -v trivy >/dev/null 2>&1; then
          echo "âš ï¸  trivy is recommended for security scans but not installed."
          echo "   Install from https://aquasecurity.github.io/trivy/"
        fi
      - task: dev:hooks

  keycloak:models:
    desc: Generate Pydantic models from Keycloak OpenAPI specs
    cmd: uv run --group model-generation python scripts/generate_keycloak_models.py
    sources:
      - scripts/generate_keycloak_models.py
      - keycloak-api-spec.yaml
      - scripts/keycloak_versions.yaml
    generates:
      - src/keycloak_operator/models/keycloak_api.py

  keycloak:verify-api:
    desc: Verify Keycloak API stability across versions
    cmd: uv run python scripts/verify_api_stability.py --check-all

  crds:schemas:
    desc: Generate JSON schemas from CRDs for IDE autocomplete
    cmd: uv run python scripts/generate-crd-schemas.py
    sources:
      - charts/keycloak-operator/crds/*.yaml
      - scripts/generate-crd-schemas.py
    generates:
      - _schemas/**/*.json

  # ============================================================================
  # Code Quality
  # ============================================================================
  quality:format:
    desc: Format code with ruff
    cmd: uv run --group quality ruff format

  quality:lint:
    desc: Lint code with ruff
    cmd: uv run --group quality ruff check --fix

  quality:type-check:
    desc: Run type checking with ty
    cmd: uv run --group quality ty check

  quality:_python:
    internal: true
    cmds:
      - task: quality:format
      - task: quality:lint
      - task: quality:type-check

  quality:helm:
    desc: Lint all Helm charts
    cmds:
      - helm lint charts/keycloak-operator
      - helm lint charts/keycloak-realm
      - helm lint charts/keycloak-client

  quality:security:
    desc: Run security scans (pip-audit, safety, trivy)
    cmds:
      - uv run --group security pip-audit --desc
      - uv run --group security safety check --json
      - |
        if [ -z "$CI" ] && command -v trivy >/dev/null 2>&1; then
          echo "ðŸ” Running Trivy image scan..."
          trivy image keycloak-operator:{{.TEST_IMAGE_TAG}} --severity CRITICAL,HIGH --exit-code 1
        elif [ -n "$CI" ]; then
          echo "â„¹ï¸ Skipping Trivy in CI (handled by action)"
        else
          echo "âš ï¸ trivy not installed, skipping image scan. Install from https://aquasecurity.github.io/trivy/"
        fi

  quality:check:
    desc: Run all quality and validation checks
    deps:
      - quality:_python
      - quality:helm
      - quality:validate-decisions
      - quality:validate-docs
      - quality:validate-crd-pydantic

  quality:validate-decisions:
    desc: Validate Decision Records (Architecture/Development)
    cmd: |
      if [ -n "$(ls docs/decisions/*.yaml 2>/dev/null)" ]; then
        uv run scripts/adr_validator.py --validate;
      else
        echo "No decision record files found";
      fi

  quality:validate-docs:
    desc: Validate documentation examples against schemas
    cmd: uv run --group dev python scripts/lib/schema_validator.py --fail-on-error

  quality:validate-crd-pydantic:
    desc: Validate CRD schemas match Pydantic models
    cmd: uv run --group dev python scripts/lib/crd_pydantic_validator.py --fail-on-error

  # ============================================================================
  # Documentation
  # ============================================================================
  docs:generate-decisions:
    desc: Generate markdown from decision record YAML files
    cmd: bash scripts/build-adr-docs.sh
    sources:
      - docs/decisions/*.yaml
    generates:
      - docs/decisions/generated-markdown/*.md

  docs:build:
    desc: Build documentation site
    deps: [docs:generate-decisions]
    cmd: uv run --group docs mkdocs build
    sources:
      - docs/**/*
      - mkdocs.yml
    generates:
      - site/index.html

  docs:clean:
    desc: Clean generated documentation
    cmds:
      - rm -rf site/
      - rm -rf docs/decisions/generated-markdown/

  docs:publish-dev:
    desc: Build and publish development documentation to GitHub Pages
    cmds:
      - task: docs:generate-decisions
      - uv run --group docs mike deploy --push dev

  docs:publish-release:
    desc: Build and publish versioned release documentation to GitHub Pages
    vars:
      VERSION:
        sh: yq eval '.version' charts/keycloak-operator/Chart.yaml
    cmds:
      - task: docs:generate-decisions
      - uv run --group docs mike deploy --push --update-aliases {{.VERSION}} latest
      - uv run --group docs mike set-default --push latest

  # ============================================================================
  # Unit Testing
  # ============================================================================
  test:unit:
    desc: Run unit tests with coverage
    cmd: KUBECONFIG=/dev/null uv run --group test pytest tests/unit/ -v --disable-socket --allow-unix-socket --cov=keycloak_operator --cov-report=xml --cov-report=term

  # ============================================================================
  # Images
  # ============================================================================
  image:build-operator:
    desc: Build operator production image
    cmds:
      - echo "Building operator production image..."
      - |
        docker build \
          --build-arg VERSION={{.VERSION}} \
          --build-arg REVISION={{.REVISION}} \
          --build-arg CREATED={{.CREATED}} \
          -f images/operator/Dockerfile --target production -t keycloak-operator:{{.TEST_IMAGE_TAG}} .
      - echo "âœ“ Operator image built"
      - mkdir -p .task && touch .task/image_build_operator
    sources:
      - images/operator/Dockerfile
      - src/**/*.py
      - pyproject.toml
      - uv.lock
      - README.md
      - LICENSE
    generates:
      - .task/image_build_operator

  image:load-operator:
    desc: Load operator image into Kind
    deps: [image:build-operator, cluster:create]
    cmd: kind load docker-image keycloak-operator:{{.TEST_IMAGE_TAG}} --name {{.CLUSTER_NAME}}

  image:build-coverage:
    desc: Build operator test image with coverage
    cmds:
      - echo "Building operator test image with coverage..."
      - |
        docker build \
          --build-arg VERSION={{.VERSION}} \
          --build-arg REVISION={{.REVISION}} \
          --build-arg CREATED={{.CREATED}} \
          -f images/operator/Dockerfile --target test -t keycloak-operator:{{.TEST_IMAGE_TAG}} .
      - echo "âœ“ Operator coverage image built"
      - mkdir -p .task && touch .task/image_build_coverage
    sources:
      - images/operator/Dockerfile
      - src/**/*.py
      - pyproject.toml
      - uv.lock
      - README.md
      - LICENSE
      - .coveragerc
      - images/operator/coveragerc.container
      - images/operator/test-inject/**/*
    generates:
      - .task/image_build_coverage

  image:load-coverage:
    desc: Load coverage image into Kind
    deps: [image:build-coverage, cluster:create]
    cmd: kind load docker-image keycloak-operator:{{.TEST_IMAGE_TAG}} --name {{.CLUSTER_NAME}}

  image:build-keycloak:
    desc: Build optimized Keycloak image
    cmds:
      - echo "Building optimized Keycloak image..."
      - |
        docker build -f images/keycloak-optimized/Dockerfile \
          --build-arg KEYCLOAK_VERSION={{.KEYCLOAK_VERSION}} \
          -t keycloak-optimized:{{.KEYCLOAK_VERSION}} \
          .
      - mkdir -p .task && touch .task/image_build_keycloak
    sources:
      - images/keycloak-optimized/Dockerfile
    generates:
      - .task/image_build_keycloak

  image:load-keycloak:
    desc: Load optimized Keycloak into Kind
    deps: [image:build-keycloak, cluster:create]
    cmd: kind load docker-image keycloak-optimized:{{.KEYCLOAK_VERSION}} --name {{.CLUSTER_NAME}}

  image:build-keycloak-tracing:
    desc: Build optimized Keycloak image with tracing
    cmds:
      - echo "Building optimized Keycloak image with tracing..."
      - |
        docker build -f images/keycloak-optimized/Dockerfile \
          --build-arg KEYCLOAK_VERSION={{.KEYCLOAK_VERSION}} \
          --build-arg TRACING_ENABLED=true \
          -t keycloak-optimized-tracing:{{.KEYCLOAK_VERSION}} \
          .
      - mkdir -p .task && touch .task/image_build_keycloak_tracing
    sources:
      - images/keycloak-optimized/Dockerfile
    generates:
      - .task/image_build_keycloak_tracing

  image:load-keycloak-tracing:
    desc: Load tracing Keycloak into Kind
    deps: [image:build-keycloak-tracing, cluster:create]
    cmd: kind load docker-image keycloak-optimized-tracing:{{.KEYCLOAK_VERSION}} --name {{.CLUSTER_NAME}}

  image:load-selected:
    desc: Load the correct Keycloak image variant based on tracing config
    vars:
      TRACING_ENABLED:
        sh: |
          if [ -n "$OTEL_TEST_TRACING_ENABLED" ]; then
             echo "$OTEL_TEST_TRACING_ENABLED" | tr '[:upper:]' '[:lower:]' | grep -qE "true|yes|1" && echo "true" || echo "false"
          elif [ -n "$CI" ]; then
             echo "false"
          else
             echo "true"
          fi
    cmds:
      - task: '{{if eq .TRACING_ENABLED "true"}}image:load-keycloak-tracing{{else}}image:load-keycloak{{end}}'

  image:load-all:
    desc: Load all test images
    deps: [image:load-operator, image:load-keycloak, image:load-keycloak-tracing]

  image:publish:
    desc: Build and push operator production image
    vars:
      PLATFORMS: '{{default "linux/amd64" .PLATFORMS}}'
      # Convert newline-separated tags/labels to docker flags
      DOCKER_TAGS:
        sh: echo "{{.TAGS}}" | sed 's/^/--tag /' | tr '\n' ' '
      DOCKER_LABELS:
        sh: echo "{{.LABELS}}" | sed 's/^/--label "/; s/$/"/' | tr '\n' ' '
    cmds:
      - |
        docker buildx build \
          --platform {{.PLATFORMS}} \
          --build-arg VERSION={{.VERSION}} \
          --build-arg REVISION={{.REVISION}} \
          --build-arg CREATED={{.CREATED}} \
          -f images/operator/Dockerfile --target production \
          --push \
          {{.DOCKER_TAGS}} \
          {{.DOCKER_LABELS}} \
          --metadata-file .task/image-metadata.json \
          .

  # ============================================================================
  # Cluster & Infrastructure
  # ============================================================================
  cluster:create:
    desc: Recreate Kind cluster (Fresh state)
    run: once
    cmd: bash scripts/kind-setup.sh

  cluster:destroy:
    desc: Destroy Kind cluster
    cmd: bash scripts/kind-teardown.sh

  infra:cnpg:
    desc: Install CNPG operator (Idempotent)
    deps: [cluster:create]
    status:
      - kubectl get deployment -n cnpg-system cnpg-cloudnative-pg
    cmd: bash scripts/install-cnpg.sh

  infra:cert-manager:
    desc: Install cert-manager (Idempotent)
    deps: [cluster:create]
    status:
      - kubectl get deployment -n cert-manager cert-manager
    cmd: bash scripts/install-cert-manager.sh

  infra:otel:
    desc: Deploy OTEL collector
    deps: [cluster:create]
    cmd: bash scripts/deploy-otel-collector.sh

  infra:ldap:
    desc: Deploy OpenLDAP for user federation testing
    deps: [cluster:create]
    cmd: bash scripts/install-openldap.sh

  infra:all:
    desc: Install all infrastructure
    deps: [infra:cnpg, infra:cert-manager, infra:otel, infra:ldap]

  # ============================================================================
  # Helm Charts
  # ============================================================================
  charts:update-version:
    desc: Update operator chart version and image tag
    vars:
      VERSION: '{{default .VERSION .OPERATOR_VERSION}}'
    cmds:
      - yq eval -i '.image.tag = "v{{.VERSION}}"' charts/keycloak-operator/values.yaml
      - yq eval -i '.appVersion = "v{{.VERSION}}"' charts/keycloak-operator/Chart.yaml
      - echo "Updated operator chart to version v{{.VERSION}}"

  charts:publish:
    desc: Package and push a Helm chart to OCI registry
    vars:
      CHART_VERSION:
        sh: yq eval '.version' charts/{{.CHART_NAME}}/Chart.yaml
    cmds:
      - mkdir -p .tmp/charts
      - helm package charts/{{.CHART_NAME}} -d .tmp/charts
      - |
        OUTPUT=$(helm push .tmp/charts/{{.CHART_NAME}}-{{.CHART_VERSION}}.tgz oci://{{.REGISTRY_URL}}/{{.REGISTRY_OWNER}}/charts 2>&1)
        echo "$OUTPUT"
        echo "$OUTPUT" | grep -oP 'Digest: \Ksha256:[a-fA-F0-9]+' > .task/{{.CHART_NAME}}-digest

  charts:tag-primary:
    desc: Create and push primary version tag for operator chart
    vars:
      CHART_VERSION:
        sh: yq eval '.version' charts/keycloak-operator/Chart.yaml
    cmds:
      - |
        PRIMARY_TAG="v{{.CHART_VERSION}}"
        COMMIT_SHA=$(git rev-parse HEAD)
        git tag "$PRIMARY_TAG" "$COMMIT_SHA" 2>/dev/null || echo "Tag $PRIMARY_TAG already exists"
        git push origin "$PRIMARY_TAG" 2>/dev/null || echo "Tag $PRIMARY_TAG already pushed"

  # ============================================================================
  # Integration Tests
  # ============================================================================
  test:run-integration:
    desc: Run pytest for integration tests (Internal/CI)
    cmds:
      - mkdir -p .tmp/test-logs
      - echo "Running integration tests..."
      - |
        set -o pipefail
        EXIT_CODE=0
        INTEGRATION_COVERAGE={{default "false" .COVERAGE}} \
        TEST_IMAGE_TAG={{.TEST_IMAGE_TAG}} \
        KEYCLOAK_VERSION={{.KEYCLOAK_VERSION}} \
        uv run pytest {{.TESTS}} -v -n auto --dist=loadscope {{.CLI_ARGS}} 2>&1 | tee .tmp/test-integration.log || EXIT_CODE=$?

        if [ "{{default "false" .COVERAGE}}" = "true" ]; then
          echo "Combining coverage data..."
          bash scripts/combine-coverage.sh || true
        fi

        exit $EXIT_CODE

  test:integration:
    desc: Run integration tests (guaranteed fresh cluster)
    deps: [cluster:create, infra:all, image:load-operator, image:load-selected]
    cmds:
      - task: test:run-integration
        vars:
          CLI_ARGS: "{{.CLI_ARGS}}"

  test:integration-coverage:
    desc: Run integration tests with coverage (guaranteed fresh cluster)
    deps: [cluster:create, infra:all, image:load-coverage, image:load-selected]
    cmds:
      - task: test:run-integration
        vars:
          COVERAGE: "true"
          CLI_ARGS: "{{.CLI_ARGS}}"

  # ============================================================================
  # Main Flows
  # ============================================================================
  test:all:
    desc: Full test suite (Quality + Unit + Integration with fresh cluster)
    vars:
      TIMESTAMP:
        sh: date -u +%Y-%m-%dT%H:%M:%SZ
    cmds:
      - mkdir -p .tmp/test-logs
      - 'echo "[{{.TIMESTAMP}}] Starting full test suite..." | tee -a .tmp/test-pre-commit.log'

      - task: quality:check
      - task: quality:validate-docs

      # Clean start for integration tests
      - task: cluster:create

      - task: test:unit

      # Setup infrastructure
      - task: infra:all

      # Run integration tests (with error handling)
      - |
        set -o pipefail
        task test:integration-coverage 2>&1 | tee -a .tmp/test-pre-commit.log || {
          echo "[{{.TIMESTAMP}}] âŒ Integration tests failed" | tee -a .tmp/test-pre-commit.log
          task logs:collect
          exit 1
        }

      - task: logs:collect
      - 'echo "[{{.TIMESTAMP}}] âœ“ All tests passed!" | tee -a .tmp/test-pre-commit.log'

  logs:collect:
    desc: Collect logs and diagnostics
    vars:
      TRACING_ENABLED:
        sh: |
          if [ -n "$OTEL_TEST_TRACING_ENABLED" ]; then
             echo "$OTEL_TEST_TRACING_ENABLED" | tr '[:upper:]' '[:lower:]' | grep -qE "true|yes|1" && echo "true" || echo "false"
          elif [ -n "$CI" ]; then
             echo "false"
          else
             echo "true"
          fi
    cmds:
      - mkdir -p .tmp/test-logs
      - kubectl cluster-info > .tmp/test-logs/cluster-info.log 2>&1 || true
      - |
        for pod in $(kubectl get pods --all-namespaces -l app.kubernetes.io/name=keycloak-operator -o jsonpath='{range .items[*]}{.metadata.namespace}/{.metadata.name}{"\n"}{end}' 2>/dev/null); do
          namespace=$(echo $pod | cut -d/ -f1)
          podname=$(echo $pod | cut -d/ -f2)
          echo "=== Logs from $namespace/$podname ===" >> .tmp/test-logs/operator-logs.log
          kubectl logs -n $namespace $podname --all-containers=true --tail=2000 >> .tmp/test-logs/operator-logs.log 2>&1 || true
        done
      - kubectl get deployment -l app.kubernetes.io/name=keycloak-operator --all-namespaces -o wide > .tmp/test-logs/operator-status.log 2>&1 || true
      - kubectl get keycloaks,keycloakrealms,keycloakclients --all-namespaces -o wide > .tmp/test-logs/test-resources.log 2>&1 || true
      - kubectl get events --all-namespaces --sort-by='.lastTimestamp' > .tmp/test-logs/events.log 2>&1 || true
      - kubectl get pods --all-namespaces -o wide > .tmp/test-logs/all-pods.log 2>&1 || true
      - if [ "{{.TRACING_ENABLED}}" = "true" ]; then bash scripts/retrieve-traces.sh || true; fi

  # ============================================================================
  # Trace Visualization
  # ============================================================================
  trace:ui:
    desc: Start Jaeger UI and load traces from .tmp/traces/ (human only)
    cmd: bash scripts/trace-ui.sh

  trace:ui-stop:
    desc: Stop the Jaeger trace viewer container
    cmds:
      - docker rm -f keycloak-operator-jaeger 2>/dev/null || true
      - echo "âœ“ Jaeger container stopped"

  # ============================================================================
  # Cleanup
  # ============================================================================
  clean:
    desc: Clean artifacts
    cmds:
      - rm -rf .pytest_cache/ htmlcov/ .coverage .coverage.* test-logs/ .tmp/
      - docker image prune -f

  clean:all:
    desc: Clean everything
    deps: [clean, cluster:destroy]
    cmd: docker system prune -f

  # ============================================================================
  # Compatibility Aliases (Optional, for transition)
  # ============================================================================
  test: { deps: [test:all] }
