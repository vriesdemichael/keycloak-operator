name: Integration Tests

# This workflow follows 2025 Kubernetes operator testing best practices:
# - Uses unified Makefile commands for consistency with local development
# - Leverages cluster reuse optimization where possible
# - Follows Kubebuilder/Operator SDK conventions
# - Separates unit tests (fast feedback) from integration tests (comprehensive validation)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      kubernetes_version:
        description: 'Kubernetes version to test against'
        required: false
        default: 'v1.28.0'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  integration-tests:
    name: Integration Tests (K8s ${{ matrix.k8s-version }})
    runs-on: ubuntu-latest
    timeout-minutes: 45

    strategy:
      fail-fast: false
      matrix:
        k8s-version:
          - v1.30.0

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.13'

    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true
        cache-dependency-glob: "pyproject.toml"

    - name: Install dependencies
      run: uv sync

    - name: Show available Makefile targets
      run: make help

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Set up Kind
      uses: helm/kind-action@v1.10.0
      with:
        version: v0.20.0
        kubectl_version: ${{ matrix.k8s-version }}
        cluster_name: keycloak-operator-test
        config: tests/kind/kind-config.yaml
        node_image: kindest/node:${{ matrix.k8s-version }}
        wait: 300s

    - name: Verify Kind cluster
      run: |
        kubectl cluster-info
        kubectl get nodes
        kubectl get pods -A

    - name: Deploy operator
      run: |
        echo "Building operator image..."
        make build-test
        
        echo "Loading operator image into Kind..."
        kind load docker-image keycloak-operator:test --name keycloak-operator-test
        
        echo "Installing CloudNativePG operator..."
        helm repo add cnpg https://cloudnative-pg.github.io/charts
        helm repo update
        helm upgrade --install cnpg cnpg/cloudnative-pg \
          --namespace cnpg-system \
          --create-namespace \
          --wait \
          --timeout=300s
        
        echo "Deploying operator + test Keycloak via Helm chart..."
        echo "Note: Admin password will be auto-generated by operator"
        helm upgrade --install keycloak-operator ./charts/keycloak-operator \
          --namespace keycloak-system \
          --create-namespace \
          --set namespace.create=false \
          --set crds.install=true \
          --set operator.image.repository=keycloak-operator \
          --set operator.image.tag=test \
          --set operator.image.pullPolicy=Never \
          --set operator.replicaCount=1 \
          --set keycloak.enabled=true \
          --set keycloak.name=test-keycloak \
          --set keycloak.replicas=1 \
          --set keycloak.database.cnpg.enabled=true \
          --set keycloak.database.cnpg.clusterName=test-keycloak-postgres \
          --wait \
          --timeout=600s
        
        echo "Deployment complete!"
        kubectl get pods -n keycloak-system
        kubectl get clusters.postgresql.cnpg.io -n keycloak-system
        kubectl get keycloaks -n keycloak-system
        
        echo "Admin credentials will be in secret: test-keycloak-admin-credentials"

    - name: Wait for operator deployment
      if: success()  # Only run if previous steps succeeded
      run: |
        echo "Verifying operator is ready..."
        kubectl wait -n keycloak-system --for=condition=available deployment/keycloak-operator --timeout=300s
        kubectl wait -n keycloak-system --for=condition=ready pod -l app.kubernetes.io/name=keycloak-operator --timeout=300s
        
        echo "Operator is ready!"
        kubectl get pods -n keycloak-system

    - name: Run integration tests using 2025 best practices
      if: success()  # Only run if operator deployed successfully
      env:
        KUBERNETES_VERSION: ${{ matrix.k8s-version }}
        KUBECONFIG: ${{ env.KUBECONFIG }}
      run: |
        # Use Makefile for integration tests following 2025 best practices
        make test-integration

    - name: Run leader election tests
      if: success()  # Only run if integration tests passed
      run: |
        # Test leader election specifically
        kubectl scale -n keycloak-system deployment keycloak-operator --replicas=2
        kubectl wait -n keycloak-system --for=condition=available deployment/keycloak-operator --timeout=300s

        # Wait for leader election to stabilize
        sleep 30

        # Check lease exists
        kubectl get lease -n keycloak-system keycloak-operator

        # Get current leader
        LEADER=$(kubectl get lease -n keycloak-system keycloak-operator -o jsonpath='{.spec.holderIdentity}')
        echo "Current leader: $LEADER"

        # Test pod failure (chaos engineering)
        LEADER_POD=$(kubectl get pods -n keycloak-system -l app.kubernetes.io/name=keycloak-operator -o jsonpath='{.items[0].metadata.name}')
        echo "Deleting leader pod: $LEADER_POD"
        kubectl delete pod -n keycloak-system $LEADER_POD

        # Wait for new leader election
        sleep 30
        kubectl wait -n keycloak-system --for=condition=available deployment/keycloak-operator --timeout=300s

        # Check new leader
        NEW_LEADER=$(kubectl get lease -n keycloak-system keycloak-operator -o jsonpath='{.spec.holderIdentity}')
        echo "New leader: $NEW_LEADER"

    - name: Test basic operator functionality
      if: success()  # Only run if leader election tests passed
      run: |
        # Create test namespace and resources
        kubectl create namespace operator-test || true

        # Create secrets
        kubectl create -n operator-test secret generic test-db-secret \
          --from-literal=password=testpass

        # Create Keycloak resource
        cat <<EOF | kubectl apply -f -
        apiVersion: keycloak.mdvr.nl/v1
        kind: Keycloak
        metadata:
          name: test-keycloak
          namespace: operator-test
        spec:
          image: "quay.io/keycloak/keycloak:26.4.0"
          replicas: 1
          database:
            type: "postgresql"
            host: "postgres.postgres.svc.cluster.local"
            database: "keycloak"
            username: "keycloak"
            password_secret:
              name: "test-db-secret"
              key: "password"
          service:
            type: "ClusterIP"
            http_port: 8080
        EOF

        # Wait for resource to be processed
        sleep 60

        # Check if deployment was created
        kubectl get -n operator-test deployments
        kubectl describe keycloak -n operator-test test-keycloak

    - name: Collect logs and diagnostics
      if: always()
      run: |
        echo "=== Cluster Info ==="
        kubectl cluster-info

        echo "=== Operator Logs ==="
        make operator-logs || kubectl logs -n keycloak-system -l app.kubernetes.io/name=keycloak-operator --all-containers=true --tail=500 || true

        echo "=== Operator Status ==="
        make operator-status || true

        echo "=== Test Resources ==="
        kubectl get keycloaks,keycloakrealms,keycloakclients --all-namespaces || true

        echo "=== Events ==="
        kubectl get events --all-namespaces --sort-by='.lastTimestamp' --tail=50 || true

        echo "=== PostgreSQL Status ==="
        kubectl get -n postgres pods,services || true
        kubectl logs -n postgres -l app=postgres --tail=100 || true

    - name: Upload test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-logs-k8s-${{ matrix.k8s-version }}
        path: |
          test-logs/
        retention-days: 7

  # Separate job for running unit tests (faster feedback)
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.13'

    - name: Install uv
      uses: astral-sh/setup-uv@v4
      with:
        enable-cache: true

    - name: Install dependencies
      run: uv sync

    - name: Run quality checks
      run: |
        make quality

    - name: Run unit tests
      run: |
        make test-unit

    - name: Generate coverage report
      if: success() || failure()
      run: |
        uv run pytest tests/unit --cov=keycloak_operator --cov-report=xml --cov-report=term

    - name: Upload coverage to Codecov
      if: success() || failure()
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        fail_ci_if_error: false

  # Summary job that depends on all test jobs
  test-summary:
    name: Test Summary
    runs-on: ubuntu-latest
    if: always()
    needs: [integration-tests, unit-tests]

    steps:
    - name: Check test results
      run: |
        echo "Unit tests: ${{ needs.unit-tests.result }}"
        echo "Integration tests: ${{ needs.integration-tests.result }}"

        if [[ "${{ needs.unit-tests.result }}" == "failure" || "${{ needs.integration-tests.result }}" == "failure" ]]; then
          echo "❌ Some tests failed!"
          exit 1
        else
          echo "✅ All tests passed!"
        fi