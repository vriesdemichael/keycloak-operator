name: CI/CD Pipeline (Unified)

# Unified CI/CD pipeline with clear phases:
# 1. Detection - Determine what changed and what needs to run
# 2. Fast checks - Unit tests + code quality (parallel, ~2-5 min)
# 3. Slow checks - Security + integration tests (parallel after fast, ~15-30 min)
# 4. Release-please - Create/update release PRs (non-release commits only)
# 5. Publish - Publish artifacts (release commits only)
# 6. Docs - Update documentation (after checks pass)
# 7. Complete - Final status check

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  KEYCLOAK_VERSION: "26.4.1"

jobs:
  # =====================================================
  # PHASE 1: DETECTION
  # =====================================================
  detect:
    name: Detect Changes & Release Type
    runs-on: ubuntu-latest
    outputs:
      # Release detection
      is_release: ${{ steps.release-check.outputs.is_release }}
      release_type: ${{ steps.release-check.outputs.release_type }}
      # Which components are releasing
      operator_releasing: ${{ steps.release-check.outputs.operator_releasing }}
      chart_operator_releasing: ${{ steps.release-check.outputs.chart_operator_releasing }}
      chart_realm_releasing: ${{ steps.release-check.outputs.chart_realm_releasing }}
      chart_client_releasing: ${{ steps.release-check.outputs.chart_client_releasing }}
      any_chart_releasing: ${{ steps.release-check.outputs.any_chart_releasing }}
      # Version info
      operator_version: ${{ steps.release-check.outputs.operator_version }}
      # File changes
      code_changed: ${{ steps.filter.outputs.code }}
      charts_changed: ${{ steps.filter.outputs.charts }}
      docs_changed: ${{ steps.filter.outputs.docs }}
      crds_changed: ${{ steps.filter.outputs.crds }}
      # Branch info
      is_main: ${{ steps.branch.outputs.is_main }}

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: Check branch
        id: branch
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "is_main=true" >> $GITHUB_OUTPUT
          else
            echo "is_main=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect release commit
        id: release-check
        run: |
          # Handle cases where head_commit may be null (workflow_dispatch, pull_request)
          COMMIT_MSG="${{ github.event.head_commit.message || '' }}"
          COMMIT_AUTHOR="${{ github.event.head_commit.author.username || '' }}"

          # Check if this is a release-please commit
          # Method A: Check bot author (works when release-please bot commits directly)
          # Method B: Check commit message + CHANGELOG (works when user merges release PR)
          IS_RELEASE=false
          if [[ "$COMMIT_AUTHOR" == "github-actions[bot]" ]] && \
             [[ "$COMMIT_MSG" == "chore: release"* || "$COMMIT_MSG" == "chore(main): release"* ]]; then
            IS_RELEASE=true
          elif [[ "$COMMIT_MSG" == "chore(main): release"* ]]; then
            # Release commits merged by user - verify by checking CHANGELOG changes
            if git diff HEAD~1 HEAD --name-only | grep -E -q "^CHANGELOG.md$|^charts/.*/CHANGELOG.md$"; then
              IS_RELEASE=true
            fi
          fi

          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT

          if [[ "$IS_RELEASE" == "false" ]]; then
            echo "Not a release commit"
            echo "release_type=none" >> $GITHUB_OUTPUT
            echo "operator_releasing=false" >> $GITHUB_OUTPUT
            echo "chart_operator_releasing=false" >> $GITHUB_OUTPUT
            echo "chart_realm_releasing=false" >> $GITHUB_OUTPUT
            echo "chart_client_releasing=false" >> $GITHUB_OUTPUT
            echo "any_chart_releasing=false" >> $GITHUB_OUTPUT
            echo "operator_version=" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Release commit detected, parsing versions..."

          # Initialize outputs
          OPERATOR_RELEASING=false
          CHART_OP_RELEASING=false
          CHART_REALM_RELEASING=false
          CHART_CLIENT_RELEASING=false
          OPERATOR_VERSION=""
          RELEASE_TYPE=""

          # Parse from changed CHANGELOG files
          if git diff HEAD~1 HEAD --name-only | grep -q "^CHANGELOG.md$"; then
            OPERATOR_RELEASING=true
            OPERATOR_VERSION=$(grep -m1 "^## \[" CHANGELOG.md | sed 's/## \[\(.*\)\].*/\1/')
            RELEASE_TYPE="operator"
          fi

          if git diff HEAD~1 HEAD --name-only | grep -q "^charts/keycloak-operator/CHANGELOG.md$"; then
            CHART_OP_RELEASING=true
            RELEASE_TYPE="${RELEASE_TYPE:+$RELEASE_TYPE,}chart-operator"
          fi

          if git diff HEAD~1 HEAD --name-only | grep -q "^charts/keycloak-realm/CHANGELOG.md$"; then
            CHART_REALM_RELEASING=true
            RELEASE_TYPE="${RELEASE_TYPE:+$RELEASE_TYPE,}chart-realm"
          fi

          if git diff HEAD~1 HEAD --name-only | grep -q "^charts/keycloak-client/CHANGELOG.md$"; then
            CHART_CLIENT_RELEASING=true
            RELEASE_TYPE="${RELEASE_TYPE:+$RELEASE_TYPE,}chart-client"
          fi

          # Set any_chart_releasing
          ANY_CHART_RELEASING=false
          if [[ "$CHART_OP_RELEASING" == "true" ]] || \
             [[ "$CHART_REALM_RELEASING" == "true" ]] || \
             [[ "$CHART_CLIENT_RELEASING" == "true" ]]; then
            ANY_CHART_RELEASING=true
          fi

          # Output results
          echo "operator_releasing=${OPERATOR_RELEASING}" >> $GITHUB_OUTPUT
          echo "chart_operator_releasing=${CHART_OP_RELEASING}" >> $GITHUB_OUTPUT
          echo "chart_realm_releasing=${CHART_REALM_RELEASING}" >> $GITHUB_OUTPUT
          echo "chart_client_releasing=${CHART_CLIENT_RELEASING}" >> $GITHUB_OUTPUT
          echo "any_chart_releasing=${ANY_CHART_RELEASING}" >> $GITHUB_OUTPUT
          echo "operator_version=${OPERATOR_VERSION}" >> $GITHUB_OUTPUT
          echo "release_type=${RELEASE_TYPE}" >> $GITHUB_OUTPUT

          # Summary
          echo "### ðŸŽ¯ Release Detection" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release Type:** ${RELEASE_TYPE}" >> $GITHUB_STEP_SUMMARY
          echo "- Operator: ${OPERATOR_RELEASING} ${OPERATOR_VERSION:+(v$OPERATOR_VERSION)}" >> $GITHUB_STEP_SUMMARY
          echo "- Chart Operator: ${CHART_OP_RELEASING}" >> $GITHUB_STEP_SUMMARY
          echo "- Chart Realm: ${CHART_REALM_RELEASING}" >> $GITHUB_STEP_SUMMARY
          echo "- Chart Client: ${CHART_CLIENT_RELEASING}" >> $GITHUB_STEP_SUMMARY

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            code:
              - 'src/**'
              - 'tests/**'
              - 'pyproject.toml'
              - 'uv.lock'
              - 'images/operator/**'
            charts:
              - 'charts/*/Chart.yaml'
              - 'charts/*/values.yaml'
              - 'charts/*/values.schema.json'
              - 'charts/*/templates/**'
              - 'charts/*/crds/**'
            docs:
              - 'docs/**'
              - 'mkdocs.yml'
              - 'scripts/build-adr-docs.sh'
            crds:
              - 'src/domain/models.py'

      - name: Summary
        run: |
          echo "### ðŸ“‹ Change Detection" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "**Is Main:** ${{ steps.branch.outputs.is_main }}" >> $GITHUB_STEP_SUMMARY
          echo "**Is Release:** ${{ steps.release-check.outputs.is_release }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Changed Files:**" >> $GITHUB_STEP_SUMMARY
          echo "- Code: ${{ steps.filter.outputs.code }}" >> $GITHUB_STEP_SUMMARY
          echo "- Charts: ${{ steps.filter.outputs.charts }}" >> $GITHUB_STEP_SUMMARY
          echo "- Docs: ${{ steps.filter.outputs.docs }}" >> $GITHUB_STEP_SUMMARY
          echo "- CRDs: ${{ steps.filter.outputs.crds }}" >> $GITHUB_STEP_SUMMARY

  # =====================================================
  # PHASE 2: BUILD (Always on code/chart changes)
  # =====================================================
  build-operator:
    name: Build Operator Image
    needs: detect
    # Force full run on main to catch integration issues from previous commits
    # Use change detection for PRs to save resources
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      needs.detect.outputs.code_changed == 'true' ||
      needs.detect.outputs.charts_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build operator image (test with coverage)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: images/operator/Dockerfile.test
          platforms: linux/amd64
          tags: keycloak-operator:test
          outputs: type=docker,dest=/tmp/operator-test.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Upload image artifact
        uses: actions/upload-artifact@v5
        with:
          name: operator-image
          path: /tmp/operator-test.tar
          retention-days: 1

  # =====================================================
  # PHASE 3: FAST CHECKS (Parallel, ~2-5 min)
  # =====================================================
  unit-tests:
    name: Unit Tests & Coverage
    needs: [detect, build-operator]
    if: |
      github.ref == 'refs/heads/main' ||
      needs.detect.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v5

      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Run unit tests
        run: uv run --group test pytest tests/unit --cov=keycloak_operator --cov-report=xml --cov-report=term

      - name: Upload unit coverage artifact for combining
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: unit-coverage
          path: |
            .coverage
            coverage.xml
          retention-days: 1

      - name: Upload coverage (try CLI first)
        id: codecov_cli
        uses: codecov/codecov-action@v5
        continue-on-error: true
        if: (success() || failure()) && github.actor != 'dependabot[bot]'
        with:
          files: ./coverage.xml
          flags: unit
          name: unit-tests
          token: ${{ secrets.CODECOV_TOKEN }}
          disable_search: true
          fail_ci_if_error: false

      - name: Upload coverage (fallback to legacy)
        if: (success() || failure()) && github.actor != 'dependabot[bot]' && steps.codecov_cli.outcome == 'failure'
        uses: codecov/codecov-action@v5
        continue-on-error: true
        with:
          files: ./coverage.xml
          flags: unit
          name: unit-tests
          token: ${{ secrets.CODECOV_TOKEN }}
          disable_search: true
          fail_ci_if_error: false  # TEMPORARY: Global Codecov outage 2025-11-18
          use_legacy_upload_endpoint: true

      - name: Check coverage upload
        if: (success() || failure()) && github.actor != 'dependabot[bot]' && steps.codecov_cli.outcome == 'failure'
        run: |
          echo "::warning::Codecov CLI upload failed, used legacy endpoint as fallback (allowing failures due to outage)"

  code-quality:
    name: Code Quality
    needs: [detect, build-operator]
    if: |
      github.ref == 'refs/heads/main' ||
      needs.detect.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v5

      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Run quality checks
        run: make quality

      - name: Install yq for decision record validation
        env:
          YQ_VERSION: "v4.44.3"
          YQ_CHECKSUM: "a2c097180dd884a8d50c956ee16a9cec070f30a7947cf4ebf87d5f36213e9ed7"
        run: |
          wget -q https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64 -O /tmp/yq
          echo "${YQ_CHECKSUM}  /tmp/yq" | sha256sum -c -
          sudo mv /tmp/yq /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
        if: hashFiles('docs/decisions/*.yaml') != ''

      - name: Validate Decision Records
        run: uv run --group quality scripts/adr_validator.py --validate
        if: hashFiles('docs/decisions/*.yaml') != ''

  # =====================================================
  # PHASE 4: SLOW CHECKS (Parallel after fast, ~15-30 min)
  # =====================================================
  security-scans:
    name: Security Scans
    needs: [detect, build-operator, unit-tests, code-quality]
    if: |
      github.ref == 'refs/heads/main' ||
      needs.detect.outputs.code_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      security-events: write
      contents: read
      actions: read

    steps:
      - uses: actions/checkout@v5

      # CodeQL SAST
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: python
          config-file: .github/codeql-config.yml

      - name: Autobuild
        uses: github/codeql-action/autobuild@v4

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: "/language:python"

      # Dependency scanning
      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true

      - name: Run pip-audit
        run: uv run --group security pip-audit --desc || true

      - name: Run safety check
        run: uv run --group security safety check --json || true

      # Image scanning
      - name: Download image
        uses: actions/download-artifact@v6
        with:
          name: operator-image
          path: /tmp

      - name: Load image
        run: docker load --input /tmp/operator-test.tar

      - name: Trivy scan (SARIF)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'keycloak-operator:test'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v4
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'trivy-test-image'

      - name: Trivy scan (table, fail on critical)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'keycloak-operator:test'
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

      # SBOM generation
      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: keycloak-operator:test
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Scan SBOM for vulnerabilities
        uses: anchore/scan-action@v7
        with:
          sbom: sbom.spdx.json
          fail-build: false
          severity-cutoff: high

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: sbom-test-image
          path: sbom.spdx.json
          retention-days: 90

      # Secret scanning
      - name: TruffleHog Secret Scan
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event_name == 'pull_request' && github.event.pull_request.base.sha || 'HEAD~1' }}
          head: HEAD
          extra_args: --only-verified

  integration-tests:
    name: Integration Tests
    needs: [detect, build-operator, unit-tests, code-quality]
    if: |
      github.ref == 'refs/heads/main' ||
      needs.detect.outputs.code_changed == 'true' ||
      needs.detect.outputs.charts_changed == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read
      packages: read

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true
          cache-dependency-glob: "pyproject.toml"

      - name: Download operator image
        uses: actions/download-artifact@v6
        with:
          name: operator-image
          path: /tmp

      - name: Load operator image
        run: docker load --input /tmp/operator-test.tar

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up Kind
        uses: helm/kind-action@v1.13.0
        with:
          version: v0.20.0
          kubectl_version: v1.30.0
          cluster_name: test-${{ github.run_id }}
          config: tests/kind/kind-config.yaml
          node_image: kindest/node:v1.30.0
          wait: 300s

      - name: Verify Kind cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get pods -A

      - name: Load operator image into Kind
        run: kind load docker-image keycloak-operator:test --name test-${{ github.run_id }}

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and load Keycloak optimized image
        env:
          KEYCLOAK_IMAGE: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/keycloak-optimized:${{ env.KEYCLOAK_VERSION }}
        run: |
          docker pull "${KEYCLOAK_IMAGE}"
          docker tag "${KEYCLOAK_IMAGE}" keycloak-optimized:${{ env.KEYCLOAK_VERSION }}
          kind load docker-image keycloak-optimized:${{ env.KEYCLOAK_VERSION }} --name test-${{ github.run_id }}

      - name: Install CloudNativePG operator
        run: |
          helm repo add cnpg https://cloudnative-pg.github.io/charts
          helm repo update
          helm upgrade --install cnpg cnpg/cloudnative-pg \
            --namespace cnpg-system \
            --create-namespace \
            --wait \
            --timeout=300s

          kubectl wait -n cnpg-system \
            --for=condition=available deployment/cnpg-cloudnative-pg \
            --timeout=300s

      - name: Install cert-manager
        run: |
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml

          kubectl wait -n cert-manager \
            --for=condition=available deployment/cert-manager \
            --timeout=300s
          kubectl wait -n cert-manager \
            --for=condition=available deployment/cert-manager-webhook \
            --timeout=300s
          kubectl wait -n cert-manager \
            --for=condition=available deployment/cert-manager-cainjector \
            --timeout=300s

      - name: Run integration tests
        env:
          INTEGRATION_COVERAGE: "true"
        run: uv run --group test pytest tests/integration/ -v -n auto --dist=loadscope

      - name: Upload integration coverage to Codecov
        uses: codecov/codecov-action@v5
        if: always() && github.actor != 'dependabot[bot]'
        with:
          files: .tmp/coverage/.coverage.*
          flags: integration
          name: integration-tests
          token: ${{ secrets.CODECOV_TOKEN }}
          disable_search: true
          fail_ci_if_error: true

      - name: Collect logs and diagnostics
        if: always()
        run: |
          mkdir -p test-logs

          kubectl cluster-info | tee test-logs/cluster-info.log

          for pod in $(kubectl get pods --all-namespaces -l app.kubernetes.io/name=keycloak-operator -o jsonpath='{range .items[*]}{.metadata.namespace}/{.metadata.name}{"\n"}{end}'); do
            namespace=$(echo $pod | cut -d/ -f1)
            podname=$(echo $pod | cut -d/ -f2)
            kubectl logs -n $namespace $podname --all-containers=true --tail=2000 >> test-logs/operator-logs.log 2>&1 || true
          done

          kubectl get deployment -l app.kubernetes.io/name=keycloak-operator --all-namespaces -o wide >> test-logs/operator-status.log 2>&1 || true
          kubectl get keycloaks,keycloakrealms,keycloakclients --all-namespaces -o wide >> test-logs/test-resources.log 2>&1 || true
          kubectl get events --all-namespaces --sort-by='.lastTimestamp' >> test-logs/events.log 2>&1 || true
          kubectl get pods --all-namespaces -o wide >> test-logs/all-pods.log 2>&1 || true

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: test-logs-${{ github.run_id }}
          path: test-logs/
          retention-days: 7

  # =====================================================
  # CHECKPOINT: All required checks passed
  # =====================================================
  all-required-checks-passed:
    name: All Required Checks Passed
    needs: [detect, unit-tests, code-quality, security-scans, integration-tests]
    if: always()
    runs-on: ubuntu-latest
    outputs:
      passed: ${{ steps.check.outputs.passed }}

    steps:
      - name: Check all required
        id: check
        run: |
          echo "### âœ… Required Checks Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Unit Tests: ${{ needs.unit-tests.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Code Quality: ${{ needs.code-quality.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Security Scans: ${{ needs.security-scans.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Integration Tests: ${{ needs.integration-tests.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if any required job failed
          if [[ "${{ needs.unit-tests.result }}" == "failure" ]] || \
             [[ "${{ needs.code-quality.result }}" == "failure" ]] || \
             [[ "${{ needs.security-scans.result }}" == "failure" ]] || \
             [[ "${{ needs.integration-tests.result }}" == "failure" ]]; then
            echo "âŒ Required checks failed" >> $GITHUB_STEP_SUMMARY
            echo "passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Check if skipped inappropriately on main push
          # Note: workflow_dispatch on main is allowed to skip
          if [[ "${{ github.ref }}" == "refs/heads/main" ]] && [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ needs.integration-tests.result }}" == "skipped" ]]; then
              echo "âš ï¸ Integration tests should not skip on main branch pushes" >> $GITHUB_STEP_SUMMARY
              echo "passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

          echo "âœ… All required checks passed" >> $GITHUB_STEP_SUMMARY
          echo "passed=true" >> $GITHUB_OUTPUT

  # =====================================================
  # PHASE 5: RELEASE-PLEASE (Non-release commits only)
  # =====================================================
  release-please:
    name: Release Please
    needs: [detect, all-required-checks-passed]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'false' &&
      github.event_name == 'push'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Run Release Please
        id: release
        uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          config-file: .github/release-please-config.json
          manifest-file: .github/.release-please-manifest.json

      - name: Release summary
        if: steps.release.outputs.release_created == 'true'
        run: |
          echo "### :rocket: Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** \`${{ steps.release.outputs.tag_name }}\`" >> $GITHUB_STEP_SUMMARY

      - name: PR summary
        if: steps.release.outputs.pr != ''
        env:
          PR_DATA: ${{ steps.release.outputs.pr }}
        run: |
          echo "### :memo: Release PR Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** ${PR_DATA}" >> $GITHUB_STEP_SUMMARY

      - name: Enable auto-merge for non-major releases
        if: steps.release.outputs.pr != ''
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PLEASE_TOKEN }}
          PR_DATA: ${{ steps.release.outputs.pr }}
        run: |
          PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
          PR_BRANCH=$(echo "$PR_DATA" | jq -r '.headBranchName')

          # Fetch the PR branch to compare manifest
          git fetch origin "$PR_BRANCH:$PR_BRANCH"

          # Check manifest changes to determine if this is a major release
          HAS_MAJOR_BUMP=false

          # Get current and new manifest
          CURRENT_MANIFEST=$(cat .github/.release-please-manifest.json)
          NEW_MANIFEST=$(git show "$PR_BRANCH:.github/.release-please-manifest.json")

          # Compare each component
          for component in $(echo "$CURRENT_MANIFEST" | jq -r 'keys[]'); do
            CURRENT_VERSION=$(echo "$CURRENT_MANIFEST" | jq -r --arg comp "$component" '.[$comp]')
            NEW_VERSION=$(echo "$NEW_MANIFEST" | jq -r --arg comp "$component" '.[$comp]')

            if [[ "$CURRENT_VERSION" != "$NEW_VERSION" ]]; then
              echo "Component '$component': $CURRENT_VERSION -> $NEW_VERSION"

              # Parse versions
              if [[ "$CURRENT_VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
                CUR_MAJOR="${BASH_REMATCH[1]}"
                CUR_MINOR="${BASH_REMATCH[2]}"
                CUR_PATCH="${BASH_REMATCH[3]}"
              fi

              if [[ "$NEW_VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
                NEW_MAJOR="${BASH_REMATCH[1]}"
                NEW_MINOR="${BASH_REMATCH[2]}"
                NEW_PATCH="${BASH_REMATCH[3]}"
              fi

              # Check if it's a major release (X.0.0 where X > current major and X > 0)
              if [[ "$NEW_MAJOR" -gt "$CUR_MAJOR" ]] && [[ "$NEW_MAJOR" -gt 0 ]]; then
                echo "âš ï¸  Major version bump detected: $CURRENT_VERSION -> $NEW_VERSION"
                HAS_MAJOR_BUMP=true
              fi
            fi
          done

          # Enable auto-merge only if no major bumps
          if [[ "$HAS_MAJOR_BUMP" == "false" ]]; then
            if gh pr merge "$PR_NUMBER" --auto --rebase --repo ${{ github.repository }}; then
              echo "### :white_check_mark: Auto-merge enabled" >> $GITHUB_STEP_SUMMARY
            else
              echo "### :warning: Auto-merge failed" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### :warning: Manual Review Required (Major Release)" >> $GITHUB_STEP_SUMMARY
          fi

  # =====================================================
  # PHASE 6: PUBLISH OPERATOR IMAGE (Release commits)
  # =====================================================
  publish-operator-image:
    name: Publish Operator Image
    needs: [detect, all-required-checks-passed]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'true' &&
      needs.detect.outputs.operator_releasing == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: ghcr-production
      url: https://github.com/${{ github.repository }}/pkgs/container/keycloak-operator
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write  # For OIDC token to sign attestations
      attestations: write  # For publishing attestations

    steps:
      - uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version
        id: version
        run: |
          VERSION="${{ needs.detect.outputs.operator_version }}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Publishing operator version: ${VERSION}"

      - name: Generate tags
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=raw,value=v${{ steps.version.outputs.version }}
            type=raw,value=${{ steps.version.outputs.version }}
          labels: |
            org.opencontainers.image.title=Keycloak Operator
            org.opencontainers.image.description=GitOps-compatible Kubernetes operator for Keycloak
            org.opencontainers.image.vendor=MichaÃ«l de Vries
            org.opencontainers.image.licenses=MIT
            org.opencontainers.image.version=v${{ steps.version.outputs.version }}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: images/operator/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          # Generate build provenance attestation (SLSA)
          provenance: true
          # Generate SBOM attestation
          sbom: true

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ steps.version.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Attest SBOM
        uses: actions/attest-sbom@v2
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.build.outputs.digest }}
          sbom-path: sbom.spdx.json
          push-to-registry: true

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v5
        with:
          name: sbom-operator-v${{ steps.version.outputs.version }}
          path: sbom.spdx.json
          retention-days: 90

      - name: Summary
        run: |
          echo "### :whale: Operator Image Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** v${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  # =====================================================
  # PHASE 7: UPDATE OPERATOR CHART (After operator publish)
  # =====================================================
  update-operator-chart:
    name: Update Operator Chart Version
    needs: [detect, all-required-checks-passed, publish-operator-image]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'true' &&
      needs.detect.outputs.operator_releasing == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Update chart values
        run: |
          VERSION="v${{ needs.detect.outputs.operator_version }}"

          sed -i "s|tag: \"v.*\"|tag: \"${VERSION}\"|g" charts/keycloak-operator/values.yaml
          sed -i "s|appVersion: \"v.*\"|appVersion: \"${VERSION}\"|g" charts/keycloak-operator/Chart.yaml

          git diff

      - name: Check for changes
        id: check
        run: |
          if git diff --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: steps.check.outputs.changed == 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: main
          commit-message: |
            fix(chart-operator): update for operator v${{ needs.detect.outputs.operator_version }}

            Update operator chart to use operator v${{ needs.detect.outputs.operator_version }}.
            This ensures helm deployments use the latest tested operator image.

            Auto-generated by CI/CD workflow
          branch: chore/update-operator-chart-v${{ needs.detect.outputs.operator_version }}
          delete-branch: true
          title: "fix(chart-operator): update for operator v${{ needs.detect.outputs.operator_version }}"
          body: |
            Updates operator chart to use operator version `v${{ needs.detect.outputs.operator_version }}`.

            **Changes:**
            - Updated `charts/keycloak-operator/values.yaml` image tag
            - Updated `charts/keycloak-operator/Chart.yaml` appVersion

            This fix ensures the chart is compatible with operator v${{ needs.detect.outputs.operator_version }}.

            ðŸ¤– Auto-generated by CI/CD workflow
          labels: |
            dependencies
            helm
            automated

      - name: Enable auto-rebase for chart update PR
        if: steps.check.outputs.changed == 'true' && steps.cpr.outputs.pull-request-number
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.cpr.outputs.pull-request-number }}"

          # Enable auto-merge with rebase
          if gh pr merge $PR_NUMBER --auto --rebase --repo ${{ github.repository }}; then
            echo "### :white_check_mark: Auto-rebase enabled for chart update PR" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "PR #${PR_NUMBER} will merge automatically when checks pass." >> $GITHUB_STEP_SUMMARY
          else
            echo "### :warning: Could not enable auto-rebase" >> $GITHUB_STEP_SUMMARY
          fi

  # =====================================================
  # PHASE 8: PUBLISH HELM CHARTS (Chart releases to OCI)
  # =====================================================
  publish-chart-operator:
    name: Publish Helm Chart (Operator)
    needs: [detect, all-required-checks-passed]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'true' &&
      needs.detect.outputs.chart_operator_releasing == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ghcr-chart-operator
      url: https://github.com/${{ github.repository }}/pkgs/container/charts%2Fkeycloak-operator
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
      - uses: actions/checkout@v5

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Get chart version
        id: version
        run: |
          VERSION=$(yq eval '.version' charts/keycloak-operator/Chart.yaml)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Publishing keycloak-operator chart version: ${VERSION}"

      - name: Package chart
        id: package
        run: |
          helm package charts/keycloak-operator
          PACKAGE_FILE=$(ls keycloak-operator-*.tgz)
          echo "file=${PACKAGE_FILE}" >> $GITHUB_OUTPUT

      - name: Push chart to OCI registry
        id: push
        run: |
          OUTPUT=$(helm push ${{ steps.package.outputs.file }} oci://ghcr.io/${{ github.repository_owner }}/charts 2>&1)
          echo "$OUTPUT"
          # Extract digest from output
          DIGEST=$(echo "$OUTPUT" | grep -oP 'Digest: \K[a-f0-9:]+' || echo "")
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

      - name: Attest chart provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ghcr.io/${{ github.repository_owner }}/charts/keycloak-operator
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  publish-chart-realm:
    name: Publish Helm Chart (Realm)
    needs: [detect, all-required-checks-passed]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'true' &&
      needs.detect.outputs.chart_realm_releasing == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ghcr-chart-realm
      url: https://github.com/${{ github.repository }}/pkgs/container/charts%2Fkeycloak-realm
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
      - uses: actions/checkout@v5

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Get chart version
        id: version
        run: |
          VERSION=$(yq eval '.version' charts/keycloak-realm/Chart.yaml)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Publishing keycloak-realm chart version: ${VERSION}"

      - name: Package chart
        id: package
        run: |
          helm package charts/keycloak-realm
          PACKAGE_FILE=$(ls keycloak-realm-*.tgz)
          echo "file=${PACKAGE_FILE}" >> $GITHUB_OUTPUT

      - name: Push chart to OCI registry
        id: push
        run: |
          OUTPUT=$(helm push ${{ steps.package.outputs.file }} oci://ghcr.io/${{ github.repository_owner }}/charts 2>&1)
          echo "$OUTPUT"
          DIGEST=$(echo "$OUTPUT" | grep -oP 'Digest: \K[a-f0-9:]+' || echo "")
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

      - name: Attest chart provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ghcr.io/${{ github.repository_owner }}/charts/keycloak-realm
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  publish-chart-client:
    name: Publish Helm Chart (Client)
    needs: [detect, all-required-checks-passed]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'true' &&
      needs.detect.outputs.chart_client_releasing == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ghcr-chart-client
      url: https://github.com/${{ github.repository }}/pkgs/container/charts%2Fkeycloak-client
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
      - uses: actions/checkout@v5

      - name: Set up Helm
        uses: azure/setup-helm@v4

      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | helm registry login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Get chart version
        id: version
        run: |
          VERSION=$(yq eval '.version' charts/keycloak-client/Chart.yaml)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Publishing keycloak-client chart version: ${VERSION}"

      - name: Package chart
        id: package
        run: |
          helm package charts/keycloak-client
          PACKAGE_FILE=$(ls keycloak-client-*.tgz)
          echo "file=${PACKAGE_FILE}" >> $GITHUB_OUTPUT

      - name: Push chart to OCI registry
        id: push
        run: |
          OUTPUT=$(helm push ${{ steps.package.outputs.file }} oci://ghcr.io/${{ github.repository_owner }}/charts 2>&1)
          echo "$OUTPUT"
          DIGEST=$(echo "$OUTPUT" | grep -oP 'Digest: \K[a-f0-9:]+' || echo "")
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

      - name: Attest chart provenance
        uses: actions/attest-build-provenance@v2
        with:
          subject-name: ghcr.io/${{ github.repository_owner }}/charts/keycloak-client
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  # =====================================================
  # PHASE 9: DOCUMENTATION
  # =====================================================
  update-dev-docs:
    name: Update Dev Documentation
    needs: [detect, all-required-checks-passed]
    if: |
      needs.all-required-checks-passed.outputs.passed == 'true' &&
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'false' &&
      needs.detect.outputs.docs_changed == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: github-pages
      cancel-in-progress: false
    environment:
      name: github-pages-dev
      url: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/dev
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - uses: astral-sh/setup-uv@v7

      - name: Build ADR documentation
        run: bash scripts/build-adr-docs.sh

      - name: Generate CRD JSON schemas
        run: uv run python scripts/generate-crd-schemas.py

      - name: Configure Git for mike
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Deploy dev docs with mike
        run: uv run --group docs mike deploy --push dev

  publish-release-docs:
    name: Publish Release Documentation
    needs: [detect, all-required-checks-passed, publish-chart-operator]
    if: |
      needs.detect.outputs.is_main == 'true' &&
      needs.detect.outputs.is_release == 'true' &&
      needs.detect.outputs.chart_operator_releasing == 'true'
    runs-on: ubuntu-latest
    concurrency:
      group: github-pages
      cancel-in-progress: false
    environment:
      name: github-pages-release
      url: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v6
        with:
          python-version: '3.13'

      - uses: astral-sh/setup-uv@v7

      - name: Install yq for YAML parsing
        env:
          YQ_VERSION: "v4.44.3"
        run: |
          wget -q https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64 -O /tmp/yq
          sudo mv /tmp/yq /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get chart version
        id: version
        run: |
          # Use yq for robust YAML parsing instead of grep/awk
          VERSION=$(yq eval '.version' charts/keycloak-operator/Chart.yaml)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

      - name: Deploy versioned docs with mike
        run: |
          uv run --group docs mike deploy --push --update-aliases ${{ steps.version.outputs.version }} latest
          uv run --group docs mike set-default --push latest

  # =====================================================
  # FINAL CHECKPOINT: Workflow Complete
  # =====================================================
  all-complete:
    name: Workflow Complete
    needs: [
      detect,
      all-required-checks-passed,
      release-please,
      publish-operator-image,
      update-operator-chart,
      publish-chart-operator,
      publish-chart-realm,
      publish-chart-client,
      update-dev-docs,
      publish-release-docs
    ]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Workflow summary
        run: |
          echo "### ðŸŽ¯ Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Required Checks:** ${{ needs.all-required-checks-passed.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release Please:** ${{ needs.release-please.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Operator Image:** ${{ needs.publish-operator-image.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Chart Update:** ${{ needs.update-operator-chart.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Chart Operator:** ${{ needs.publish-chart-operator.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Chart Realm:** ${{ needs.publish-chart-realm.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Chart Client:** ${{ needs.publish-chart-client.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Dev Docs:** ${{ needs.update-dev-docs.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release Docs:** ${{ needs.publish-release-docs.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if any publish job that RAN failed
          FAILED=false

          if [[ "${{ needs.all-required-checks-passed.result }}" == "failure" ]]; then
            echo "âŒ Required checks failed" >> $GITHUB_STEP_SUMMARY
            FAILED=true
          fi

          if [[ "${{ needs.publish-operator-image.result }}" == "failure" ]] || \
             [[ "${{ needs.publish-helm-charts.result }}" == "failure" ]] || \
             [[ "${{ needs.publish-release-docs.result }}" == "failure" ]] || \
             [[ "${{ needs.update-dev-docs.result }}" == "failure" ]]; then
            echo "âŒ Publishing failed" >> $GITHUB_STEP_SUMMARY
            FAILED=true
          fi

          if [[ "$FAILED" == "true" ]]; then
            exit 1
          fi

          echo "âœ… Workflow completed successfully" >> $GITHUB_STEP_SUMMARY
