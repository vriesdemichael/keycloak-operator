package output

import (
	"strings"
	"testing"

	"github.com/vriesdemichael/keycloak-operator/tools/migration-toolkit/internal/transform"
)

func TestGenerateNextSteps_EmptyResult(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:    "test-realm",
		RealmValues:  map[string]any{},
		ClientValues: map[string]map[string]any{},
		Secrets:      []transform.SecretEntry{},
		Users:        []map[string]any{},
		Warnings:     []transform.Warning{},
	}

	output := GenerateNextSteps(result)

	// Header with realm name
	if !strings.Contains(output, "# Migration Next Steps") {
		t.Error("expected header '# Migration Next Steps'")
	}
	if !strings.Contains(output, "Realm: **test-realm**") {
		t.Error("expected realm name in header")
	}

	// Summary section
	if !strings.Contains(output, "## Summary") {
		t.Error("expected summary section")
	}
	if !strings.Contains(output, "**Clients**: 0 extracted") {
		t.Error("expected client count of 0")
	}
	if !strings.Contains(output, "**Secrets**: 0 extracted") {
		t.Error("expected secret count of 0")
	}
	if !strings.Contains(output, "**Users**: 0 extracted") {
		t.Error("expected user count of 0")
	}
	if !strings.Contains(output, "**Unsupported features**: 0") {
		t.Error("expected unsupported feature count of 0")
	}

	// Secrets section should NOT be present
	if strings.Contains(output, "## Secrets") {
		t.Error("secrets section should not appear when there are no secrets")
	}

	// Users section should NOT be present
	if strings.Contains(output, "## Users") {
		t.Error("users section should not appear when there are no users")
	}

	// Unsupported section should NOT be present
	if strings.Contains(output, "## Unsupported Features") {
		t.Error("unsupported section should not appear when there are no unsupported warnings")
	}

	// Apply instructions should be present
	if !strings.Contains(output, "## Applying the Generated Values") {
		t.Error("expected apply instructions section")
	}

	// Verification checklist should be present
	if !strings.Contains(output, "## Verification Checklist") {
		t.Error("expected verification checklist section")
	}

	// Footer
	if !strings.Contains(output, "Generated by keycloak-migrate") {
		t.Error("expected footer with 'Generated by keycloak-migrate'")
	}
}

func TestGenerateNextSteps_WithSecrets(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:    "secret-realm",
		RealmValues:  map[string]any{},
		ClientValues: map[string]map[string]any{},
		Secrets: []transform.SecretEntry{
			{
				Name:        "my-app-secret",
				Key:         "client-secret",
				Value:       "super-secret-value",
				Description: "OAuth2 client secret",
				SourceField: "clients[0].secret",
			},
			{
				Name:        "smtp-secret",
				Key:         "password",
				Value:       "smtp-pass",
				Description: "SMTP password",
				SourceField: "smtpServer.password",
			},
		},
		Users:    []map[string]any{},
		Warnings: []transform.Warning{},
	}

	output := GenerateNextSteps(result)

	// Secrets section should appear
	if !strings.Contains(output, "## Secrets") {
		t.Error("expected secrets section")
	}

	// Table headers
	if !strings.Contains(output, "| Secret Name | Key | Source | Description |") {
		t.Error("expected secret table headers")
	}

	// Secret entries in table
	if !strings.Contains(output, "| `my-app-secret` | `client-secret` | `clients[0].secret` | OAuth2 client secret |") {
		t.Error("expected first secret entry in table")
	}
	if !strings.Contains(output, "| `smtp-secret` | `password` | `smtpServer.password` | SMTP password |") {
		t.Error("expected second secret entry in table")
	}

	// Summary count
	if !strings.Contains(output, "**Secrets**: 2 extracted") {
		t.Error("expected secret count of 2 in summary")
	}

	// Provisioning options
	if !strings.Contains(output, "External Secrets Operator") {
		t.Error("expected ESO option in secrets section")
	}
	if !strings.Contains(output, "Sealed Secrets") {
		t.Error("expected Sealed Secrets option in secrets section")
	}
	if !strings.Contains(output, "Plain Secrets") {
		t.Error("expected Plain Secrets option in secrets section")
	}
}

func TestGenerateNextSteps_WithUsers(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:    "user-realm",
		RealmValues:  map[string]any{},
		ClientValues: map[string]map[string]any{},
		Secrets:      []transform.SecretEntry{},
		Users: []map[string]any{
			{"username": "alice", "email": "alice@example.com"},
			{"username": "bob", "email": "bob@example.com"},
			{"username": "charlie", "email": "charlie@example.com"},
		},
		Warnings: []transform.Warning{},
	}

	output := GenerateNextSteps(result)

	// Users section should appear
	if !strings.Contains(output, "## Users") {
		t.Error("expected users section")
	}

	// User count in section
	if !strings.Contains(output, "**3 users**") {
		t.Error("expected user count of 3 in users section")
	}

	// Summary count
	if !strings.Contains(output, "**Users**: 3 extracted") {
		t.Error("expected user count of 3 in summary")
	}

	// Import options
	if !strings.Contains(output, "Partial Import") {
		t.Error("expected Partial Import option")
	}
	if !strings.Contains(output, "kcadm.sh") {
		t.Error("expected kcadm.sh option")
	}

	// Users step in apply instructions
	if !strings.Contains(output, "### 4. Import Users") {
		t.Error("expected users step in apply instructions")
	}
}

func TestGenerateNextSteps_WithUnsupportedFeatures(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:    "unsupported-realm",
		RealmValues:  map[string]any{},
		ClientValues: map[string]map[string]any{},
		Secrets:      []transform.SecretEntry{},
		Users:        []map[string]any{},
		Warnings: []transform.Warning{
			{
				Category: "unsupported",
				Field:    "identityProviders",
				Message:  "Identity provider federation not yet supported",
				IssueURL: "https://github.com/vriesdemichael/keycloak-operator/issues/42",
			},
			{
				Category: "unsupported",
				Field:    "authenticationFlows",
				Message:  "Custom authentication flows not yet supported",
				IssueURL: "",
			},
			{
				Category: "deprecated",
				Field:    "someOldField",
				Message:  "This field is deprecated",
				IssueURL: "",
			},
		},
	}

	output := GenerateNextSteps(result)

	// Unsupported section should appear
	if !strings.Contains(output, "## Unsupported Features") {
		t.Error("expected unsupported features section")
	}

	// Table headers
	if !strings.Contains(output, "| Feature | Description | Tracking Issue |") {
		t.Error("expected unsupported feature table headers")
	}

	// Feature entries with issue link
	if !strings.Contains(output, "| `identityProviders` | Identity provider federation not yet supported | [#42]") {
		t.Error("expected identityProviders entry with issue link")
	}

	// Feature entries without issue link should show dash
	if !strings.Contains(output, "| `authenticationFlows` | Custom authentication flows not yet supported | â€” |") {
		t.Error("expected authenticationFlows entry with dash for missing issue URL")
	}

	// Only unsupported warnings counted (not deprecated)
	if !strings.Contains(output, "**Unsupported features**: 2") {
		t.Error("expected unsupported feature count of 2 (excluding deprecated)")
	}

	// Deprecated warning should NOT appear in unsupported table
	if strings.Contains(output, "someOldField") {
		t.Error("deprecated warnings should not appear in unsupported features table")
	}
}

func TestGenerateNextSteps_WithClients(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:   "client-realm",
		RealmValues: map[string]any{},
		ClientValues: map[string]map[string]any{
			"frontend-app": {"enabled": true},
			"backend-api":  {"enabled": true},
		},
		Secrets:  []transform.SecretEntry{},
		Users:    []map[string]any{},
		Warnings: []transform.Warning{},
	}

	output := GenerateNextSteps(result)

	// Client count in summary
	if !strings.Contains(output, "**Clients**: 2 extracted") {
		t.Error("expected client count of 2 in summary")
	}

	// Helm install commands for each client
	if !strings.Contains(output, "helm install frontend-app keycloak-client") {
		t.Error("expected helm install command for frontend-app")
	}
	if !strings.Contains(output, "helm install backend-api keycloak-client") {
		t.Error("expected helm install command for backend-api")
	}

	// Verify "No custom clients found" is NOT present
	if strings.Contains(output, "No custom clients found") {
		t.Error("should not show 'No custom clients found' when clients exist")
	}
}

func TestGenerateNextSteps_NoClients(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:    "empty-realm",
		RealmValues:  map[string]any{},
		ClientValues: map[string]map[string]any{},
		Secrets:      []transform.SecretEntry{},
		Users:        []map[string]any{},
		Warnings:     []transform.Warning{},
	}

	output := GenerateNextSteps(result)

	if !strings.Contains(output, "No custom clients found") {
		t.Error("expected 'No custom clients found' message when no clients exist")
	}
}

func TestGenerateNextSteps_Full(t *testing.T) {
	result := &transform.TransformResult{
		RealmName:   "full-realm",
		RealmValues: map[string]any{"enabled": true},
		ClientValues: map[string]map[string]any{
			"my-client": {"enabled": true},
		},
		Secrets: []transform.SecretEntry{
			{
				Name:        "my-client-secret",
				Key:         "secret",
				Value:       "val",
				Description: "Client secret",
				SourceField: "clients[0].secret",
			},
		},
		Users: []map[string]any{
			{"username": "admin"},
		},
		Warnings: []transform.Warning{
			{
				Category: "unsupported",
				Field:    "components",
				Message:  "Custom components not supported",
				IssueURL: "https://github.com/vriesdemichael/keycloak-operator/issues/99",
			},
		},
		UnsupportedFeatures: map[string]any{"components": true},
	}

	output := GenerateNextSteps(result)

	// All major sections present
	sections := []string{
		"# Migration Next Steps",
		"## Summary",
		"## Secrets",
		"## Users",
		"## Unsupported Features",
		"## Applying the Generated Values",
		"## Verification Checklist",
	}
	for _, section := range sections {
		if !strings.Contains(output, section) {
			t.Errorf("expected section %q to be present", section)
		}
	}

	// Summary counts
	if !strings.Contains(output, "**Clients**: 1 extracted") {
		t.Error("expected client count of 1")
	}
	if !strings.Contains(output, "**Secrets**: 1 extracted") {
		t.Error("expected secret count of 1")
	}
	if !strings.Contains(output, "**Users**: 1 extracted") {
		t.Error("expected user count of 1")
	}
	if !strings.Contains(output, "**Unsupported features**: 1") {
		t.Error("expected unsupported feature count of 1")
	}

	// Users step in apply instructions
	if !strings.Contains(output, "### 4. Import Users") {
		t.Error("expected users import step in apply instructions")
	}

	// Footer
	if !strings.Contains(output, "Generated by keycloak-migrate") {
		t.Error("expected footer")
	}
}

func TestGenerateNextSteps_VerificationChecklist(t *testing.T) {
	t.Run("minimal result has base checklist items", func(t *testing.T) {
		result := &transform.TransformResult{
			RealmName:    "check-realm",
			RealmValues:  map[string]any{},
			ClientValues: map[string]map[string]any{},
			Secrets:      []transform.SecretEntry{},
			Users:        []map[string]any{},
			Warnings:     []transform.Warning{},
		}
		output := GenerateNextSteps(result)

		if !strings.Contains(output, "- [ ] Realm CR status is `Ready`") {
			t.Error("expected realm ready checklist item")
		}
		if !strings.Contains(output, "- [ ] Authentication flows work") {
			t.Error("expected authentication flows checklist item")
		}
		if !strings.Contains(output, "- [ ] Client applications can authenticate") {
			t.Error("expected client applications checklist item")
		}

		// Should NOT have optional items
		if strings.Contains(output, "All Client CRs status is `Ready`") {
			t.Error("should not have client CR checklist item without clients")
		}
		if strings.Contains(output, "All secrets are correctly provisioned") {
			t.Error("should not have secrets checklist item without secrets")
		}
		if strings.Contains(output, "Users are imported and can log in") {
			t.Error("should not have users checklist item without users")
		}
		if strings.Contains(output, "Unsupported features are manually configured") {
			t.Error("should not have unsupported checklist item without unsupported warnings")
		}
	})

	t.Run("full result has all checklist items", func(t *testing.T) {
		result := &transform.TransformResult{
			RealmName:   "full-check-realm",
			RealmValues: map[string]any{},
			ClientValues: map[string]map[string]any{
				"app": {"enabled": true},
			},
			Secrets: []transform.SecretEntry{
				{Name: "s", Key: "k", Value: "v", Description: "d", SourceField: "f"},
			},
			Users: []map[string]any{
				{"username": "user1"},
			},
			Warnings: []transform.Warning{
				{Category: "unsupported", Field: "feat", Message: "not supported"},
			},
		}
		output := GenerateNextSteps(result)

		if !strings.Contains(output, "- [ ] Realm CR status is `Ready`") {
			t.Error("expected realm ready checklist item")
		}
		if !strings.Contains(output, "- [ ] All Client CRs status is `Ready`") {
			t.Error("expected client CR checklist item")
		}
		if !strings.Contains(output, "- [ ] All secrets are correctly provisioned") {
			t.Error("expected secrets checklist item")
		}
		if !strings.Contains(output, "- [ ] Users are imported and can log in") {
			t.Error("expected users checklist item")
		}
		if !strings.Contains(output, "- [ ] Unsupported features are manually configured") {
			t.Error("expected unsupported features checklist item")
		}
		if !strings.Contains(output, "- [ ] Client applications can authenticate") {
			t.Error("expected client applications checklist item")
		}
	})
}

func TestSanitizeForPath_Simple(t *testing.T) {
	got := sanitizeForPath("my-client")
	if got != "my-client" {
		t.Errorf("sanitizeForPath(%q) = %q, want %q", "my-client", got, "my-client")
	}
}

func TestSanitizeForPath_Spaces(t *testing.T) {
	got := sanitizeForPath("my client")
	if got != "my-client" {
		t.Errorf("sanitizeForPath(%q) = %q, want %q", "my client", got, "my-client")
	}
}

func TestSanitizeForPath_SpecialChars(t *testing.T) {
	got := sanitizeForPath("client@#$")
	if got != "client" {
		t.Errorf("sanitizeForPath(%q) = %q, want %q", "client@#$", got, "client")
	}
}

func TestSanitizeForPath_Slashes(t *testing.T) {
	got := sanitizeForPath("path/to/thing")
	if got != "path-to-thing" {
		t.Errorf("sanitizeForPath(%q) = %q, want %q", "path/to/thing", got, "path-to-thing")
	}
}

func TestSanitizeForPath_Backslash(t *testing.T) {
	got := sanitizeForPath("path\\to")
	if got != "path-to" {
		t.Errorf("sanitizeForPath(%q) = %q, want %q", "path\\to", got, "path-to")
	}
}

func TestSanitizeForPath_Underscore(t *testing.T) {
	got := sanitizeForPath("my_client")
	if got != "my_client" {
		t.Errorf("sanitizeForPath(%q) = %q, want %q", "my_client", got, "my_client")
	}
}
