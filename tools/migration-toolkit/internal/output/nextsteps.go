package output

import (
	"fmt"
	"strings"

	"github.com/vriesdemichael/keycloak-operator/tools/migration-toolkit/internal/transform"
)

// GenerateNextSteps produces a NEXT-STEPS.md document from transformation results.
// It provides actionable guidance for completing the migration.
func GenerateNextSteps(result *transform.TransformResult) string {
	var b strings.Builder

	b.WriteString("# Migration Next Steps\n\n")
	b.WriteString(fmt.Sprintf("Realm: **%s**\n\n", result.RealmName))
	b.WriteString("This document was generated by `keycloak-migrate transform`. ")
	b.WriteString("Review each section carefully before applying the generated Helm values.\n\n")

	b.WriteString("## Summary\n\n")
	b.WriteString(fmt.Sprintf("- **Clients**: %d extracted\n", len(result.ClientValues)))
	b.WriteString(fmt.Sprintf("- **Secrets**: %d extracted (see `secrets-inventory.json`)\n", len(result.Secrets)))
	b.WriteString(fmt.Sprintf("- **Users**: %d extracted (see `users.json`)\n", len(result.Users)))
	unsupportedCount := 0
	for _, w := range result.Warnings {
		if w.Category == "unsupported" {
			unsupportedCount++
		}
	}
	b.WriteString(fmt.Sprintf("- **Unsupported features**: %d (see below)\n\n", unsupportedCount))

	// Secrets section
	if len(result.Secrets) > 0 {
		writeSecretsSection(&b, result)
	}

	// Users section
	if len(result.Users) > 0 {
		writeUsersSection(&b, result)
	}

	// Unsupported features section
	if unsupportedCount > 0 {
		writeUnsupportedSection(&b, result)
	}

	// Apply instructions
	writeApplyInstructions(&b, result)

	// Verification section
	writeVerificationSection(&b, result)

	return b.String()
}

func writeSecretsSection(b *strings.Builder, result *transform.TransformResult) {
	b.WriteString("## Secrets\n\n")
	b.WriteString("The following secrets were extracted from the Keycloak export.\n")
	b.WriteString("**WARNING**: `secrets-inventory.json` contains plaintext secret values. ")
	b.WriteString("Delete it after provisioning secrets in your secret management system.\n\n")

	b.WriteString("| Secret Name | Key | Source | Description |\n")
	b.WriteString("|-------------|-----|--------|-------------|\n")
	for _, s := range result.Secrets {
		b.WriteString(fmt.Sprintf("| `%s` | `%s` | `%s` | %s |\n", s.Name, s.Key, s.SourceField, s.Description))
	}
	b.WriteString("\n")

	b.WriteString("### Secret Provisioning\n\n")
	b.WriteString("Choose your secret management approach:\n\n")
	b.WriteString("**Option A: External Secrets Operator (recommended)**\n\n")
	b.WriteString("1. Store each secret value in your external secret store (Vault, AWS SM, etc.)\n")
	b.WriteString("2. Re-run the transform with `--secret-mode=eso --eso-store=<store-name>`\n")
	b.WriteString("3. Apply the generated ExternalSecret manifests\n\n")
	b.WriteString("**Option B: Sealed Secrets**\n\n")
	b.WriteString("1. Re-run the transform with `--secret-mode=sealed-secrets`\n")
	b.WriteString("2. Use `kubeseal` to encrypt each secret value in the generated manifests\n\n")
	b.WriteString("**Option C: Plain Secrets (not recommended for production)**\n\n")
	b.WriteString("The generated `secrets.yaml` contains plain Kubernetes Secret manifests.\n")
	b.WriteString("Apply with `kubectl apply -f secrets.yaml`, but be aware that by default these are only base64-encoded and may not be encrypted at rest in your cluster; treat them as sensitive and avoid committing them to Git.\n\n")
}

func writeUsersSection(b *strings.Builder, result *transform.TransformResult) {
	b.WriteString("## Users\n\n")
	b.WriteString(fmt.Sprintf("Found **%d users** in the realm export. ", len(result.Users)))
	b.WriteString("The operator does not manage users (see [ADR-025](https://github.com/vriesdemichael/keycloak-operator/blob/main/docs/decisions/025-realm-and-client-as-primary-crd-resource-types.yaml)). ")
	b.WriteString("Users have been extracted to `users.json`.\n\n")
	b.WriteString("### Import Options\n\n")
	b.WriteString("**Option A: Partial Import (Admin Console)**\n\n")
	b.WriteString("1. Open Keycloak Admin Console\n")
	b.WriteString("2. Navigate to the realm\n")
	b.WriteString("3. Go to **Realm Settings** > **Action** > **Partial Import**\n")
	b.WriteString("4. Upload `users.json`\n")
	b.WriteString("5. Select **Skip** or **Overwrite** for existing resources\n\n")
	b.WriteString("**Option B: Keycloak CLI (kcadm.sh)**\n\n")
	b.WriteString("```bash\nkcadm.sh create partialImport \\\n")
	b.WriteString(fmt.Sprintf("  -r %s \\\n", result.RealmName))
	b.WriteString("  -s ifResourceExists=SKIP \\\n")
	b.WriteString("  -f users.json\n```\n\n")
	b.WriteString("**Note**: Password hashes from the export are preserved and will survive the import.\n\n")
}

func writeUnsupportedSection(b *strings.Builder, result *transform.TransformResult) {
	b.WriteString("## Unsupported Features\n\n")
	b.WriteString("The following features from the Keycloak export are not yet supported by the operator's Helm charts. ")
	b.WriteString("They require manual configuration or will be addressed in future releases.\n\n")

	b.WriteString("| Feature | Description | Tracking Issue |\n")
	b.WriteString("|---------|-------------|----------------|\n")
	for _, w := range result.Warnings {
		if w.Category != "unsupported" {
			continue
		}
		issueLink := "â€”"
		if w.IssueURL != "" {
			// Extract issue number from URL
			parts := strings.Split(w.IssueURL, "/")
			issueNum := parts[len(parts)-1]
			issueLink = fmt.Sprintf("[#%s](%s)", issueNum, w.IssueURL)
		}
		b.WriteString(fmt.Sprintf("| `%s` | %s | %s |\n", w.Field, w.Message, issueLink))
	}
	b.WriteString("\n")
}

func writeApplyInstructions(b *strings.Builder, result *transform.TransformResult) {
	b.WriteString("## Applying the Generated Values\n\n")
	b.WriteString("### 1. Create Secrets\n\n")
	b.WriteString("Provision all secrets listed above before deploying the Helm charts.\n\n")

	b.WriteString("### 2. Deploy Realm\n\n")
	b.WriteString("```bash\n")
	b.WriteString(fmt.Sprintf("helm install %s keycloak-realm \\\n", result.RealmName))
	b.WriteString(fmt.Sprintf("  --repo https://vriesdemichael.github.io/keycloak-operator \\\n"))
	b.WriteString(fmt.Sprintf("  -f %s/realm-values.yaml \\\n", result.RealmName))
	b.WriteString(fmt.Sprintf("  -n <namespace>\n"))
	b.WriteString("```\n\n")

	b.WriteString("### 3. Deploy Clients\n\n")
	if len(result.ClientValues) > 0 {
		b.WriteString("Deploy each client after the realm is `Ready`:\n\n")
		for clientId := range result.ClientValues {
			b.WriteString("```bash\n")
			b.WriteString(fmt.Sprintf("helm install %s keycloak-client \\\n", clientId))
			b.WriteString(fmt.Sprintf("  --repo https://vriesdemichael.github.io/keycloak-operator \\\n"))
			b.WriteString(fmt.Sprintf("  -f %s/clients/%s/values.yaml \\\n", result.RealmName, sanitizeForPath(clientId)))
			b.WriteString(fmt.Sprintf("  -n <namespace>\n"))
			b.WriteString("```\n\n")
		}
	} else {
		b.WriteString("No custom clients found in the export.\n\n")
	}

	if len(result.Users) > 0 {
		b.WriteString("### 4. Import Users\n\n")
		b.WriteString("After realm and clients are deployed, import users using one of the options above.\n\n")
	}
}

func writeVerificationSection(b *strings.Builder, result *transform.TransformResult) {
	b.WriteString("## Verification Checklist\n\n")
	b.WriteString("After applying all resources, verify:\n\n")
	b.WriteString("- [ ] Realm CR status is `Ready`\n")
	if len(result.ClientValues) > 0 {
		b.WriteString("- [ ] All Client CRs status is `Ready`\n")
	}
	b.WriteString("- [ ] Authentication flows work (login, registration, password reset)\n")
	if len(result.Secrets) > 0 {
		b.WriteString("- [ ] All secrets are correctly provisioned\n")
	}
	if len(result.Users) > 0 {
		b.WriteString("- [ ] Users are imported and can log in\n")
	}
	unsupportedCount := 0
	for _, w := range result.Warnings {
		if w.Category == "unsupported" {
			unsupportedCount++
		}
	}
	if unsupportedCount > 0 {
		b.WriteString("- [ ] Unsupported features are manually configured\n")
	}
	b.WriteString("- [ ] Client applications can authenticate against the new realm\n")
	b.WriteString("\n---\n*Generated by keycloak-migrate*\n")
}

func sanitizeForPath(name string) string {
	result := make([]byte, 0, len(name))
	for i := 0; i < len(name); i++ {
		c := name[i]
		if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '_' {
			result = append(result, c)
		} else if c == ' ' || c == '/' || c == '\\' {
			result = append(result, '-')
		}
	}
	return string(result)
}
