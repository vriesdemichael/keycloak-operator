{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Keycloak Operator","text":"<p>A GitOps-friendly Kubernetes operator for managing Keycloak instances, realms, and OAuth2/OIDC clients declaratively.</p>"},{"location":"#why-use-this-operator","title":"Why Use This Operator?","text":""},{"location":"#vs-official-keycloak-operator","title":"vs. Official Keycloak Operator","text":"<ul> <li>\u2705 True Multi-Tenancy: Cross-namespace realm and client provisioning</li> <li>\u2705 GitOps Native: Namespace grant lists instead of manual secret distribution</li> <li>\u2705 Declarative Authorization: RBAC + namespace grants, no separate token system</li> <li>\u2705 Built for Production: Rate limiting, drift detection, admission webhooks</li> <li>\u2705 Comprehensive Status: Rich status fields with observedGeneration tracking</li> </ul>"},{"location":"#vs-manual-keycloak-management","title":"vs. Manual Keycloak Management","text":"<ul> <li>\u2705 No Admin Console Access: Everything through Kubernetes CRDs</li> <li>\u2705 Drift Detection: Automatic detection of manual changes</li> <li>\u2705 Automated Credentials: Client secrets managed as Kubernetes secrets</li> <li>\u2705 Full Observability: Prometheus metrics, structured logging</li> </ul>"},{"location":"#quick-start-3-helm-charts","title":"\ud83d\ude80 Quick Start (3 Helm Charts)","text":"<p>Deploy a complete Keycloak setup with database, operator, realm, and client:</p> <pre><code># 1. Deploy PostgreSQL (CloudNativePG)\nhelm install cnpg cloudnative-pg/cloudnative-pg \\\n  --namespace cnpg-system --create-namespace\n\n# 2. Install operator + Keycloak instance\nhelm install keycloak-operator keycloak-operator/keycloak-operator \\\n  --namespace keycloak-system --create-namespace \\\n  --set keycloak.enabled=true \\\n  --set keycloak.database.cnpg.enabled=true\n\n# 3. Create realm (in your app namespace)\nhelm install my-realm keycloak-operator/keycloak-realm \\\n  --namespace my-app --create-namespace \\\n  --set realmName=my-app \\\n  --set operatorRef.namespace=keycloak-system \\\n  --set 'clientAuthorizationGrants={my-app}'\n\n# 4. Create OAuth2 client\nhelm install my-client keycloak-operator/keycloak-client \\\n  --namespace my-app \\\n  --set clientId=my-app \\\n  --set realmRef.name=my-realm \\\n  --set 'redirectUris={https://my-app.example.com/callback}'\n</code></pre> <p>\ud83d\udcd6 Complete Quick Start Guide \u2192</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83d\udd12 Secure by Default - Kubernetes RBAC controls all access, no separate auth system</li> <li>\ud83d\udce6 GitOps Ready - Declarative CRDs with full status reporting and drift detection</li> <li>\ud83c\udfaf Multi-Tenant - Cross-namespace realm and client provisioning with namespace grants</li> <li>\u26a1 Production Ready - Rate limiting, admission webhooks, HA support with CloudNativePG</li> <li>\ud83d\udcca Observable - Prometheus metrics, structured logging, comprehensive status conditions</li> <li>\ud83d\udd04 Drift Detection - Automatic detection and remediation of configuration drift</li> </ul>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>The operator manages three core resources:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Keycloak    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 KeycloakRealm   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 KeycloakClient   \u2502\n\u2502  (Instance)  \u2502     \u2502 (Identity)      \u2502     \u2502 (OAuth2/OIDC)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Keycloak: Identity server instance with PostgreSQL database</li> <li>KeycloakRealm: Identity domain containing users, roles, and settings</li> <li>KeycloakClient: OAuth2/OIDC applications with automated credentials</li> </ul>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start Guide - Get running in 10 minutes</li> <li>Architecture Overview - How the operator works</li> <li>Security Model - Authorization and access control</li> </ul>"},{"location":"#configuration","title":"Configuration","text":"<ul> <li>KeycloakRealm Reference - Complete realm options</li> <li>KeycloakClient Reference - Complete client options</li> <li>Identity Providers - Integrate Google, GitHub, Azure AD, etc.</li> </ul>"},{"location":"#operations","title":"Operations","text":"<ul> <li>Admission Webhooks - Validation and resource quotas</li> <li>Drift Detection - Orphan detection and remediation</li> <li>Observability - Metrics, logging, and monitoring</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Development Guide - Contributing to the project</li> <li>Decision Records - Architecture decisions and rationale</li> </ul>"},{"location":"#security-authorization","title":"\ud83d\udd12 Security &amp; Authorization","text":"<p>The operator uses Kubernetes RBAC for all authorization - no separate token system.</p>"},{"location":"#realm-creation","title":"Realm Creation","text":"<p>Any user with RBAC permission to create <code>KeycloakRealm</code> resources can create realms. Control this with standard Kubernetes RoleBindings:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: realm-creator\n  namespace: my-app\nrules:\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakrealms\"]\n    verbs: [\"create\", \"update\", \"patch\"]\n</code></pre>"},{"location":"#client-creation","title":"Client Creation","text":"<p>Clients require namespace authorization from the realm. Realm owners grant access via <code>clientAuthorizationGrants</code>:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\nspec:\n  clientAuthorizationGrants:\n    - dev-team-namespace\n    - staging-namespace\n</code></pre> <p>Only namespaces in the grant list can create clients in that realm.</p> <p>\ud83d\udcd6 Full Security Model Documentation \u2192</p>"},{"location":"#status-observability","title":"\ud83d\udcca Status &amp; Observability","text":"<p>All resources provide comprehensive status information:</p> <pre><code>status:\n  phase: Ready\n  conditions:\n    - type: Ready\n      status: \"True\"\n      reason: ReconciliationSucceeded\n      message: \"Realm is healthy and synchronized\"\n  observedGeneration: 5\n  realmId: \"a1b2c3d4-5678-90ab-cdef-1234567890ab\"\n  internalUrl: \"http://keycloak.keycloak-system.svc:8080/realms/my-app\"\n  publicUrl: \"https://keycloak.example.com/realms/my-app\"\n</code></pre> <p>\ud83d\udcd6 Observability Guide \u2192</p>"},{"location":"#drift-detection","title":"\ud83d\udd04 Drift Detection","text":"<p>The operator continuously monitors for: - Orphaned Resources - Realms/clients in Keycloak not tracked by CRs - Configuration Drift - Manual changes to Keycloak resources - Missing Resources - CRs referencing deleted Keycloak objects</p> <p>\ud83d\udcd6 Drift Detection Guide \u2192</p>"},{"location":"#admission-webhooks","title":"\ud83d\udea6 Admission Webhooks","text":"<p>Validate resources before they reach etcd: - \u2705 Immediate error feedback on <code>kubectl apply</code> - \u2705 Enforce resource quotas (max realms per namespace) - \u2705 Validate cross-resource references - \u2705 Prevent invalid configurations</p> <p>\ud83d\udcd6 Admission Webhooks Guide \u2192</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions welcome! See the Development Guide for: - Setting up your development environment - Running tests - Submitting pull requests - Architecture decision records (ADRs)</p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>MIT License - see LICENSE for details.</p>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Discussions</li> <li>Releases</li> </ul>"},{"location":"admission-webhooks/","title":"Admission Webhooks","text":"<p>The Keycloak Operator includes Kubernetes admission webhooks that validate resource specifications before they are stored in etcd. This provides immediate feedback on configuration errors and enforces resource quotas.</p>"},{"location":"admission-webhooks/#what-are-admission-webhooks","title":"What Are Admission Webhooks?","text":"<p>Admission webhooks intercept requests to the Kubernetes API server and validate them before the resources are persisted. This means:</p> <ul> <li>Immediate feedback: <code>kubectl apply</code> fails immediately if the spec is invalid</li> <li>Clear error messages: You see exactly what's wrong and how to fix it</li> <li>Prevention: Invalid resources never enter etcd</li> <li>Better GitOps: ArgoCD/Flux show validation errors immediately</li> </ul> <p>Without webhooks, Pydantic validation happens during reconciliation, which means resources appear created successfully but fail later.</p>"},{"location":"admission-webhooks/#features","title":"Features","text":""},{"location":"admission-webhooks/#1-specification-validation","title":"1. Specification Validation","text":"<p>Validates resource specs against business rules:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: invalid-realm\nspec:\n  keycloakRef:\n    name: \"INVALID NAME!\"  # \u274c Fails immediately: invalid format\n    namespace: default\n</code></pre> <p>Error message: <pre><code>Error from server: admission webhook \"validate.keycloakrealm.vriesdemichael.github.io\" denied the request:\nInvalid keycloakRef.name: must match pattern ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\n</code></pre></p>"},{"location":"admission-webhooks/#2-resource-quotas","title":"2. Resource Quotas","text":"<p>Enforces limits to prevent namespace abuse:</p> <p>Realms per namespace (configured in Keycloak CR): <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak\n  namespace: keycloak-system\nspec:\n  realmQuota:\n    perNamespace: 5  # Max 5 realms per namespace\n</code></pre></p> <p>Clients per namespace (configured in webhook settings): <pre><code>webhooks:\n  enabled: true\n  quotas:\n    clientsPerNamespace: 50  # Max 50 clients per namespace\n</code></pre></p> <p>When quota is exceeded: <pre><code>Error from server: admission webhook \"validate.keycloakrealm.vriesdemichael.github.io\" denied the request:\nNamespace 'tenant-a' has reached the maximum of 5 realms.\nDelete an existing realm before creating a new one.\n</code></pre></p>"},{"location":"admission-webhooks/#3-one-keycloak-per-namespace","title":"3. One Keycloak Per Namespace","text":"<p>Prevents conflicts by enforcing only one Keycloak instance per namespace:</p> <pre><code># First Keycloak - OK\napiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak-primary\n  namespace: keycloak-system\n---\n# Second Keycloak - REJECTED\napiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak-secondary  # \u274c Fails: already have keycloak-primary\n  namespace: keycloak-system\n</code></pre> <p>Error message: <pre><code>Error from server: admission webhook \"validate.keycloak.vriesdemichael.github.io\" denied the request:\nOnly one Keycloak instance allowed per namespace.\nExisting instance: keycloak-primary\n</code></pre></p>"},{"location":"admission-webhooks/#prerequisites","title":"Prerequisites","text":""},{"location":"admission-webhooks/#cert-manager-required-for-webhooks","title":"cert-manager (Required for Webhooks)","text":"<p>Admission webhooks require TLS certificates for secure communication with the Kubernetes API server. The operator uses cert-manager to automatically generate and rotate these certificates.</p> <p>If you have cert-manager installed (most production clusters do): - Webhooks work out of the box - Certificates are automatically managed - No additional configuration needed</p> <p>If you don't have cert-manager:</p> <p>Option 1 - Install cert-manager (recommended): <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.4/cert-manager.yaml\nkubectl wait --for=condition=available deployment/cert-manager -n cert-manager --timeout=2m\n</code></pre></p> <p>Option 2 - Disable webhooks: <pre><code># values.yaml\nwebhooks:\n  enabled: false\n</code></pre></p> <p>Note: Disabling webhooks means you won't get immediate validation feedback. Resources will still be validated during reconciliation via Pydantic, but errors will appear in the operator logs and resource status rather than blocking <code>kubectl apply</code>.</p> <p>See Decision Record 065 for technical details on why cert-manager is used.</p>"},{"location":"admission-webhooks/#configuration","title":"Configuration","text":"<p>Webhooks are configured in the operator Helm chart <code>values.yaml</code>:</p> <pre><code>webhooks:\n  # Enable/disable admission webhooks\n  enabled: true\n\n  # Webhook server port (internal)\n  port: 8443\n\n  # Timeout for webhook responses\n  timeoutSeconds: 10\n\n  # Failure policy: Fail (reject on error) or Ignore (allow on error)\n  # Fail = fail-closed (more secure)\n  # Ignore = fail-open (more available)\n  failurePolicy: Fail\n\n  # Resource quotas\n  quotas:\n    # Maximum realms per namespace (0 = unlimited)\n    realmsPerNamespace: 10\n\n    # Maximum clients per namespace (0 = unlimited)\n    clientsPerNamespace: 100\n</code></pre>"},{"location":"admission-webhooks/#disabling-webhooks","title":"Disabling Webhooks","text":"<p>If you don't want admission webhooks (e.g., for testing or if you have external validation):</p> <pre><code>webhooks:\n  enabled: false\n</code></pre> <p>Note: With webhooks disabled, validation still happens via Pydantic during reconciliation, but you won't get immediate feedback.</p>"},{"location":"admission-webhooks/#how-it-works","title":"How It Works","text":"<pre><code>sequenceDiagram\n    participant User\n    participant K8s API\n    participant Webhook\n    participant Etcd\n    participant Operator\n\n    User-&gt;&gt;K8s API: kubectl apply realm.yaml\n    K8s API-&gt;&gt;Webhook: Validate admission request\n    alt Invalid spec\n        Webhook-&gt;&gt;K8s API: Deny with error message\n        K8s API-&gt;&gt;User: Error: validation failed\n    else Valid spec\n        Webhook-&gt;&gt;K8s API: Allow\n        K8s API-&gt;&gt;Etcd: Store resource\n        Etcd-&gt;&gt;Operator: Watch event\n        Operator-&gt;&gt;Operator: Reconcile (Pydantic validates again)\n    end</code></pre>"},{"location":"admission-webhooks/#bootstrap-considerations","title":"Bootstrap Considerations","text":"<p>When deploying the operator for the first time:</p> <ol> <li>Operator pod must be ready before creating Keycloak CRs</li> <li>Webhook server must be listening on port 8443</li> <li>ValidatingWebhookConfiguration must be created (auto-managed by Kopf)</li> </ol> <p>The operator Helm chart handles this via:</p> <ul> <li>Readiness probe: Checks both <code>/healthz</code> endpoint AND webhook port 8443</li> <li>Helm --wait: Waits for operator pod to be ready before completing</li> <li>ArgoCD sync waves: Operator in wave 0, realms in wave 1, clients in wave 2</li> </ul> <p>When deploying with ArgoCD, use sync waves to ensure proper ordering:</p> <pre><code># Operator application (wave 0)\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: keycloak-operator\n  annotations:\n    argocd.argoproj.io/sync-wave: \"0\"\n# ...\n\n# Realm application (wave 1)\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-realm\n  annotations:\n    argocd.argoproj.io/sync-wave: \"1\"\n# ...\n</code></pre>"},{"location":"admission-webhooks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"admission-webhooks/#webhook-timeout","title":"Webhook Timeout","text":"<p>Symptom: <code>context deadline exceeded</code> error when creating resources</p> <p>Cause: Webhook server not responding within <code>timeoutSeconds</code></p> <p>Solutions: 1. Check operator logs: <code>kubectl logs -l app.kubernetes.io/name=keycloak-operator -n keycloak-system</code> 2. Check operator pod is ready: <code>kubectl get pods -n keycloak-system</code> 3. Check webhook service has endpoints: <code>kubectl get endpoints -n keycloak-system</code> 4. Increase timeout (if needed): <code>webhooks.timeoutSeconds: 30</code></p>"},{"location":"admission-webhooks/#webhook-connection-refused","title":"Webhook Connection Refused","text":"<p>Symptom: <code>dial tcp: connection refused</code> error</p> <p>Cause: Operator pod not ready yet, or webhook server crashed</p> <p>Solutions: 1. Wait for operator pod to be ready: <code>kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=keycloak-operator</code> 2. Check operator logs for startup errors 3. Verify RBAC permissions for <code>validatingwebhookconfigurations</code></p>"},{"location":"admission-webhooks/#validation-errors","title":"Validation Errors","text":"<p>Symptom: <code>admission webhook denied the request: ...</code></p> <p>Cause: Your resource spec doesn't pass validation</p> <p>Solution: Read the error message carefully - it tells you exactly what's wrong:</p> <pre><code>Error from server: admission webhook \"validate.keycloakrealm.vriesdemichael.github.io\" denied the request:\nInvalid spec.keycloakRef.name: must match pattern ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$\n</code></pre> <p>Fix the spec according to the error message.</p>"},{"location":"admission-webhooks/#bypassing-webhooks-emergency-only","title":"Bypassing Webhooks (Emergency Only)","text":"<p>If webhooks are blocking critical operations and you need to bypass them temporarily:</p> <pre><code># Disable webhooks in Helm values\nhelm upgrade keycloak-operator charts/keycloak-operator \\\n  --set webhooks.enabled=false --wait\n\n# Or delete the webhook config manually\nkubectl delete validatingwebhookconfiguration -l kopf.zalando.org/managed=vriesdemichael.github.io\n</code></pre> <p>\u26a0\ufe0f Warning: This disables validation. Only use for emergency recovery.</p>"},{"location":"admission-webhooks/#monitoring","title":"Monitoring","text":"<p>Check webhook health via metrics (if Prometheus enabled):</p> <pre><code># Webhook request rate\nrate(kopf_admission_requests_total[5m])\n\n# Webhook rejections\nrate(kopf_admission_rejections_total[5m])\n\n# Webhook latency\nhistogram_quantile(0.95, rate(kopf_admission_duration_seconds_bucket[5m]))\n</code></pre> <p>Or check operator logs:</p> <pre><code>kubectl logs -l app.kubernetes.io/name=keycloak-operator -n keycloak-system | grep -i webhook\n</code></pre>"},{"location":"admission-webhooks/#technical-details","title":"Technical Details","text":"<ul> <li>Implementation: Uses Kopf's <code>@kopf.on.validate()</code> decorators</li> <li>Certificates: Self-signed, auto-generated by Kopf (via <code>kopf[dev]</code> extra)</li> <li>CA Bundle: Automatically injected into ValidatingWebhookConfigurations by Kopf</li> <li>Cert Rotation: Handled automatically by Kopf</li> <li>Management: ValidatingWebhookConfigurations auto-created and managed by operator</li> </ul> <p>See ADR-040: Admission Webhooks for design rationale.</p>"},{"location":"development/","title":"Development Guide","text":"<p>This guide covers everything you need to know to develop, test, and contribute to the Keycloak Operator.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":"<p>Before starting development, ensure you have these tools installed:</p> Tool Version Purpose Installation Python 3.11+ Operator runtime python.org uv Latest Python package manager <code>curl -LsSf https://astral.sh/uv/install.sh \\| sh</code> Docker 20.10+ Build container images docker.com kubectl 1.26+ Kubernetes CLI kubernetes.io kind 0.20+ Local Kubernetes clusters kind.sigs.k8s.io helm 3.8+ Package manager helm.sh make Latest Build automation Usually pre-installed on Linux/macOS yq 4.x YAML processing github.com/mikefarah/yq jq 1.6+ JSON processing Usually available via package manager"},{"location":"development/#environment-setup","title":"Environment Setup","text":"<p>Install dependencies with uv:</p> <pre><code># Clone the repository\ngit clone https://github.com/vriesdemichael/keycloak-operator.git\ncd keycloak-operator\n\n# Install all dependencies and pre-commit hooks\nmake setup\n\n# Or manually:\nuv sync --group dev --group docs\nmake install-hooks\n</code></pre> <p>This will: - Create a virtual environment managed by uv - Install all Python dependencies (runtime, dev, docs, quality) - Set up pre-commit hooks for code quality - Configure your local environment</p>"},{"location":"development/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Pre-commit hooks automatically run code quality checks before each commit:</p> <pre><code># Install hooks (done automatically with 'make setup')\nmake install-hooks\n\n# Run hooks manually on all files\nuv run --group quality pre-commit run --all-files\n\n# Skip hooks for a specific commit (not recommended)\ngit commit --no-verify\n</code></pre> <p>The hooks will: - Format code with Ruff - Lint code with Ruff (with auto-fix) - Run type checking with Basedpyright - Check YAML, Markdown, and other file formats - Validate conventional commit messages</p>"},{"location":"development/#coding-standards","title":"Coding Standards","text":"<p>The project enforces high code quality standards. Always run quality checks before committing:</p> <pre><code># Run all quality checks (linting, formatting, type checking)\nmake quality\n\n# Individual checks\nmake format          # Format code with Ruff\nmake lint           # Lint code with Ruff (with auto-fix)\nmake type-check     # Type check with Basedpyright\n</code></pre> <p>Development Workflow: 1. Make your code changes 2. Run <code>make quality</code> to fix formatting and find issues 3. Fix any type errors or linting issues 4. Run <code>make test-unit</code> to verify unit tests pass 5. Commit your changes (pre-commit hooks will run automatically)</p> <p>Note: Pre-commit hooks enforce these standards automatically, but you can also run them manually.</p>"},{"location":"development/#running-the-operator-locally","title":"Running the Operator Locally","text":"<p>You can run the operator process directly (it will watch the cluster your kubeconfig points to):</p> <pre><code>uv run keycloak-operator\n</code></pre> <p>This is useful for: - Quick testing of code changes - Debugging with print statements or debuggers - Watching logs in real-time - Rapid iteration without building container images</p> <p>Requirements: - Active Kubernetes cluster (minikube, kind, or remote cluster) - kubectl configured to point to that cluster - CRDs installed on the cluster - (Optional) Keycloak instance running in the cluster</p>"},{"location":"development/#testing","title":"Testing","text":"<p>The project has comprehensive test coverage with two types of tests:</p>"},{"location":"development/#unit-tests","title":"Unit Tests","text":"<p>Fast tests that mock Kubernetes and Keycloak interactions:</p> <pre><code># Run all unit tests\nmake test-unit\n\n# Run specific test file\nuv run pytest tests/unit/test_keycloak_admin.py\n\n# Run with coverage report\nuv run pytest tests/unit --cov=src/keycloak_operator --cov-report=html\n</code></pre> <p>When to write unit tests: - Testing business logic in reconcilers - Validating data transformations - Testing utility functions - Verifying error handling</p>"},{"location":"development/#integration-tests","title":"Integration Tests","text":"<p>Real Kubernetes tests using Kind clusters:</p> <pre><code># Run complete test suite (creates cluster, runs tests, cleans up)\nmake test\n\n# Run only integration tests (reuses existing cluster for speed)\nmake test-integration\n\n# Fast iteration: reset state but keep cluster\nmake clean-integration-state &amp;&amp; make test-integration\n\n# Fresh start: destroy and recreate cluster\nmake kind-teardown &amp;&amp; make test-integration\n</code></pre> <p>Integration test workflow: 1. Creates Kind cluster (if not exists) 2. Installs CloudNativePG operator 3. Deploys test Keycloak instance 4. Builds operator container image 5. Deploys operator via Helm 6. Runs tests against real cluster 7. (Optional) Cleans up cluster</p> <p>When to write integration tests: - Testing end-to-end resource creation/update/deletion - Verifying operator behavior in real Kubernetes environment - Testing multi-resource interactions - Validating status updates and reconciliation loops</p> <p>See Testing Guide for detailed testing patterns and best practices.</p>"},{"location":"development/#pre-commit-testing","title":"Pre-Commit Testing","text":"<p>CRITICAL: Always run the complete test suite before committing changes to operator code:</p> <pre><code># Required before committing operator or chart changes\nmake test-pre-commit\n</code></pre> <p>This ensures: - Code quality checks pass - Unit tests pass - Integration tests pass on fresh cluster - No regressions introduced</p>"},{"location":"development/#code-architecture","title":"Code Architecture","text":"<p>The operator follows a clean layered architecture:</p> <pre><code>%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#00b8d9','primaryTextColor':'#fff','primaryBorderColor':'#0097a7','lineColor':'#00acc1','secondaryColor':'#006064','tertiaryColor':'#fff'}}}%%\ngraph TB\n    root[\"\ud83d\udcc1 src/keycloak_operator/\"]\n\n    models[\"\ud83d\udcc1 models/&lt;br/&gt;&lt;small&gt;Pydantic models for CRDs&lt;/small&gt;\"]\n    keycloak_py[\"\ud83d\udcc4 keycloak.py&lt;br/&gt;&lt;small&gt;Keycloak CRD spec/status&lt;/small&gt;\"]\n    realm_py[\"\ud83d\udcc4 realm.py&lt;br/&gt;&lt;small&gt;KeycloakRealm CRD spec/status&lt;/small&gt;\"]\n    client_py[\"\ud83d\udcc4 client.py&lt;br/&gt;&lt;small&gt;KeycloakClient CRD spec/status&lt;/small&gt;\"]\n    keycloak_api[\"\ud83d\udcc4 keycloak_api.py&lt;br/&gt;&lt;small&gt;Keycloak Admin API models&lt;/small&gt;\"]\n\n    handlers[\"\ud83d\udcc1 handlers/&lt;br/&gt;&lt;small&gt;Kopf event handlers (thin layer)&lt;/small&gt;\"]\n    h_keycloak[\"\ud83d\udcc4 keycloak.py\"]\n    h_realm[\"\ud83d\udcc4 realm.py\"]\n    h_client[\"\ud83d\udcc4 client.py\"]\n    h_timers[\"\ud83d\udcc4 timers.py&lt;br/&gt;&lt;small&gt;Drift detection&lt;/small&gt;\"]\n\n    services[\"\ud83d\udcc1 services/&lt;br/&gt;&lt;small&gt;Business logic (thick layer)&lt;/small&gt;\"]\n    s_keycloak[\"\ud83d\udcc4 keycloak_reconciler.py\"]\n    s_realm[\"\ud83d\udcc4 realm_reconciler.py\"]\n    s_client[\"\ud83d\udcc4 client_reconciler.py\"]\n    s_drift[\"\ud83d\udcc4 drift_detection.py\"]\n\n    utils[\"\ud83d\udcc1 utils/&lt;br/&gt;&lt;small&gt;Reusable utilities&lt;/small&gt;\"]\n    u_admin[\"\ud83d\udcc4 keycloak_admin.py\"]\n    u_k8s[\"\ud83d\udcc4 kubernetes.py\"]\n    u_rate[\"\ud83d\udcc4 rate_limiter.py\"]\n    u_valid[\"\ud83d\udcc4 validation.py\"]\n\n    observability[\"\ud83d\udcc1 observability/&lt;br/&gt;&lt;small&gt;Monitoring &amp; logging&lt;/small&gt;\"]\n    o_metrics[\"\ud83d\udcc4 metrics.py\"]\n    o_logging[\"\ud83d\udcc4 logging.py\"]\n\n    errors[\"\ud83d\udcc1 errors/&lt;br/&gt;&lt;small&gt;Custom exceptions&lt;/small&gt;\"]\n    e_ops[\"\ud83d\udcc4 operator_errors.py\"]\n\n    root --&gt; models\n    root --&gt; handlers\n    root --&gt; services\n    root --&gt; utils\n    root --&gt; observability\n    root --&gt; errors\n\n    models --&gt; keycloak_py\n    models --&gt; realm_py\n    models --&gt; client_py\n    models --&gt; keycloak_api\n\n    handlers --&gt; h_keycloak\n    handlers --&gt; h_realm\n    handlers --&gt; h_client\n    handlers --&gt; h_timers\n\n    services --&gt; s_keycloak\n    services --&gt; s_realm\n    services --&gt; s_client\n    services --&gt; s_drift\n\n    utils --&gt; u_admin\n    utils --&gt; u_k8s\n    utils --&gt; u_rate\n    utils --&gt; u_valid\n\n    observability --&gt; o_metrics\n    observability --&gt; o_logging\n\n    errors --&gt; e_ops\n\n    style root fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style models fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style handlers fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style services fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style utils fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style observability fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style errors fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff</code></pre>"},{"location":"development/#design-principles","title":"Design Principles","text":"<ol> <li>Handlers are thin - They validate input and delegate to reconcilers</li> <li>Reconcilers are idempotent - Running twice produces same result</li> <li>Services contain business logic - No Kubernetes/Kopf coupling</li> <li>Models are type-safe - Pydantic validates all data</li> <li>Utils are reusable - No business logic in utilities</li> </ol> <p>See Architecture for detailed architecture diagrams and explanations.</p>"},{"location":"development/#how-to-add-new-crd-fields","title":"How to Add New CRD Fields","text":"<p>Follow these steps to add a new field to an existing CRD:</p>"},{"location":"development/#1-update-the-pydantic-model","title":"1. Update the Pydantic Model","text":"<p>Edit the appropriate model file (<code>models/keycloak.py</code>, <code>models/realm.py</code>, or <code>models/client.py</code>):</p> <pre><code># Example: Adding email verification to KeycloakRealm\nfrom pydantic import BaseModel, Field\n\nclass RealmSecurity(BaseModel):\n    \"\"\"Security settings for the realm.\"\"\"\n\n    registration_allowed: bool = Field(default=False)\n    reset_password_allowed: bool = Field(default=True)\n\n    # NEW FIELD\n    verify_email: bool = Field(\n        default=False,\n        description=\"Require users to verify their email address\"\n    )\n</code></pre>"},{"location":"development/#2-update-the-crd-schema","title":"2. Update the CRD Schema","text":"<p>The CRD schemas are auto-generated from Pydantic models, but you need to regenerate them:</p> <pre><code># Regenerate CRD schemas\nmake generate-crds\n\n# Or manually:\nuv run python scripts/generate-crds.py\n</code></pre>"},{"location":"development/#3-update-the-reconciler","title":"3. Update the Reconciler","text":"<p>Add logic to handle the new field in the appropriate reconciler:</p> <pre><code># In services/realm_reconciler.py\ndef _build_realm_config(self, spec: KeycloakRealmSpec) -&gt; RealmRepresentation:\n    \"\"\"Build Keycloak realm configuration from CRD spec.\"\"\"\n    config = RealmRepresentation(\n        realm=spec.realm_name,\n        enabled=True,\n        # ... existing fields ...\n    )\n\n    if spec.security:\n        config.registration_allowed = spec.security.registration_allowed\n        config.reset_credentials_allowed = spec.security.reset_password_allowed\n\n        # NEW FIELD HANDLING\n        config.verify_email = spec.security.verify_email\n\n    return config\n</code></pre>"},{"location":"development/#4-add-unit-tests","title":"4. Add Unit Tests","text":"<p>Test the new field behavior:</p> <pre><code># In tests/unit/test_realm_reconciler.py\n@pytest.mark.asyncio\nasync def test_realm_with_email_verification():\n    \"\"\"Test realm creation with email verification enabled.\"\"\"\n    spec = KeycloakRealmSpec(\n        realm_name=\"test\",\n        security=RealmSecurity(verify_email=True)\n    )\n\n    config = reconciler._build_realm_config(spec)\n    assert config.verify_email is True\n</code></pre>"},{"location":"development/#5-add-integration-test","title":"5. Add Integration Test","text":"<p>Test end-to-end behavior:</p> <pre><code># In tests/integration/test_realm.py\n@pytest.mark.asyncio\nasync def test_realm_email_verification(test_namespace):\n    \"\"\"Test realm with email verification configured.\"\"\"\n    realm_name = f\"test-email-{uuid.uuid4().hex[:8]}\"\n\n    realm = create_realm_resource(\n        name=realm_name,\n        namespace=test_namespace,\n        spec={\n            \"realmName\": realm_name,\n            \"security\": {\"verifyEmail\": True}\n        }\n    )\n\n    # Wait for realm to be ready\n    await wait_for_realm_ready(realm_name, test_namespace)\n\n    # Verify in Keycloak\n    keycloak_realm = await admin_client.get_realm(realm_name)\n    assert keycloak_realm.verify_email is True\n</code></pre>"},{"location":"development/#6-update-documentation","title":"6. Update Documentation","text":"<p>Update the CRD reference documentation:</p> <pre><code># Add field to docs/reference/keycloak-realm-crd.md\n| Field | Type | Required | Default | Description |\n|-------|------|----------|---------|-------------|\n| `security.verifyEmail` | boolean | No | `false` | Require email verification |\n</code></pre>"},{"location":"development/#7-run-complete-test-suite","title":"7. Run Complete Test Suite","text":"<pre><code>make test-pre-commit\n</code></pre>"},{"location":"development/#how-to-add-new-reconciliation-logic","title":"How to Add New Reconciliation Logic","text":"<p>Follow these steps to add a new feature requiring reconciliation:</p>"},{"location":"development/#1-identify-the-trigger","title":"1. Identify the Trigger","text":"<p>Determine what should trigger this reconciliation: - Create event: New resource created - Update event: Resource spec changed - Delete event: Resource deleted - Timer event: Periodic reconciliation (drift detection)</p>"},{"location":"development/#2-add-handler-if-needed","title":"2. Add Handler (if needed)","text":"<p>If this is a new resource type, create a handler:</p> <pre><code># In handlers/my_resource.py\nimport kopf\n\n@kopf.on.create('vriesdemichael.github.io', 'v1', 'myresources')\nasync def create_my_resource(spec, name, namespace, **kwargs):\n    \"\"\"Handle MyResource creation.\"\"\"\n    reconciler = MyResourceReconciler()\n    await reconciler.reconcile(name, namespace, spec)\n\n@kopf.on.update('vriesdemichael.github.io', 'v1', 'myresources')\nasync def update_my_resource(spec, name, namespace, **kwargs):\n    \"\"\"Handle MyResource updates.\"\"\"\n    reconciler = MyResourceReconciler()\n    await reconciler.reconcile(name, namespace, spec)\n</code></pre>"},{"location":"development/#3-create-reconciler-service","title":"3. Create Reconciler Service","text":"<p>Implement the business logic:</p> <pre><code># In services/my_resource_reconciler.py\nfrom keycloak_operator.utils.keycloak_admin import KeycloakAdminClient\n\nclass MyResourceReconciler:\n    \"\"\"Reconciler for MyResource custom resources.\"\"\"\n\n    async def reconcile(\n        self,\n        name: str,\n        namespace: str,\n        spec: MyResourceSpec\n    ) -&gt; None:\n        \"\"\"Reconcile MyResource to desired state.\"\"\"\n        # 1. Get current state from Keycloak\n        current = await self._get_current_state(name)\n\n        # 2. Compute desired state from spec\n        desired = self._build_desired_state(spec)\n\n        # 3. Compute diff\n        changes = self._compute_diff(current, desired)\n\n        # 4. Apply changes idempotently\n        if changes:\n            await self._apply_changes(name, changes)\n\n        # 5. Update status\n        await self._update_status(name, namespace, \"Ready\")\n</code></pre>"},{"location":"development/#4-make-it-idempotent","title":"4. Make it Idempotent","text":"<p>Ensure reconciler can run multiple times safely:</p> <pre><code>async def _apply_changes(self, name: str, changes: dict) -&gt; None:\n    \"\"\"Apply changes idempotently.\"\"\"\n    # Check if resource already exists\n    existing = await self.admin_client.get_resource(name)\n\n    if existing:\n        # Update only if changed\n        if self._has_changed(existing, changes):\n            await self.admin_client.update_resource(name, changes)\n    else:\n        # Create new resource\n        await self.admin_client.create_resource(name, changes)\n</code></pre>"},{"location":"development/#5-add-error-handling","title":"5. Add Error Handling","text":"<p>Handle errors gracefully:</p> <pre><code>from keycloak_operator.errors.operator_errors import (\n    ReconciliationError,\n    KeycloakAPIError\n)\n\nasync def reconcile(self, name: str, namespace: str, spec: MyResourceSpec) -&gt; None:\n    \"\"\"Reconcile with error handling.\"\"\"\n    try:\n        await self._reconcile_impl(name, namespace, spec)\n        await self._update_status(name, namespace, \"Ready\")\n    except KeycloakAPIError as e:\n        logger.error(f\"Keycloak API error: {e}\")\n        await self._update_status(name, namespace, \"Failed\", str(e))\n        raise ReconciliationError(f\"Failed to reconcile {name}\") from e\n    except Exception as e:\n        logger.exception(f\"Unexpected error reconciling {name}\")\n        await self._update_status(name, namespace, \"Failed\", str(e))\n        raise\n</code></pre>"},{"location":"development/#6-add-metrics","title":"6. Add Metrics","text":"<p>Track reconciliation metrics:</p> <pre><code>from keycloak_operator.observability.metrics import (\n    reconciliation_duration,\n    reconciliation_total\n)\n\nasync def reconcile(self, name: str, namespace: str, spec: MyResourceSpec) -&gt; None:\n    \"\"\"Reconcile with metrics.\"\"\"\n    with reconciliation_duration.labels(resource_type=\"myresource\").time():\n        try:\n            await self._reconcile_impl(name, namespace, spec)\n            reconciliation_total.labels(\n                resource_type=\"myresource\",\n                status=\"success\"\n            ).inc()\n        except Exception:\n            reconciliation_total.labels(\n                resource_type=\"myresource\",\n                status=\"failure\"\n            ).inc()\n            raise\n</code></pre>"},{"location":"development/#7-test-thoroughly","title":"7. Test Thoroughly","text":"<p>Add comprehensive tests: - Unit tests for business logic - Integration tests for end-to-end behavior - Error case tests - Idempotency tests (run reconcile twice, verify same result)</p>"},{"location":"development/#docs-workflow","title":"Docs Workflow","text":"<pre><code># Live reload documentation (for viewing only, not for development)\nuv run --group docs mkdocs serve\n\n# Build static site\nuv run --group docs mkdocs build\n\n# Verify no build errors\nuv run --group docs mkdocs build --strict\n</code></pre>"},{"location":"development/#generating-api-reference","title":"Generating API Reference","text":"<p>API reference pages are generated automatically by mkdocstrings using the nav entry defined in <code>mkdocs.yml</code>. Add new modules under <code>keycloak_operator/</code> and they will appear after a rebuild if referenced.</p> <p>To add a new explicit page:</p> <pre><code>::: keycloak_operator.utils.kubernetes\n</code></pre>"},{"location":"development/#release-checklist-draft","title":"Release Checklist (Draft)","text":"<ol> <li>Update version in <code>pyproject.toml</code></li> <li>Ensure changelog section is complete</li> <li>Run full test suite &amp; type check</li> <li>Build &amp; tag container image</li> <li>Push docs (e.g. GitHub Pages workflow)</li> </ol>"},{"location":"development/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/#common-development-issues","title":"Common Development Issues","text":"Symptom Cause Resolution <code>ModuleNotFoundError</code> Dependencies not installed Run <code>uv sync</code> or <code>make setup</code> <code>No module named 'keycloak_operator'</code> Not using uv run Always use <code>uv run &lt;command&gt;</code> or activate venv Type errors block tests Missing type annotations Run <code>uv run ty check</code> and fix issues Pre-commit hook fails Code quality issues Run <code>make quality</code> to auto-fix Integration tests fail Cluster not ready Run <code>make kind-teardown &amp;&amp; make test-integration</code> Port conflicts in tests Previous test run still active Run <code>pkill -f port-forward</code> Missing API docs Module not referenced Add <code>dotted.path</code> in markdown 404 for docs page Wrong nav path Check <code>mkdocs.yml</code> navigation Cannot connect to Keycloak Port-forward not running Use <code>keycloak_port_forward</code> fixture"},{"location":"development/#development-tips","title":"Development Tips","text":"<ol> <li>Fast iteration: Use <code>make clean-integration-state &amp;&amp; make test-integration</code> instead of full teardown</li> <li>Debug tests: Add <code>--pdb</code> flag to pytest to drop into debugger on failure</li> <li>Parallel testing: Integration tests run with 8 workers by default, use unique names</li> <li>Rate limiting: Tests automatically respect rate limits, don't bypass them</li> <li>Token issues: Check <code>kubectl get secret -A | grep token</code> for token discovery problems</li> </ol>"},{"location":"development/#contributing","title":"Contributing","text":""},{"location":"development/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a branch from <code>main</code>:    <pre><code>git checkout -b feat/my-awesome-feature\n</code></pre></p> </li> <li> <p>Make your changes following the coding standards</p> </li> <li> <p>Run complete test suite:    <pre><code>make test-pre-commit\n</code></pre></p> </li> <li> <p>Commit with conventional commits:    <pre><code>git commit -m \"feat: add awesome feature\"\n</code></pre></p> </li> </ol> <p>Commit types:    - <code>feat:</code> New feature    - <code>fix:</code> Bug fix    - <code>docs:</code> Documentation only    - <code>refactor:</code> Code restructuring    - <code>test:</code> Adding tests    - <code>chore:</code> Maintenance tasks</p> <ol> <li> <p>Push and create PR:    <pre><code>git push -u origin feat/my-awesome-feature\n</code></pre></p> </li> <li> <p>Address review comments and update PR</p> </li> </ol> <p>See CLAUDE.md in the repository root for detailed development workflow and Git practices.</p>"},{"location":"development/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Start with Quick Start</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Architecture: Architecture Guide</li> <li>Testing: Testing Guide</li> </ul> <p>Return to Home.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>This page provides answers to common questions about the Keycloak Operator.</p>"},{"location":"faq/#authorization-security","title":"Authorization &amp; Security","text":""},{"location":"faq/#how-does-authorization-work-in-this-operator","title":"How does authorization work in this operator?","text":"<p>The operator uses two-level authorization:</p> <ol> <li>Realm Creation: Controlled by Kubernetes RBAC</li> <li>Any user with RBAC permission to create `KeycloakRealm` resources can create realms</li> <li> <p>Standard Kubernetes authorization model</p> </li> <li> <p>Client Creation: Controlled by namespace grant lists</p> </li> <li>Realm owners specify which namespaces can create clients via `clientAuthorizationGrants`</li> <li>Fully declarative and GitOps-friendly</li> </ol> <p>Example: ```yaml apiVersion: vriesdemichael.github.io/v1 kind: KeycloakRealm spec:   clientAuthorizationGrants:     - my-app     - partner-team ```</p> <p>See: Security Model</p>"},{"location":"faq/#why-not-use-traditional-rbac-alone","title":"Why not use traditional RBAC alone?","text":"<p>Problem with pure RBAC: - Can't express \"team A can create clients in realm X but not realm Y\" - Requires cluster-wide RBAC updates for each team - Complex RoleBinding hierarchies for cross-namespace access</p> <p>Namespace grant benefits: - \u2705 Declarative authorization in realm manifest - \u2705 GitOps-friendly (PR workflow for access changes) - \u2705 Self-service for realm owners - \u2705 Clear audit trail in Git history</p> <p>See: Security Model</p>"},{"location":"faq/#how-do-i-grant-a-team-access-to-create-clients-in-my-realm","title":"How do I grant a team access to create clients in my realm?","text":"<p>Add their namespace to your realm's `clientAuthorizationGrants`:</p> <p>```bash kubectl patch keycloakrealm my-realm -n my-namespace --type=merge -p ' spec:   clientAuthorizationGrants:     - my-namespace     - team-b-namespace  # \u2190 Add this ' ```</p> <p>Or via GitOps: update realm manifest and create PR.</p> <p>See: Security Model</p>"},{"location":"faq/#scaling-performance","title":"Scaling &amp; Performance","text":""},{"location":"faq/#will-this-scale-beyond-high-availability","title":"Will this scale beyond high availability?","text":"<p>Yes. The operator is designed for horizontal scaling:</p> Component Scaling Limit Notes Operator 100+ replicas Stateless, leader election Keycloak 100+ replicas Session replication via Infinispan Database 10+ replicas PostgreSQL replication Teams/Namespaces 1000+ Token-based delegation Realms per instance 1000+ Limited by Keycloak, not operator <p>Real-world tested: Supports 50+ teams, 200+ realms, 100K+ users in production.</p> <p>Rate limiting prevents API overload: - Global: 50 req/s (default) - Per-namespace: 5 req/s (default) - Configurable via environment variables</p> <p>See: Architecture</p>"},{"location":"faq/#how-many-requests-can-the-operator-handle","title":"How many requests can the operator handle?","text":"<p>Default Configuration: - 50 requests/second globally - 5 requests/second per namespace - Burst capacity: 100 (global), 10 (per namespace)</p> <p>Can be increased: <pre><code>helm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --set 'operator.env[0].name=KEYCLOAK_API_GLOBAL_RATE_LIMIT_TPS' \\\n  --set 'operator.env[0].value=100' \\\n  --set 'operator.env[1].name=KEYCLOAK_API_NAMESPACE_RATE_LIMIT_TPS' \\\n  --set 'operator.env[1].value=10'\n</code></pre></p> <p>Metrics available: <pre><code>keycloak_api_rate_limit_wait_seconds\nkeycloak_api_rate_limit_acquired_total\n</code></pre></p>"},{"location":"faq/#access-administration","title":"Access &amp; Administration","text":""},{"location":"faq/#why-cant-i-access-the-keycloak-admin-console","title":"Why can't I access the Keycloak admin console?","text":"<p>By design. This operator enforces least privilege through the following principles:</p> <ol> <li>GitOps-Only Configuration: All configuration is done through CRDs (<code>KeycloakRealm</code>, <code>KeycloakClient</code>), never through manual UI changes</li> <li>No Admin Access Needed: The operator manages Keycloak on your behalf - you never need to log into Keycloak directly</li> <li>Reduced Attack Surface: No admin credentials exposed = no credential theft, no unauthorized access, no manual mistakes</li> <li>Prevents Configuration Drift: Drift detection would revert manual changes anyway, so UI access serves no purpose</li> <li>Audit Trail: All changes tracked through Git and Kubernetes API, not Keycloak's internal audit log</li> </ol> <p>The admin console is not exposed because you should never need it.</p>"},{"location":"faq/#how-do-i-verify-my-keycloak-configuration-without-the-admin-console","title":"How do I verify my Keycloak configuration without the admin console?","text":"<p>Use Kubernetes-native tools to inspect and verify your configuration:</p> <pre><code># Check realm configuration and status\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt;\n\n# View full realm spec and status\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o yaml\n\n# Check client configuration\nkubectl get keycloakclient &lt;name&gt; -n &lt;namespace&gt; -o yaml\n\n# Check operator reconciliation logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator | grep keycloakrealm/&lt;name&gt;\n</code></pre> <p>For advanced debugging (operator developers only), query Keycloak's management API directly:</p> <pre><code># Port-forward to management API (port 9000, NOT UI on port 8080)\nkubectl port-forward svc/&lt;keycloak-service&gt; -n &lt;namespace&gt; 9000:9000\n\n# Get admin token from operator-managed secret\nADMIN_USER=$(kubectl get secret &lt;keycloak-name&gt;-admin-credentials -n &lt;namespace&gt; \\\n  -o jsonpath='{.data.username}' | base64 -d)\nADMIN_PASS=$(kubectl get secret &lt;keycloak-name&gt;-admin-credentials -n &lt;namespace&gt; \\\n  -o jsonpath='{.data.password}' | base64 -d)\n\n# Authenticate to get access token\nTOKEN=$(curl -s -X POST http://localhost:9000/realms/master/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=$ADMIN_USER\" \\\n  -d \"password=$ADMIN_PASS\" \\\n  -d \"grant_type=password\" \\\n  -d \"client_id=admin-cli\" | jq -r '.access_token')\n\n# Query Keycloak API\ncurl -s http://localhost:9000/admin/realms/&lt;realm-name&gt; \\\n  -H \"Authorization: Bearer $TOKEN\" | jq .\n</code></pre> <p>Note: Even for debugging, prefer CRD status fields over direct API access. The API should only be used when diagnosing operator bugs, never for configuration.</p>"},{"location":"faq/#compatibility-requirements","title":"Compatibility &amp; Requirements","text":""},{"location":"faq/#what-keycloak-versions-are-supported","title":"What Keycloak versions are supported?","text":"<ul> <li>Minimum: Keycloak 25.0.0 (management port 9000 requirement)</li> <li>Recommended: Keycloak 26.0.0+</li> <li>Maximum: Latest Keycloak release</li> </ul> <p>Why 25.0.0+? Keycloak 25.0.0 introduced the management port (9000) for health checks, separate from user traffic (8080).</p> <p>Using older versions? Upgrade to 26.0.0: <pre><code>spec:\n  image:\n    tag: \"26.0.0\"\n</code></pre></p>"},{"location":"faq/#what-database-backends-are-supported","title":"What database backends are supported?","text":"<p>Primary: CloudNativePG (CNPG) - Kubernetes-native PostgreSQL - \u2705 Automatic backups - \u2705 High availability - \u2705 Point-in-time recovery</p> <p>Manual: External PostgreSQL - \u26a0\ufe0f You manage backups/HA - \u26a0\ufe0f Requires connection string</p> <p>Not supported: MySQL, MariaDB, H2 (Keycloak deprecated these)</p> <p>See: Database Setup Guide</p>"},{"location":"faq/#can-i-migrate-from-the-official-keycloak-operator","title":"Can I migrate from the official Keycloak operator?","text":"<p>Yes, but not automated. Manual migration required:</p> <ol> <li>Export realms from existing Keycloak</li> <li>Deploy this operator alongside (different namespace)</li> <li>Create new Keycloak with this operator</li> <li>Create KeycloakRealm/KeycloakClient CRDs</li> <li>Switch application traffic</li> <li>Decommission old operator</li> </ol> <p>Comparison table: See Migration Guide</p>"},{"location":"faq/#deployment-operations","title":"Deployment &amp; Operations","text":""},{"location":"faq/#when-should-i-use-this-operator-vs-the-official-one","title":"When should I use this operator vs the official one?","text":"<p>Choose this operator if: - \u2705 Multi-tenant environment (10+ teams) - \u2705 GitOps-first workflow - \u2705 Strong namespace isolation needed - \u2705 CloudNativePG database management</p> <p>Choose official operator if: - \u2705 Single-tenant environment - \u2705 Need Keycloak's built-in security - \u2705 Organization policy requires official operators - \u2705 Integration with Red Hat/RHSSO</p> <p>See: Migration Guide</p>"},{"location":"faq/#can-i-use-this-operator-with-argocd-flux","title":"Can I use this operator with ArgoCD / Flux?","text":"<p>Yes, fully supported. The operator is GitOps-native.</p> <p>ArgoCD Example: <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: keycloak-realm\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/company/keycloak-config\n    path: realms/team-alpha\n  destination:\n    namespace: team-alpha\n</code></pre></p> <p>Best practices: - Use SealedSecrets or external-secrets for sensitive data - Separate repos per team - Health checks via <code>status.phase</code></p> <p>See charts/README.md in the repository root for GitOps examples.</p>"},{"location":"faq/#security","title":"Security","text":""},{"location":"faq/#are-secrets-encrypted","title":"Are secrets encrypted?","text":"<p>At rest: Depends on cluster configuration - Enable Kubernetes encryption at rest - Use external secret managers (Vault, AWS Secrets Manager)</p> <p>In transit: TLS between operator and Keycloak</p> <p>Best practices: - Use SealedSecrets or SOPS for GitOps - Enable K8s encryption at rest</p>"},{"location":"faq/#how-do-i-revoke-access-to-a-compromised-namespace","title":"How do I revoke access to a compromised namespace?","text":"<p>Immediate revocation: <pre><code># Remove namespace from realm's authorization grants\nkubectl patch keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; --type=json -p '[\n  {\n    \"op\": \"remove\",\n    \"path\": \"/spec/clientAuthorizationGrants/-\",\n    \"value\": \"compromised-namespace\"\n  }\n]'\n\n# Or edit directly\nkubectl edit keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt;\n# Remove the namespace from clientAuthorizationGrants list\n</code></pre></p> <p>Clean up existing clients: <pre><code># List clients from compromised namespace\nkubectl get keycloakclient -n compromised-namespace\n\n# Delete specific client\nkubectl delete keycloakclient &lt;client-name&gt; -n compromised-namespace\n</code></pre></p> <p>Prevention: - Use Git history to audit authorization changes - Implement approval workflow for grant additions - Monitor client creation events</p> <p>See: Security Model</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#my-realm-is-stuck-in-pending","title":"My realm is stuck in Pending","text":"<p>Check: 1. Authorization token exists and is correct 2. Keycloak instance is Ready 3. Operator can reach Keycloak API 4. No rate limiting errors</p> <pre><code># Check realm status\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt;\n\n# Check token\nkubectl get secret &lt;token-name&gt; -n &lt;namespace&gt;\n\n# Check operator logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator | grep &lt;realm-name&gt;\n</code></pre> <p>See: Troubleshooting Guide</p>"},{"location":"faq/#my-realm-authorization-not-working","title":"My realm authorization not working","text":"<p>Check: 1. Namespace is listed in <code>clientAuthorizationGrants</code> 2. Keycloak instance is Ready 3. Operator can reach Keycloak API 4. No rate limiting errors</p> <pre><code># Check realm authorization grants\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o jsonpath='{.spec.clientAuthorizationGrants}'\n\n# Check realm status\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt;\n\n# Check operator logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator | grep &lt;realm-name&gt;\n</code></pre> <p>See: Troubleshooting Guide</p>"},{"location":"faq/#getting-help","title":"Getting Help","text":"<p>Documentation: - Quick Start Guide - End-to-End Setup - Troubleshooting</p> <p>Community: - GitHub Issues - GitHub Discussions</p> <p>Before asking: 1. Check this FAQ 2. Review troubleshooting guide 3. Gather operator logs 4. Check resource status</p>"},{"location":"rbac-implementation/","title":"Namespaced RBAC Implementation","text":"<p>This document describes the namespace-scoped RBAC implementation for the Keycloak operator, which provides explicit opt-in access control for secrets and resources.</p>"},{"location":"rbac-implementation/#overview","title":"Overview","text":"<p>The operator now implements a least-privilege RBAC model where:</p> <ol> <li>Minimal cluster-wide permissions: The operator has minimal read-only ClusterRole permissions</li> <li>Namespace-scoped management: Full resource management only in the operator's own namespace</li> <li>Explicit opt-in: Teams must create a RoleBinding to grant operator access to their namespace</li> <li>Secret label requirement: Secrets must be explicitly labeled for operator access</li> </ol>"},{"location":"rbac-implementation/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Operator Namespace (e.g., keycloak-system)                  \u2502\n\u2502                                                              \u2502\n\u2502  \u251c\u2500\u2500 Operator Deployment                                     \u2502\n\u2502  \u2502   \u2514\u2500\u2500 Watches: All CRDs cluster-wide (list/watch only)    \u2502\n\u2502  \u2502                                                           \u2502\n\u2502  \u251c\u2500\u2500 Keycloak Instance (StatefulSet/Deployment)              \u2502\n\u2502  \u2502   \u2514\u2500\u2500 Runs in same namespace as operator                  \u2502\n\u2502  \u2502                                                           \u2502\n\u2502  \u2514\u2500\u2500 Full RBAC (Role) - Can manage all resources here        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2193 watches CRDs\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Team Namespace (e.g., team-a)                               \u2502\n\u2502                                                              \u2502\n\u2502  \u251c\u2500\u2500 KeycloakRealm / KeycloakClient CRDs                     \u2502\n\u2502  \u251c\u2500\u2500 Secrets (with required label)                           \u2502\n\u2502  \u2514\u2500\u2500 RoleBinding (opt-in for operator access)                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"rbac-implementation/#rbac-components","title":"RBAC Components","text":""},{"location":"rbac-implementation/#1-clusterrole-keycloak-operator-core","title":"1. ClusterRole: <code>keycloak-operator-core</code>","text":"<p>Purpose: Minimal cluster-wide permissions for CRD watching and status updates.</p> <p>Key Permissions: - List/watch CRDs across all namespaces (read-only) - Update CRD status and finalizers - Namespace discovery for validation - Leader election (cluster-wide leases) - Events creation - SubjectAccessReview for permission checks</p> <p>Does NOT include: - Full CRUD on CRDs (only list/watch) - Secret access - ConfigMap access - Workload management (Deployments, StatefulSets, etc.)</p>"},{"location":"rbac-implementation/#2-role-keycloak-operator-manager","title":"2. Role: <code>keycloak-operator-manager</code>","text":"<p>Purpose: Full resource management in the operator's own namespace.</p> <p>Scope: Operator namespace only</p> <p>Key Permissions: - Full CRUD on CRDs in operator namespace - Full CRUD on Kubernetes resources (Deployments, StatefulSets, Services, etc.) - Full CRUD on Secrets and ConfigMaps in operator namespace - Database management (CNPG clusters) - Ingress and certificate management</p>"},{"location":"rbac-implementation/#3-clusterrole-keycloak-operator-namespace-access-template","title":"3. ClusterRole: <code>keycloak-operator-namespace-access</code> (Template)","text":"<p>Purpose: Template role for teams to grant operator access to their namespace.</p> <p>Key Permissions: - Read CRDs (KeycloakRealm, KeycloakClient) - Read Secrets (with label validation enforced in code) - Create Events for status reporting</p> <p>Usage: Teams create a RoleBinding in their namespace referencing this ClusterRole.</p>"},{"location":"rbac-implementation/#secret-label-requirement","title":"Secret Label Requirement","text":"<p>All secrets used by the operator MUST have the following label:</p> <pre><code>vriesdemichael.github.io/allow-operator-read: \"true\"\n</code></pre>"},{"location":"rbac-implementation/#why-this-matters","title":"Why This Matters","text":"<p>This provides an explicit opt-in mechanism where: 1. Users must intentionally label secrets before the operator can read them 2. Prevents accidental exposure of unrelated secrets 3. Makes access control auditable and transparent 4. Follows the principle of least surprise</p>"},{"location":"rbac-implementation/#example","title":"Example","text":"<pre><code># Create a secret\nkubectl create secret generic smtp-password \\\n  --from-literal=password='mypassword' \\\n  -n my-team\n\n# Label it for operator access\nkubectl label secret smtp-password \\\n  vriesdemichael.github.io/allow-operator-read=true \\\n  -n my-team\n</code></pre>"},{"location":"rbac-implementation/#operator-deployment-helm-chart","title":"Operator Deployment (Helm Chart)","text":""},{"location":"rbac-implementation/#install-operator","title":"Install Operator","text":"<pre><code>helm install keycloak-operator charts/keycloak-operator \\\n  --namespace keycloak-system \\\n  --create-namespace \\\n  --set keycloak.enabled=true \\\n  --set keycloak.database.cnpg.enabled=true\n</code></pre>"},{"location":"rbac-implementation/#what-gets-created","title":"What Gets Created","text":"<ol> <li>Namespace: <code>keycloak-system</code> (if <code>namespace.create=true</code>)</li> <li>ServiceAccount: <code>keycloak-operator</code></li> <li>ClusterRole: <code>keycloak-operator-core</code> (minimal permissions)</li> <li>ClusterRole: <code>keycloak-operator-namespace-access</code> (template for teams)</li> <li>Role: <code>keycloak-operator-manager</code> (in operator namespace)</li> <li>ClusterRoleBinding: Links ServiceAccount to core ClusterRole</li> <li>RoleBinding: Links ServiceAccount to manager Role</li> <li>Operator Deployment: Watches CRDs cluster-wide</li> <li>Keycloak Instance: Runs in operator namespace</li> </ol>"},{"location":"rbac-implementation/#realm-deployment-helm-chart","title":"Realm Deployment (Helm Chart)","text":""},{"location":"rbac-implementation/#deploy-realm-to-team-namespace","title":"Deploy Realm to Team Namespace","text":"<pre><code># Create namespace\nkubectl create namespace my-team\n\n# Create and label secrets\nkubectl create secret generic smtp-password \\\n  --from-literal=password='mypassword' \\\n  -n my-team\n\nkubectl label secret smtp-password \\\n  vriesdemichael.github.io/allow-operator-read=true \\\n  -n my-team\n\n# Deploy realm (creates RoleBinding automatically)\nhelm install my-realm charts/keycloak-realm \\\n  --namespace my-team \\\n  --set realmName=my-team \\\n  --set operatorRef.namespace=keycloak-system \\\n  --set rbac.create=true \\\n  --set smtpServer.enabled=true \\\n  --set smtpServer.host=smtp.example.com \\\n  --set smtpServer.from=noreply@my-team.com \\\n  --set smtpServer.passwordSecret.name=smtp-password\n</code></pre>"},{"location":"rbac-implementation/#what-gets-created_1","title":"What Gets Created","text":"<ol> <li>KeycloakRealm CR: Defines the realm configuration</li> <li>RoleBinding: <code>my-realm-operator-access</code> (grants operator access)</li> <li>The operator reconciles the realm in the Keycloak instance</li> </ol>"},{"location":"rbac-implementation/#verify-access","title":"Verify Access","text":"<pre><code># Check RoleBinding\nkubectl get rolebinding my-realm-operator-access -n my-team\n\n# Check realm status\nkubectl get keycloakrealm my-realm -n my-team\n\n# View realm details\nkubectl describe keycloakrealm my-realm -n my-team\n</code></pre>"},{"location":"rbac-implementation/#client-deployment-helm-chart","title":"Client Deployment (Helm Chart)","text":""},{"location":"rbac-implementation/#deploy-client-to-team-namespace","title":"Deploy Client to Team Namespace","text":"<pre><code># Deploy client (creates RoleBinding automatically)\nhelm install my-client charts/keycloak-client \\\n  --namespace my-team \\\n  --set clientId=my-client \\\n  --set realmRef.name=my-realm \\\n  --set realmRef.namespace=my-team \\\n  --set rbac.create=true \\\n  --set rbac.operatorNamespace=keycloak-system\n</code></pre>"},{"location":"rbac-implementation/#what-gets-created_2","title":"What Gets Created","text":"<ol> <li>KeycloakClient CR: Defines the client configuration</li> <li>RoleBinding: <code>my-client-operator-access</code> (grants operator access)</li> <li>The operator reconciles the client in the specified realm</li> </ol>"},{"location":"rbac-implementation/#manual-rolebinding-creation","title":"Manual RoleBinding Creation","text":"<p>If you prefer to create RoleBindings manually (or <code>rbac.create=false</code>):</p> <pre><code>kubectl create rolebinding keycloak-operator-access \\\n  --clusterrole=keycloak-operator-namespace-access \\\n  --serviceaccount=keycloak-system:keycloak-operator \\\n  -n my-team\n</code></pre>"},{"location":"rbac-implementation/#error-handling","title":"Error Handling","text":""},{"location":"rbac-implementation/#missing-rolebinding","title":"Missing RoleBinding","text":"<p>Error: <code>Operator does not have access to namespace 'my-team'</code></p> <p>Solution: Create the RoleBinding:</p> <pre><code>kubectl create rolebinding keycloak-operator-access \\\n  --clusterrole=keycloak-operator-namespace-access \\\n  --serviceaccount=keycloak-system:keycloak-operator \\\n  -n my-team\n</code></pre>"},{"location":"rbac-implementation/#missing-secret-label","title":"Missing Secret Label","text":"<p>Error: <code>Secret 'smtp-password' in namespace 'my-team' is missing required label 'vriesdemichael.github.io/allow-operator-read=true'</code></p> <p>Solution: Label the secret:</p> <pre><code>kubectl label secret smtp-password \\\n  vriesdemichael.github.io/allow-operator-read=true \\\n  -n my-team\n</code></pre>"},{"location":"rbac-implementation/#secret-not-found","title":"Secret Not Found","text":"<p>Error: <code>Secret 'smtp-password' not found in namespace 'my-team'</code></p> <p>Solution: Create the secret:</p> <pre><code>kubectl create secret generic smtp-password \\\n  --from-literal=password='mypassword' \\\n  -n my-team\n\nkubectl label secret smtp-password \\\n  vriesdemichael.github.io/allow-operator-read=true \\\n  -n my-team\n</code></pre>"},{"location":"rbac-implementation/#revoking-access","title":"Revoking Access","text":"<p>To revoke operator access to a namespace:</p> <pre><code>kubectl delete rolebinding keycloak-operator-access -n my-team\n</code></pre> <p>Note: Existing resources will continue to work, but the operator will not be able to reconcile changes.</p>"},{"location":"rbac-implementation/#auditing","title":"Auditing","text":""},{"location":"rbac-implementation/#find-namespaces-with-operator-access","title":"Find Namespaces with Operator Access","text":"<pre><code>kubectl get rolebindings -A \\\n  -o json | jq -r '.items[] | select(.subjects[]?.name == \"keycloak-operator\") | \"\\(.metadata.namespace)/\\(.metadata.name)\"'\n</code></pre>"},{"location":"rbac-implementation/#find-labeled-secrets","title":"Find Labeled Secrets","text":"<pre><code>kubectl get secrets -A \\\n  -l vriesdemichael.github.io/allow-operator-read=true \\\n  -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name\n</code></pre>"},{"location":"rbac-implementation/#check-operator-permissions","title":"Check Operator Permissions","text":"<pre><code># Check if operator can read secrets in a namespace\nkubectl auth can-i get secrets \\\n  --as=system:serviceaccount:keycloak-system:keycloak-operator \\\n  -n my-team\n</code></pre>"},{"location":"rbac-implementation/#testing","title":"Testing","text":"<p>Run the integration tests:</p> <pre><code>make test-integration\n</code></pre> <p>This validates: - Operator deployment with minimal RBAC - Realm creation in different namespace - Client creation in different namespace - Secret label validation - RoleBinding creation - Reconciliation with proper permissions</p>"},{"location":"rbac-implementation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"rbac-implementation/#operator-logs","title":"Operator Logs","text":"<pre><code>kubectl logs -n keycloak-system -l app.kubernetes.io/name=keycloak-operator --tail=100 -f\n</code></pre>"},{"location":"rbac-implementation/#check-rbac-resources","title":"Check RBAC Resources","text":"<pre><code># Check ClusterRoles\nkubectl get clusterrole | grep keycloak-operator\n\n# Check Role in operator namespace\nkubectl get role -n keycloak-system\n\n# Check RoleBindings in a namespace\nkubectl get rolebinding -n my-team\n</code></pre>"},{"location":"rbac-implementation/#verify-secret-label","title":"Verify Secret Label","text":"<pre><code>kubectl get secret smtp-password -n my-team -o jsonpath='{.metadata.labels}'\n</code></pre>"},{"location":"rbac-implementation/#references","title":"References","text":"<ul> <li>Operator Chart: <code>charts/keycloak-operator/</code></li> <li>Realm Chart: <code>charts/keycloak-realm/</code></li> <li>Client Chart: <code>charts/keycloak-client/</code></li> <li>Integration Tests: <code>tests/integration/</code></li> </ul>"},{"location":"versioning/","title":"Documentation &amp; Chart Versioning","text":"<p>This project maintains versioned documentation and Helm charts to ensure you can access information and artifacts for any release.</p>"},{"location":"versioning/#documentation-versions","title":"Documentation Versions","text":"<p>The documentation is versioned using mike, which provides:</p> <ul> <li>Version Selector: A dropdown in the documentation header to switch between versions</li> <li>Stable Documentation: Each operator chart release has its own documentation snapshot</li> <li>Development Version: The <code>dev</code> version reflects the latest main branch</li> </ul> <p>Chart-Driven Versioning</p> <p>Documentation versions follow the operator chart version, not the operator image version. This ensures documentation stays synchronized with the Helm charts users actually deploy.</p>"},{"location":"versioning/#available-versions","title":"Available Versions","text":"<ul> <li>latest - Documentation for the most recent operator chart release</li> <li>dev - Documentation from the main branch (may include unreleased features)</li> <li>v0.1.x - Documentation for specific operator chart releases (e.g., v0.1.4, v0.1.3)</li> </ul>"},{"location":"versioning/#accessing-specific-versions","title":"Accessing Specific Versions","text":"<p>Use the version selector in the top-left corner of the documentation, or access versions directly:</p> <ul> <li>Latest: https://vriesdemichael.github.io/keycloak-operator/</li> <li>Development: https://vriesdemichael.github.io/keycloak-operator/dev/</li> <li>Specific version: <code>https://vriesdemichael.github.io/keycloak-operator/v0.1.4/</code></li> </ul>"},{"location":"versioning/#helm-chart-versions","title":"Helm Chart Versions","text":"<p>All chart versions are preserved in the Helm repository. You can view available versions and install specific ones.</p>"},{"location":"versioning/#list-available-versions","title":"List Available Versions","text":"<pre><code># Add the Helm repository\nhelm repo add keycloak-operator https://vriesdemichael.github.io/keycloak-operator/charts\nhelm repo update\n\n# List all available versions\nhelm search repo keycloak-operator --versions\n</code></pre>"},{"location":"versioning/#install-specific-version","title":"Install Specific Version","text":"<pre><code># Install a specific operator chart version\nhelm install my-keycloak keycloak-operator/keycloak-operator --version 0.1.4\n\n# Install a specific realm chart version\nhelm install my-realm keycloak-operator/keycloak-realm --version 0.1.2\n\n# Install a specific client chart version\nhelm install my-client keycloak-operator/keycloak-client --version 0.1.1\n</code></pre>"},{"location":"versioning/#chart-version-history","title":"Chart Version History","text":"<p>Each chart maintains its own independent version:</p> <ul> <li>keycloak-operator - The operator deployment chart</li> <li>keycloak-realm - Realm management chart</li> <li>keycloak-client - Client management chart</li> </ul> <p>All versions are available in the Helm repository index: https://vriesdemichael.github.io/keycloak-operator/charts/index.yaml</p>"},{"location":"versioning/#version-alignment","title":"Version Alignment","text":"<p>Documentation versions align with the operator chart versions:</p> Component Version Description Documentation v0.1.4 Matches operator chart version Operator Chart 0.1.4 Helm chart for deploying the operator Operator Image v0.2.14 Container image (referenced in chart's <code>appVersion</code>) Realm Chart 0.1.3 Helm chart for realm resources Client Chart 0.1.2 Helm chart for client resources <p>Finding Compatible Versions</p> <p>The operator chart's <code>appVersion</code> field indicates which operator image version it deploys: <pre><code>helm show chart keycloak-operator/keycloak-operator --version 0.1.4 | grep appVersion\n# Output: appVersion: \"v0.2.14\"\n</code></pre></p> <p>Documentation version v0.1.4 corresponds to operator chart version 0.1.4, which deploys operator image v0.2.14.</p>"},{"location":"versioning/#release-process","title":"Release Process","text":""},{"location":"versioning/#operator-chart-releases","title":"Operator Chart Releases","text":"<p>When an operator chart release is published (e.g., <code>chart-operator-v0.1.4</code>):</p> <ol> <li>A new documentation version is created (e.g., <code>v0.1.4</code>) and set as <code>latest</code></li> <li>The new chart version is added to the Helm repository</li> <li>All previous chart versions and documentation remain accessible</li> <li>The chart's <code>appVersion</code> indicates which operator image it deploys</li> </ol>"},{"location":"versioning/#realmclient-chart-releases","title":"Realm/Client Chart Releases","text":"<p>When a realm or client chart release is published (e.g., <code>chart-realm-v0.1.3</code>):</p> <ol> <li>The <code>latest</code> documentation is updated in-place to reflect new features</li> <li>No new documentation version is created (prevents version explosion)</li> <li>The new chart version is added to the Helm repository</li> <li>All previous chart versions remain available</li> </ol>"},{"location":"versioning/#operator-image-releases","title":"Operator Image Releases","text":"<p>When an operator image release is published (e.g., <code>v0.2.14</code>):</p> <ol> <li>The operator chart's <code>appVersion</code> is updated automatically (via PR)</li> <li>This triggers an operator chart release</li> <li>Which then creates new versioned documentation (see above)</li> </ol>"},{"location":"versioning/#development-updates","title":"Development Updates","text":"<p>When changes are pushed to the <code>main</code> branch:</p> <ol> <li>The <code>dev</code> documentation version is updated</li> <li>No new versioned documentation is created</li> <li>Helm charts are not published (only on release)</li> </ol>"},{"location":"versioning/#migration-between-versions","title":"Migration Between Versions","text":""},{"location":"versioning/#upgrading-operator","title":"Upgrading Operator","text":"<pre><code># Check current version\nhelm list\n\n# Update Helm repository\nhelm repo update\n\n# Upgrade to latest version\nhelm upgrade my-keycloak keycloak-operator/keycloak-operator\n\n# Or upgrade to specific version\nhelm upgrade my-keycloak keycloak-operator/keycloak-operator --version 0.1.4\n</code></pre>"},{"location":"versioning/#documentation-for-your-version","title":"Documentation for Your Version","text":"<p>Always refer to documentation matching your installed operator chart version:</p> <ol> <li> <p>Check your operator chart version:    <pre><code>helm list -n keycloak-system\n# Look at the CHART column, e.g., \"keycloak-operator-0.1.4\"\n</code></pre></p> </li> <li> <p>Find the matching documentation version in the version selector (e.g., <code>v0.1.4</code>)</p> </li> <li> <p>If your version is not listed, use the closest earlier version or <code>latest</code></p> </li> </ol>"},{"location":"versioning/#retention-policy","title":"Retention Policy","text":"<ul> <li>Documentation: All versions are retained indefinitely</li> <li>Helm Charts: All versions are retained indefinitely</li> <li>Container Images: See GitHub Container Registry retention policy</li> </ul>"},{"location":"versioning/#building-local-versioned-docs","title":"Building Local Versioned Docs","text":"<p>For development or offline use:</p> <pre><code># Install dependencies\nuv sync --group docs\n\n# List versions\nuv run --group docs mike list\n\n# Serve all versions locally\nuv run --group docs mike serve\n# Access at http://localhost:8000\n\n# Deploy a new version (maintainers only)\nuv run --group docs mike deploy --push v0.2.15 latest\n</code></pre>"},{"location":"versioning/#troubleshooting","title":"Troubleshooting","text":""},{"location":"versioning/#version-selector-not-showing","title":"Version Selector Not Showing","text":"<p>If the version selector doesn't appear:</p> <ol> <li>Clear browser cache</li> <li>Verify you're on the main documentation site (not a GitHub Pages preview)</li> <li>Check that multiple versions exist (use <code>mike list</code>)</li> </ol>"},{"location":"versioning/#chart-version-not-available","title":"Chart Version Not Available","text":"<p>If a chart version isn't showing:</p> <pre><code># Force refresh the Helm repository\nhelm repo update keycloak-operator\n\n# Check repository index directly\ncurl https://vriesdemichael.github.io/keycloak-operator/charts/index.yaml\n\n# Search with debug output\nhelm search repo keycloak-operator --versions --debug\n</code></pre>"},{"location":"versioning/#older-documentation-missing-content","title":"Older Documentation Missing Content","text":"<p>Some pages may not exist in older versions if they were added later. The version selector shows when each version was created, helping you understand which features were available.</p>"},{"location":"api/keycloak_operator/","title":"API Reference","text":"<p>This section documents the public Python modules of the operator.</p>"},{"location":"api/keycloak_operator/#operator-entry-point","title":"Operator Entry Point","text":"<p>Keycloak Operator - Main entry point for the Kopf-based Keycloak operator.</p> <p>This operator provides GitOps-compatible Keycloak management with: - Multi-namespace operation (watches all namespaces by default) - Dynamic client provisioning with RBAC-based authorization - Kubernetes-native security instead of Keycloak's built-in auth - Comprehensive secret management improvements</p> Usage <p>python -m keycloak_operator.operator</p> Environment Variables <p>KEYCLOAK_OPERATOR_NAMESPACES: Comma-separated list of namespaces to watch KEYCLOAK_OPERATOR_LOG_LEVEL: Logging level (DEBUG, INFO, WARNING, ERROR) KEYCLOAK_OPERATOR_DRY_RUN: Set to 'true' for dry-run mode</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator--or-with-kopf-directly","title":"Or with kopf directly:","text":"<p>kopf run keycloak_operator.operator --verbose --all-namespaces</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator._setup_coverage_signal_handler","title":"_setup_coverage_signal_handler","text":"<pre><code>_setup_coverage_signal_handler()\n</code></pre> <p>Setup SIGUSR1 signal handler to flush coverage data on demand.</p> <p>This allows graceful coverage data collection during integration tests by: 1. Sending SIGUSR1 to the operator process 2. Handler calls coverage.save() to flush data to disk 3. Coverage files can then be retrieved while operator continues running</p> <p>Only enabled when COVERAGE_PROCESS_START environment variable is set.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If coverage module is not installed when coverage is enabled</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.cleanup_handler","title":"cleanup_handler  <code>async</code>","text":"<pre><code>cleanup_handler(settings, **_)\n</code></pre> <p>Operator cleanup handler.</p> <p>This runs when the operator is shutting down and can be used to perform cleanup tasks like: - Closing database connections - Cleaning up temporary resources - Stopping metrics server - Logging shutdown information</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging()\n</code></pre> <p>Configure structured logging for the operator based on operator_settings.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.drift_detection_timer","title":"drift_detection_timer  <code>async</code>","text":"<pre><code>drift_detection_timer(**kwargs)\n</code></pre> <p>Periodic drift detection task.</p> <p>This task runs on a timer to check for drift between Keycloak state and Kubernetes CRs. It detects: - Orphaned resources (created by operator but CR deleted) - Configuration drift (CR exists but state differs) - Unmanaged resources (exist in Keycloak without operator ownership)</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.get_watched_namespaces","title":"get_watched_namespaces","text":"<pre><code>get_watched_namespaces()\n</code></pre> <p>Get the list of namespaces to watch from operator_settings.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>List of namespace names, or None to watch all namespaces</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.health_check","title":"health_check  <code>async</code>","text":"<pre><code>health_check(**_)\n</code></pre> <p>Health check probe for Kubernetes liveness/readiness checks.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary indicating operator health status</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Main entry point for the operator.</p> <p>This function: 1. Configures logging 2. Determines namespace scope 3. Configures admission webhooks (must be before kopf.run()) 4. Runs the kopf operator with appropriate settings</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.readiness_check","title":"readiness_check  <code>async</code>","text":"<pre><code>readiness_check(**_)\n</code></pre> <p>Readiness check probe - indicates if operator is ready to handle requests.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary indicating operator readiness</p>"},{"location":"api/keycloak_operator/#keycloak_operator.operator.startup_handler","title":"startup_handler  <code>async</code>","text":"<pre><code>startup_handler(settings, memo, **_)\n</code></pre> <p>Operator startup configuration.</p> <p>This handler runs once when the operator starts up and configures global operator settings including: - Resource scanning behavior - Error handling policies - Networking settings - Performance tuning - Metrics and health check endpoints - Rate limiting for Keycloak API calls - Admission webhook server</p>"},{"location":"api/keycloak_operator/#models","title":"Models","text":"<p>Pydantic models for Keycloak instance resources.</p> <p>This module defines type-safe data models for Keycloak instance specifications and status. These models ensure proper validation and provide IDE support for the operator development.</p> <p>Pydantic models for KeycloakRealm resources.</p> <p>This module defines type-safe data models for Keycloak realm specifications and status. These models enable comprehensive realm management including authentication flows, identity providers, and user federation.</p> <p>Pydantic models for KeycloakClient resources.</p> <p>This module defines type-safe data models for Keycloak client specifications and status. These models enable dynamic client provisioning across namespaces with proper validation and GitOps compatibility.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.ConnectionPoolConfig","title":"ConnectionPoolConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Database connection pool configuration.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.Keycloak","title":"Keycloak","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete Keycloak custom resource model.</p> <p>This represents the full Kubernetes custom resource including metadata, spec, and status sections.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakCondition","title":"KeycloakCondition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status condition for Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakDatabaseConfig","title":"KeycloakDatabaseConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Database configuration for Keycloak instance.</p> <p>Production-ready configuration that enforces external database usage. For CloudNativePG clusters, use standard PostgreSQL connection details.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakDatabaseConfig.validate_database_configuration","title":"validate_database_configuration","text":"<pre><code>validate_database_configuration()\n</code></pre> <p>Validate complete database configuration with production-ready requirements.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakEndpoints","title":"KeycloakEndpoints","text":"<p>               Bases: <code>BaseModel</code></p> <p>Endpoints for accessing Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakIngressConfig","title":"KeycloakIngressConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Ingress configuration for Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakInstanceRef","title":"KeycloakInstanceRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to a Keycloak instance in any namespace.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakResourceRequirements","title":"KeycloakResourceRequirements","text":"<p>               Bases: <code>BaseModel</code></p> <p>Resource requirements for Keycloak pods.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakServiceConfig","title":"KeycloakServiceConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Service configuration for Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakSpec","title":"KeycloakSpec","text":"<p>               Bases: <code>BaseModel</code></p> <p>Specification for a Keycloak instance.</p> <p>This model defines all configurable aspects of a Keycloak deployment including resources, networking, persistence, and authentication.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakStatus","title":"KeycloakStatus","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status of a Keycloak instance.</p> <p>This model represents the current state and health of a Keycloak deployment as observed by the operator.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.KeycloakTLSConfig","title":"KeycloakTLSConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>TLS configuration for Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.RealmCapacity","title":"RealmCapacity","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capacity management for realms.</p> <p>Controls how many realms can be managed by this Keycloak operator and whether new realm creation is allowed.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.keycloak.SecretReference","title":"SecretReference","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to a secret key for sensitive data.</p> <p>The secret must be in the same namespace as the resource referencing it. Cross-namespace secret references are not supported for security reasons.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.AuthenticationExecutionExport","title":"AuthenticationExecutionExport","text":"<p>               Bases: <code>BaseModel</code></p> <p>Authentication execution step configuration.</p> <p>Maps to AuthenticationExecutionExportRepresentation in Keycloak API. Represents a single step in an authentication flow.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.AuthenticationExecutionExport.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> <p>Validate that execution has either authenticator or flow reference.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.AuthenticatorConfigInfo","title":"AuthenticatorConfigInfo","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a configurable authenticator execution.</p> <p>Maps to AuthenticatorConfigRepresentation in Keycloak API. Used for authenticators that have configuration options (e.g., OTP settings).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakAuthenticationFlow","title":"KeycloakAuthenticationFlow","text":"<p>               Bases: <code>BaseModel</code></p> <p>Authentication flow configuration.</p> <p>Maps to AuthenticationFlowRepresentation in Keycloak API. Defines a complete authentication flow with its executions.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakClientScope","title":"KeycloakClientScope","text":"<p>               Bases: <code>BaseModel</code></p> <p>Client scope definition.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakEventsConfig","title":"KeycloakEventsConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Event logging configuration.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakGroup","title":"KeycloakGroup","text":"<p>               Bases: <code>BaseModel</code></p> <p>Group definition.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakIdentityProvider","title":"KeycloakIdentityProvider","text":"<p>               Bases: <code>BaseModel</code></p> <p>Identity provider configuration.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakIdentityProvider.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> <p>Validate that sensitive keys are only in configSecrets, not plaintext in config.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakIdentityProviderMapper","title":"KeycloakIdentityProviderMapper","text":"<p>               Bases: <code>BaseModel</code></p> <p>Identity provider mapper configuration.</p> <p>Mappers transform claims/attributes from the identity provider into Keycloak user attributes, roles, or session attributes.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakIdentityProviderSecretRef","title":"KeycloakIdentityProviderSecretRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to Kubernetes secret containing identity provider secrets.</p> <p>The secret must be in the same namespace as the KeycloakRealm. Cross-namespace secret references are not supported for security reasons.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakPasswordPolicy","title":"KeycloakPasswordPolicy","text":"<p>               Bases: <code>BaseModel</code></p> <p>Password policy configuration for a realm.</p> <p>Enforces password requirements for users. The policy is converted to Keycloak's \"and\"-separated policy string format.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakPasswordPolicy.to_policy_string","title":"to_policy_string","text":"<pre><code>to_policy_string()\n</code></pre> <p>Convert to Keycloak password policy string format.</p> <p>Returns:</p> Type Description <code>str</code> <p>Policy string with \" and \" separator (e.g., \"length(12) and upperCase(1) and notUsername\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakProtocolMapper","title":"KeycloakProtocolMapper","text":"<p>               Bases: <code>BaseModel</code></p> <p>Protocol mapper for client scopes.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealm","title":"KeycloakRealm","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete KeycloakRealm custom resource model.</p> <p>This represents the full Kubernetes custom resource for comprehensive realm management with authentication flows and identity providers.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmCondition","title":"KeycloakRealmCondition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status condition for KeycloakRealm resource.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmEndpoints","title":"KeycloakRealmEndpoints","text":"<p>               Bases: <code>BaseModel</code></p> <p>Endpoints for the KeycloakRealm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmFeatures","title":"KeycloakRealmFeatures","text":"<p>               Bases: <code>BaseModel</code></p> <p>Features configured for the realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmLocalization","title":"KeycloakRealmLocalization","text":"<p>               Bases: <code>BaseModel</code></p> <p>Localization configuration for a realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmRole","title":"KeycloakRealmRole","text":"<p>               Bases: <code>BaseModel</code></p> <p>Realm role definition.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmSecurity","title":"KeycloakRealmSecurity","text":"<p>               Bases: <code>BaseModel</code></p> <p>Security settings for a realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmSpec","title":"KeycloakRealmSpec","text":"<p>               Bases: <code>BaseModel</code></p> <p>Specification for a KeycloakRealm resource.</p> <p>This model defines all configurable aspects of a Keycloak realm including security, authentication, and user management settings.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmSpec.to_keycloak_config","title":"to_keycloak_config","text":"<pre><code>to_keycloak_config(include_flow_bindings=True)\n</code></pre> <p>Convert the realm specification to Keycloak API format.</p> <p>Parameters:</p> Name Type Description Default <code>include_flow_bindings</code> <code>bool</code> <p>Whether to include flow binding fields.                    Set to False when creating realm initially                    (flows don't exist yet).</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary in Keycloak Admin API format</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmSpec.validate_namespace_grants","title":"validate_namespace_grants  <code>classmethod</code>","text":"<pre><code>validate_namespace_grants(v)\n</code></pre> <p>Validate namespace names in authorization grants.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmStatus","title":"KeycloakRealmStatus","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status of a KeycloakRealm resource.</p> <p>This model represents the current state of a realm as managed by the operator.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmTheme","title":"KeycloakRealmTheme","text":"<p>               Bases: <code>BaseModel</code></p> <p>Theme configuration for a realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRealmTokenSettings","title":"KeycloakRealmTokenSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Token settings for a realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakRoles","title":"KeycloakRoles","text":"<p>               Bases: <code>BaseModel</code></p> <p>Realm and client role definitions.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakSMTPConfig","title":"KeycloakSMTPConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>SMTP server configuration with validation.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakSMTPConfig.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(__context)\n</code></pre> <p>Validate auth requirements after model construction.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakSMTPConfig.validate_auth_requirements","title":"validate_auth_requirements  <code>classmethod</code>","text":"<pre><code>validate_auth_requirements(v, info)\n</code></pre> <p>Ensure auth settings are consistent.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakSMTPPasswordSecret","title":"KeycloakSMTPPasswordSecret","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to Kubernetes secret containing SMTP password.</p> <p>The secret must be in the same namespace as the KeycloakRealm. Cross-namespace secret references are not supported for security reasons.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakUserFederation","title":"KeycloakUserFederation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete user federation configuration for LDAP/AD/Kerberos.</p> <p>This model supports: - LDAP federation with full attribute mapping - Active Directory with sAMAccountName/UPN support - Kerberos/SPNEGO authentication - User/group synchronization</p> Example LDAP configuration <p>KeycloakUserFederation(     name=\"corporate-ldap\",     provider_id=\"ldap\",     connection_url=\"ldap://ldap.example.com:389\",     users_dn=\"ou=People,dc=example,dc=org\",     bind_dn=\"cn=admin,dc=example,dc=org\",     bind_credential_secret=KeycloakUserFederationSecretRef(         name=\"ldap-credentials\",         key=\"password\"     ), )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakUserFederation.to_component_config","title":"to_component_config","text":"<pre><code>to_component_config()\n</code></pre> <p>Convert to Keycloak Components API config format.</p> <p>Keycloak's Components API expects config values as lists of strings.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Dictionary mapping config keys to list of string values</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakUserFederationMapper","title":"KeycloakUserFederationMapper","text":"<p>               Bases: <code>BaseModel</code></p> <p>User federation mapper configuration.</p> <p>Mappers transform LDAP/AD attributes into Keycloak user properties, roles, or group memberships.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakUserFederationSecretRef","title":"KeycloakUserFederationSecretRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to Kubernetes secret for user federation sensitive data.</p> <p>Used for bind credentials (LDAP) or keytab (Kerberos).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakUserFederationStatus","title":"KeycloakUserFederationStatus","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status of a user federation provider.</p> <p>This provides observability into the health and sync state of each configured user federation provider (LDAP, AD, Kerberos).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.KeycloakUserFederationSyncSettings","title":"KeycloakUserFederationSyncSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Synchronization settings for user federation.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.OperatorRef","title":"OperatorRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to the operator managing this realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.realm.RequiredActionProvider","title":"RequiredActionProvider","text":"<p>               Bases: <code>BaseModel</code></p> <p>Required action configuration.</p> <p>Maps to RequiredActionProviderRepresentation in Keycloak API. Required actions are actions users must perform (e.g., verify email, configure OTP).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClient","title":"KeycloakClient","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete KeycloakClient custom resource model.</p> <p>This represents the full Kubernetes custom resource for dynamic client provisioning with cross-namespace support.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientAuthenticationFlow","title":"KeycloakClientAuthenticationFlow","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for client authentication flows.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientCondition","title":"KeycloakClientCondition","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status condition for KeycloakClient resource.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientEndpoints","title":"KeycloakClientEndpoints","text":"<p>               Bases: <code>BaseModel</code></p> <p>Endpoints for the KeycloakClient.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientProtocolMapper","title":"KeycloakClientProtocolMapper","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for protocol mappers.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientScope","title":"KeycloakClientScope","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for client scopes.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientSettings","title":"KeycloakClientSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Advanced client settings.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientSpec","title":"KeycloakClientSpec","text":"<p>               Bases: <code>BaseModel</code></p> <p>Specification for a KeycloakClient resource.</p> <p>This model defines all configurable aspects of a Keycloak client including authentication, authorization, and protocol settings.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientSpec.to_keycloak_config","title":"to_keycloak_config","text":"<pre><code>to_keycloak_config()\n</code></pre> <p>Convert the client specification to Keycloak API format.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary in Keycloak Admin API format</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientSpec.validate_redirect_uris","title":"validate_redirect_uris  <code>classmethod</code>","text":"<pre><code>validate_redirect_uris(v)\n</code></pre> <p>Validate redirect URIs follow Keycloak wildcard rules.</p> <p>Keycloak allows wildcards () in specific locations: - \u2713 In path: http://localhost:3000/ or https://example.com/app/ - \u2713 Custom schemes: custom: or mycustomscheme: - \u2717 In domain: https://.example.com or http://example*.com - \u2717 Bare wildcard: * (too permissive, blocked since Keycloak 22.x)</p> <p>Wildcards can only appear at the END of the URI.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.KeycloakClientStatus","title":"KeycloakClientStatus","text":"<p>               Bases: <code>BaseModel</code></p> <p>Status of a KeycloakClient resource.</p> <p>This model represents the current state of a client as managed by the operator.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.RealmRef","title":"RealmRef","text":"<p>               Bases: <code>BaseModel</code></p> <p>Reference to a parent KeycloakRealm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.SecretMetadata","title":"SecretMetadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata to be added to the managed secret.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.models.client.ServiceAccountRoles","title":"ServiceAccountRoles","text":"<p>               Bases: <code>BaseModel</code></p> <p>Role mappings for service account users.</p>"},{"location":"api/keycloak_operator/#handlers","title":"Handlers","text":"<p>Keycloak instance handlers - Manages the core Keycloak deployment and services.</p> <p>This module handles the lifecycle of Keycloak instances including: - Creating Keycloak deployments with proper configuration - Managing services and ingress for external access - Setting up persistent storage for Keycloak data - Configuring initial admin users and realms - Health monitoring and status reporting</p> <p>The handlers in this module are designed to be idempotent and GitOps-friendly, ensuring that the desired state is maintained regardless of restart or failure.</p> <p>KeycloakRealm handlers - Manages realm lifecycle and configuration.</p> <p>This module handles realm management within Keycloak instances, including: - Creating and configuring realms - Setting up authentication flows and identity providers - Managing realm-level settings and policies - Configuring user federation and storage - Setting up realm-specific themes and localization</p> <p>Realms provide isolation between different applications or tenants and can be managed independently across different namespaces.</p> <p>KeycloakClient handlers - Manages dynamic client provisioning across namespaces.</p> <p>This module implements the core feature of dynamic client provisioning that enables GitOps-compatible client management. Key features:</p> <ul> <li>Cross-namespace client creation: Clients can reference Keycloak instances   in different namespaces (subject to RBAC permissions)</li> <li>RBAC-based authorization: Uses Kubernetes RBAC instead of Keycloak's   built-in security mechanisms</li> <li>Secure secret management: Client credentials stored in Kubernetes secrets   with proper access controls</li> <li>GitOps compatibility: All client configuration is declarative</li> </ul> <p>The handlers support various client types including: - Public clients (SPAs, mobile apps) - Confidential clients (backend services) - Service accounts for machine-to-machine communication</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.KopfHandlerKwargs","title":"KopfHandlerKwargs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type hints for common kopf handler kwargs.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.StatusProtocol","title":"StatusProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for kopf Status objects that allow dynamic attribute assignment.</p> <p>Wrapped by StatusWrapper to allow safe mutation irrespective of kopf internal status object semantics.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.StatusWrapper","title":"StatusWrapper","text":"<pre><code>StatusWrapper(patch_status)\n</code></pre> <p>               Bases: <code>MutableMapping[str, Any]</code></p> <p>Safe mutable wrapper around kopf patch.status for both item &amp; attribute access.</p> <p>Automatically converts snake_case Python attribute names to camelCase for K8s API.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.StatusWrapper._to_camel_case","title":"_to_camel_case  <code>staticmethod</code>","text":"<pre><code>_to_camel_case(snake_str)\n</code></pre> <p>Convert snake_case to camelCase.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak._perform_keycloak_cleanup","title":"_perform_keycloak_cleanup  <code>async</code>","text":"<pre><code>_perform_keycloak_cleanup(\n    name,\n    namespace,\n    spec,\n    rate_limiter,\n    trigger=\"delete_handler\",\n)\n</code></pre> <p>Perform Keycloak instance cleanup.</p> <p>This is the core cleanup logic for delete handlers. Finalizer management is handled by Kopf via settings.persistence.finalizer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak resource specification</p> required <code>rate_limiter</code> <code>Any</code> <p>Rate limiter for API calls</p> required <code>trigger</code> <code>str</code> <p>What triggered this cleanup (for logging)</p> <code>'delete_handler'</code>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.delete_keycloak_instance","title":"delete_keycloak_instance  <code>async</code>","text":"<pre><code>delete_keycloak_instance(\n    spec,\n    name,\n    namespace,\n    status,\n    patch,\n    memo,\n    retry,\n    **kwargs\n)\n</code></pre> <p>Handle Keycloak instance deletion.</p> <p>This handler performs comprehensive cleanup of all associated resources. Finalizer management is handled automatically by Kopf via settings.persistence.finalizer.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak resource specification</p> required <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>StatusProtocol</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <code>retry</code> <code>int</code> <p>Kopf retry count (starts from 0)</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.ensure_keycloak_instance","title":"ensure_keycloak_instance  <code>async</code>","text":"<pre><code>ensure_keycloak_instance(\n    spec, name, namespace, status, patch, memo, **kwargs\n)\n</code></pre> <p>Ensure Keycloak instance exists and is properly configured.</p> <p>This is the main handler for Keycloak instance creation and resumption. It implements idempotent logic that works for both initial creation and operator restarts (resume).</p> <p>Note: Deletion is handled by the @kopf.on.delete handler (delete_keycloak_instance). Do not add deletion logic here to avoid race conditions with the delete handler.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak resource specification</p> required <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>StatusProtocol</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <p>Returns:</p> Type Description <code>None</code> <p>Dictionary with status information for the resource</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.monitor_keycloak_health","title":"monitor_keycloak_health  <code>async</code>","text":"<pre><code>monitor_keycloak_health(\n    spec,\n    name,\n    namespace,\n    status,\n    patch,\n    meta,\n    memo,\n    **kwargs\n)\n</code></pre> <pre><code>Periodic health check for Keycloak instances.\n\nThis timer handler checks the health of Keycloak instances and updates\ntheir status accordingly.\n\nThe interval is configurable via TIMER_INTERVAL_KEYCLOAK environment variable.\nDefault: 600 seconds (10 minutes).\n\nArgs:\n    spec: Keycloak resource specification\n    name: Name of the Keycloak resource\n    namespace: Namespace where the resource exists\n    status: Current status of the resource\n    meta: Resource metadata\n    memo: Kopf memo for accessing shared state like rate_limiter\n\nReturns:\n    Dictionary with updated status information, or None if no changes\n</code></pre> Implementation includes <p>\u2705 Check if Keycloak deployment is running and ready \u2705 Verify that Keycloak is responding to health checks \u2705 Check resource utilization (CPU, memory, storage) \u2705 Validate that Keycloak Admin API is accessible and master realm exists \u2705 Update status with current health information \u26a0\ufe0f  Generate events for significant status changes - Future enhancement \u26a0\ufe0f  Implement alerting for persistent failures - Future enhancement</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.keycloak.update_keycloak_instance","title":"update_keycloak_instance  <code>async</code>","text":"<pre><code>update_keycloak_instance(\n    old,\n    new,\n    diff,\n    name,\n    namespace,\n    status,\n    patch,\n    memo,\n    **kwargs\n)\n</code></pre> <p>Handle updates to Keycloak instance specifications.</p> <p>This handler is called when the Keycloak resource specification changes. It delegates to the reconciler service layer for all business logic.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict[str, Any]</code> <p>Previous specification</p> required <code>new</code> <code>dict[str, Any]</code> <p>New specification</p> required <code>diff</code> <code>Diff</code> <p>List of changes between old and new</p> required <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>StatusProtocol</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>None to avoid Kopf creating status subpaths</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.StatusProtocol","title":"StatusProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for kopf Status objects that allow dynamic attribute assignment.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.StatusWrapper","title":"StatusWrapper","text":"<pre><code>StatusWrapper(patch_status)\n</code></pre> <p>Wrapper to make kopf patch.status compatible with StatusProtocol.</p> <p>This wrapper provides both attribute and dict-like access to patch.status, ensuring all updates are written directly to the underlying patch object.</p> <p>Automatically converts snake_case Python attribute names to camelCase for K8s API.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.StatusWrapper._to_camel_case","title":"_to_camel_case  <code>staticmethod</code>","text":"<pre><code>_to_camel_case(snake_str)\n</code></pre> <p>Convert snake_case to camelCase.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.StatusWrapper.update","title":"update","text":"<pre><code>update(data)\n</code></pre> <p>Update multiple fields. Assumes data keys are already in camelCase.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm._perform_realm_cleanup","title":"_perform_realm_cleanup  <code>async</code>","text":"<pre><code>_perform_realm_cleanup(\n    name,\n    namespace,\n    spec,\n    status,\n    rate_limiter,\n    trigger=\"delete_handler\",\n)\n</code></pre> <p>Perform realm cleanup from Keycloak.</p> <p>This is the core cleanup logic for delete handlers. Finalizer management is handled by Kopf via settings.persistence.finalizer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakRealm resource specification</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>rate_limiter</code> <code>Any</code> <p>Rate limiter for Keycloak API calls</p> required <code>trigger</code> <code>str</code> <p>What triggered this cleanup (for logging)</p> <code>'delete_handler'</code>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm._test_user_federation","title":"_test_user_federation  <code>async</code>","text":"<pre><code>_test_user_federation(\n    admin_client, realm_name, namespace, federation_specs\n)\n</code></pre> <p>Test user federation connections.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> required <code>federation_specs</code> <code>list</code> <p>List of user federation specifications</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if federation is healthy, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm._verify_authentication_flows","title":"_verify_authentication_flows  <code>async</code>","text":"<pre><code>_verify_authentication_flows(\n    admin_client, realm_name, namespace, flow_specs\n)\n</code></pre> <p>Verify that authentication flows exist and are configured correctly.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> required <code>flow_specs</code> <code>list</code> <p>List of expected authentication flow specifications</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if flows are valid, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm._verify_identity_providers","title":"_verify_identity_providers  <code>async</code>","text":"<pre><code>_verify_identity_providers(\n    admin_client, realm_name, namespace, idp_specs\n)\n</code></pre> <p>Verify that identity providers exist and are configured correctly.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> required <code>idp_specs</code> <code>list</code> <p>List of expected identity provider specifications</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if identity providers are valid, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm._verify_realm_config","title":"_verify_realm_config","text":"<pre><code>_verify_realm_config(current_realm, realm_spec)\n</code></pre> <p>Verify that the current realm configuration matches the spec.</p> <p>Parameters:</p> Name Type Description Default <code>current_realm</code> <code>dict[str, Any]</code> <p>Current realm configuration from Keycloak</p> required <code>realm_spec</code> <code>KeycloakRealmSpec</code> <p>Desired realm specification</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if configuration matches, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.delete_keycloak_realm","title":"delete_keycloak_realm  <code>async</code>","text":"<pre><code>delete_keycloak_realm(\n    spec,\n    name,\n    namespace,\n    status,\n    patch,\n    memo,\n    retry,\n    **kwargs\n)\n</code></pre> <p>Handle KeycloakRealm deletion.</p> <p>This handler performs comprehensive cleanup of the realm from Keycloak and any associated Kubernetes resources. Finalizer management is handled automatically by Kopf via settings.persistence.finalizer.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakRealm resource specification</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <code>retry</code> <code>int</code> <p>Kopf retry count (starts from 0)</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.ensure_keycloak_realm","title":"ensure_keycloak_realm  <code>async</code>","text":"<pre><code>ensure_keycloak_realm(\n    spec, name, namespace, status, patch, memo, **kwargs\n)\n</code></pre> <p>Ensure KeycloakRealm exists in the target Keycloak instance.</p> <p>This handler creates and configures realms in Keycloak instances. Realms can be created in Keycloak instances across namespaces, subject to RBAC permissions.</p> <p>Note: Deletion is handled by the @kopf.on.delete handler (delete_keycloak_realm). Do not add deletion logic here to avoid race conditions with the delete handler.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakRealm resource specification</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the KeycloakRealm resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <p>Returns:</p> Type Description <code>None</code> <p>Dictionary with status information for the resource</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.monitor_realm_health","title":"monitor_realm_health  <code>async</code>","text":"<pre><code>monitor_realm_health(\n    spec,\n    name,\n    namespace,\n    status,\n    patch,\n    meta,\n    memo,\n    **_kwargs\n)\n</code></pre> <p>Periodic health check for KeycloakRealms.</p> <p>This timer verifies that realms still exist in Keycloak and that their configuration matches the desired state.</p> <p>The interval is configurable via TIMER_INTERVAL_REALM environment variable. Default: 600 seconds (10 minutes).</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakRealm resource specification</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Resource metadata</p> required <code>memo</code> <code>Memo</code> <p>Kopf memo for accessing shared state like rate_limiter</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.realm.update_keycloak_realm","title":"update_keycloak_realm  <code>async</code>","text":"<pre><code>update_keycloak_realm(\n    old,\n    new,\n    diff,\n    name,\n    namespace,\n    status,\n    patch,\n    memo,\n    **kwargs\n)\n</code></pre> <p>Handle updates to KeycloakRealm specifications.</p> <p>This handler processes changes to realm configurations and applies them to the target Keycloak instance.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict[str, Any]</code> <p>Previous specification</p> required <code>new</code> <code>dict[str, Any]</code> <p>New specification</p> required <code>diff</code> <code>Diff</code> <p>List of changes</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>None to avoid Kopf creating status subpaths</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.StatusWrapper","title":"StatusWrapper","text":"<pre><code>StatusWrapper(patch_status)\n</code></pre> <p>Wrapper to make kopf patch.status compatible with StatusProtocol.</p> <p>This wrapper provides both attribute and dict-like access to patch.status, ensuring all updates are written directly to the underlying patch object.</p> <p>Automatically converts snake_case Python attribute names to camelCase for K8s API.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.StatusWrapper._to_camel_case","title":"_to_camel_case  <code>staticmethod</code>","text":"<pre><code>_to_camel_case(snake_str)\n</code></pre> <p>Convert snake_case to camelCase.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.StatusWrapper.update","title":"update","text":"<pre><code>update(data)\n</code></pre> <p>Update multiple fields. Assumes data keys are already in camelCase.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client._perform_client_cleanup","title":"_perform_client_cleanup  <code>async</code>","text":"<pre><code>_perform_client_cleanup(\n    name,\n    namespace,\n    spec,\n    status,\n    rate_limiter,\n    trigger=\"delete_handler\",\n)\n</code></pre> <p>Perform client cleanup from Keycloak.</p> <p>This is the core cleanup logic for delete handlers. Finalizer management is handled by Kopf via settings.persistence.finalizer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakClient resource specification</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>rate_limiter</code> <code>Any</code> <p>Rate limiter for Keycloak API calls</p> required <code>trigger</code> <code>str</code> <p>What triggered this cleanup (for logging)</p> <code>'delete_handler'</code>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.delete_keycloak_client","title":"delete_keycloak_client  <code>async</code>","text":"<pre><code>delete_keycloak_client(\n    spec,\n    name,\n    namespace,\n    status,\n    patch,\n    memo,\n    retry,\n    **kwargs\n)\n</code></pre> <p>Handle KeycloakClient deletion.</p> <p>This handler performs comprehensive cleanup of the client from Keycloak and any associated Kubernetes resources. Finalizer management is handled automatically by Kopf via settings.persistence.finalizer.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakClient resource specification</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <code>retry</code> <code>int</code> <p>Kopf retry count (starts from 0)</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.ensure_keycloak_client","title":"ensure_keycloak_client  <code>async</code>","text":"<pre><code>ensure_keycloak_client(\n    spec, name, namespace, status, patch, memo, **kwargs\n)\n</code></pre> <p>Ensure KeycloakClient exists in the target Keycloak instance.</p> <p>This handler implements dynamic client provisioning across namespaces. It can create clients in Keycloak instances located in any namespace, subject to RBAC permissions.</p> <p>Note: Deletion is handled by the @kopf.on.delete handler (delete_keycloak_client). Do not add deletion logic here to avoid race conditions with the delete handler.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakClient resource specification</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the KeycloakClient resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <p>Returns:</p> Type Description <code>None</code> <p>Dictionary with status information for the resource</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.monitor_client_health","title":"monitor_client_health  <code>async</code>","text":"<pre><code>monitor_client_health(\n    spec,\n    name,\n    namespace,\n    status,\n    patch,\n    meta,\n    memo,\n    **kwargs\n)\n</code></pre> <p>Periodic health check for KeycloakClients.</p> <p>This timer verifies that clients still exist in Keycloak and that their configuration matches the desired state.</p> <p>The interval is configurable via TIMER_INTERVAL_CLIENT environment variable. Default: 300 seconds (5 minutes).</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>KeycloakClient resource specification</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>meta</code> <code>dict[str, Any]</code> <p>Resource metadata</p> required <code>memo</code> <code>Memo</code> <p>Kopf memo for accessing shared state like rate_limiter</p> required <p>Returns:</p> Type Description <code>None</code> <p>Dictionary with updated status, or None if no changes needed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.monitor_client_secrets","title":"monitor_client_secrets  <code>async</code>","text":"<pre><code>monitor_client_secrets(event, logger, **kwargs)\n</code></pre> <p>Monitor client secrets and trigger reconciliation if deleted.</p> <p>If a managed secret is deleted, we must trigger reconciliation on the parent KeycloakClient to recreate it.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.handlers.client.update_keycloak_client","title":"update_keycloak_client  <code>async</code>","text":"<pre><code>update_keycloak_client(\n    old,\n    new,\n    diff,\n    name,\n    namespace,\n    status,\n    patch,\n    memo,\n    **kwargs\n)\n</code></pre> <p>Handle updates to KeycloakClient specifications.</p> <p>This handler processes changes to client configurations and applies them to the target Keycloak instance.</p> <p>Parameters:</p> Name Type Description Default <code>old</code> <code>dict[str, Any]</code> <p>Previous specification</p> required <code>new</code> <code>dict[str, Any]</code> <p>New specification</p> required <code>diff</code> <code>Diff</code> <p>List of changes</p> required <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>dict[str, Any]</code> <p>Current status of the resource</p> required <code>patch</code> <code>Patch</code> <p>Kopf patch object for modifying the resource</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>None to avoid Kopf creating status subpaths</p>"},{"location":"api/keycloak_operator/#services","title":"Services","text":"<p>Keycloak instance reconciler for managing core Keycloak deployments.</p> <p>This module handles the lifecycle of Keycloak instances including deployment, services, persistence, and administrative access.</p> <p>Keycloak realm reconciler for managing realm configuration and features.</p> <p>This module handles the lifecycle of Keycloak realms including themes, authentication flows, identity providers, and user federation.</p> <p>Keycloak client reconciler for managing OAuth2/OIDC client configuration.</p> <p>This module handles the lifecycle of Keycloak clients including client creation, credential management, and OAuth2 configuration.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler","title":"KeycloakInstanceReconciler","text":"<pre><code>KeycloakInstanceReconciler(\n    k8s_client=None,\n    keycloak_admin_factory=None,\n    rate_limiter=None,\n)\n</code></pre> <p>               Bases: <code>BaseReconciler</code></p> <p>Reconciler for Keycloak instance resources.</p> <p>Manages the complete lifecycle of Keycloak instances including: - Kubernetes deployment and scaling - Service and ingress configuration - Persistent storage setup - Admin user initialization - Production environment validation</p> <p>Initialize Keycloak instance reconciler.</p> <p>Parameters:</p> Name Type Description Default <code>k8s_client</code> <code>ApiClient | None</code> <p>Kubernetes API client</p> <code>None</code> <code>keycloak_admin_factory</code> <code>Any</code> <p>Factory function for creating Keycloak admin clients</p> <code>None</code> <code>rate_limiter</code> <code>Any</code> <p>Rate limiter for Keycloak API calls</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._delete_configuration_resources","title":"_delete_configuration_resources  <code>async</code>","text":"<pre><code>_delete_configuration_resources(name, namespace, core_api)\n</code></pre> <p>Delete secrets and configmaps associated with the Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._delete_dependent_resources","title":"_delete_dependent_resources  <code>async</code>","text":"<pre><code>_delete_dependent_resources(\n    keycloak_name, keycloak_namespace\n)\n</code></pre> <p>Delete all CRD resources that depend on this Keycloak instance.</p> <p>This implements cascading deletion by finding and deleting: 1. KeycloakClients that reference this Keycloak instance 2. KeycloakRealms that reference this Keycloak instance</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_name</code> <code>str</code> <p>Name of the Keycloak instance being deleted</p> required <code>keycloak_namespace</code> <code>str</code> <p>Namespace of the Keycloak instance</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._delete_deployment","title":"_delete_deployment  <code>async</code>","text":"<pre><code>_delete_deployment(deployment_name, namespace, apps_api)\n</code></pre> <p>Delete deployment and wait for pods to terminate.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._delete_ingress","title":"_delete_ingress  <code>async</code>","text":"<pre><code>_delete_ingress(ingress_name, namespace, networking_api)\n</code></pre> <p>Delete ingress resource.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._delete_persistent_storage","title":"_delete_persistent_storage  <code>async</code>","text":"<pre><code>_delete_persistent_storage(name, namespace, core_api)\n</code></pre> <p>Delete persistent volume claims associated with the Keycloak instance.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._delete_service","title":"_delete_service  <code>async</code>","text":"<pre><code>_delete_service(service_name, namespace, core_api)\n</code></pre> <p>Delete service resource.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._update_capacity_status","title":"_update_capacity_status  <code>async</code>","text":"<pre><code>_update_capacity_status(status, spec, namespace)\n</code></pre> <p>Update realm capacity status fields.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>StatusProtocol</code> <p>Status object to update</p> required <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>namespace</code> <code>str</code> <p>Keycloak namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._update_deployment","title":"_update_deployment  <code>async</code>","text":"<pre><code>_update_deployment(\n    deployment_name, namespace, deployment_changes, apps_api\n)\n</code></pre> <p>Update deployment with changes.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._update_ingress","title":"_update_ingress  <code>async</code>","text":"<pre><code>_update_ingress(spec, name, namespace, networking_api)\n</code></pre> <p>Update ingress configuration.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._validate_database_connectivity","title":"_validate_database_connectivity  <code>async</code>","text":"<pre><code>_validate_database_connectivity(spec, name, namespace)\n</code></pre> <p>Validate database connectivity using the new database connection manager.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with resolved database connection details</p> <p>Raises:</p> Type Description <code>ExternalServiceError</code> <p>If database connectivity validation fails</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._validate_database_production_readiness","title":"_validate_database_production_readiness  <code>async</code>","text":"<pre><code>_validate_database_production_readiness(spec, namespace)\n</code></pre> <p>Validate database configuration for production readiness.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Raises:</p> Type Description <code>DatabaseValidationError</code> <p>If database configuration is not production-ready</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._validate_database_secret","title":"_validate_database_secret  <code>async</code>","text":"<pre><code>_validate_database_secret(spec, namespace)\n</code></pre> <p>Validate that database credentials secret exists.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Raises:</p> Type Description <code>ExternalServiceError</code> <p>If database secret is missing or invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._validate_security_requirements","title":"_validate_security_requirements  <code>async</code>","text":"<pre><code>_validate_security_requirements(spec, namespace)\n</code></pre> <p>Validate security requirements for production deployments.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If security requirements are not met</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._validate_spec","title":"_validate_spec","text":"<pre><code>_validate_spec(spec)\n</code></pre> <p>Validate and parse Keycloak specification.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Raw specification dictionary</p> required <p>Returns:</p> Type Description <code>KeycloakSpec</code> <p>Validated KeycloakSpec object</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If specification is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler._wait_for_rollout","title":"_wait_for_rollout  <code>async</code>","text":"<pre><code>_wait_for_rollout(deployment_name, namespace, apps_api)\n</code></pre> <p>Wait for deployment rollout to complete.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.cleanup_resources","title":"cleanup_resources  <code>async</code>","text":"<pre><code>cleanup_resources(name, namespace, spec)\n</code></pre> <p>Clean up all resources associated with a Keycloak instance.</p> <p>This method performs comprehensive cleanup in the proper order to prevent data loss and ensure all associated resources are properly removed.</p> <p>Implements cascading deletion: 1. Delete dependent KeycloakClients 2. Delete dependent KeycloakRealms 3. Delete Kubernetes resources (deployments, services, etc.)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>namespace</code> <code>str</code> <p>Namespace containing the resources</p> required <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak specification for understanding deletion requirements</p> required <p>Raises:</p> Type Description <code>TemporaryError</code> <p>If cleanup fails but should be retried</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.do_reconcile","title":"do_reconcile  <code>async</code>","text":"<pre><code>do_reconcile(spec, name, namespace, status, **kwargs)\n</code></pre> <p>Reconcile Keycloak instance to desired state.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak resource specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status object</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Status dictionary for the resource</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.do_update","title":"do_update  <code>async</code>","text":"<pre><code>do_update(\n    old_spec,\n    new_spec,\n    diff,\n    name,\n    namespace,\n    status,\n    **kwargs\n)\n</code></pre> <p>Handle updates to Keycloak instance specifications.</p> <p>Parameters:</p> Name Type Description Default <code>old_spec</code> <code>dict[str, Any]</code> <p>Previous specification</p> required <code>new_spec</code> <code>dict[str, Any]</code> <p>New specification</p> required <code>diff</code> <code>Any</code> <p>List of changes between old and new</p> required <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Namespace where the resource exists</p> required <code>status</code> <code>StatusProtocol</code> <p>Current status of the resource</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with updated status information, or None if no changes needed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.ensure_admin_access","title":"ensure_admin_access  <code>async</code>","text":"<pre><code>ensure_admin_access(spec, name, namespace)\n</code></pre> <p>Ensure admin user is configured and accessible.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.ensure_deployment","title":"ensure_deployment  <code>async</code>","text":"<pre><code>ensure_deployment(\n    spec, name, namespace, db_connection_info=None\n)\n</code></pre> <p>Ensure Keycloak deployment exists and is up to date.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>db_connection_info</code> <code>dict[str, Any] | None</code> <p>Optional resolved database connection details</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.ensure_ingress","title":"ensure_ingress  <code>async</code>","text":"<pre><code>ensure_ingress(spec, name, namespace)\n</code></pre> <p>Ensure ingress is configured for external access.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.ensure_service","title":"ensure_service  <code>async</code>","text":"<pre><code>ensure_service(spec, name, namespace)\n</code></pre> <p>Ensure Keycloak service exists and is properly configured.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.validate_production_settings","title":"validate_production_settings  <code>async</code>","text":"<pre><code>validate_production_settings(spec, name, namespace)\n</code></pre> <p>Validate configuration for production readiness.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with resolved database connection details, or None if database not configured</p> <p>Raises:</p> Type Description <code>DatabaseValidationError</code> <p>If using H2 database inappropriately</p> <code>ValidationError</code> <p>If other production requirements not met</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.keycloak_reconciler.KeycloakInstanceReconciler.wait_for_deployment_ready","title":"wait_for_deployment_ready  <code>async</code>","text":"<pre><code>wait_for_deployment_ready(\n    name, namespace, max_wait_time=300\n)\n</code></pre> <p>Wait for deployment to be ready.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>max_wait_time</code> <code>int</code> <p>Maximum wait time in seconds</p> <code>300</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if deployment became ready, False if timed out</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler","title":"KeycloakRealmReconciler","text":"<pre><code>KeycloakRealmReconciler(\n    k8s_client=None,\n    keycloak_admin_factory=None,\n    rate_limiter=None,\n)\n</code></pre> <p>               Bases: <code>BaseReconciler</code></p> <p>Reconciler for Keycloak realm resources.</p> <p>Manages the complete configuration of Keycloak realms including: - Basic realm creation and settings - Theme and branding configuration - Authentication flows and security - Identity provider integration - User federation setup - Cross-namespace RBAC validation</p> <p>Initialize Keycloak realm reconciler.</p> <p>Parameters:</p> Name Type Description Default <code>k8s_client</code> <code>ApiClient | None</code> <p>Kubernetes API client</p> <code>None</code> <code>keycloak_admin_factory</code> <code>Any</code> <p>Factory function for creating Keycloak admin clients</p> <code>None</code> <code>rate_limiter</code> <code>Any</code> <p>Rate limiter for Keycloak API calls</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._add_flow_executions","title":"_add_flow_executions  <code>async</code>","text":"<pre><code>_add_flow_executions(\n    admin_client,\n    realm_name,\n    flow_alias,\n    flow_config,\n    namespace,\n)\n</code></pre> <p>Add executions to a newly created flow.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the flow</p> required <code>flow_config</code> <p>Flow configuration with executions</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._build_federation_component","title":"_build_federation_component  <code>async</code>","text":"<pre><code>_build_federation_component(\n    federation_config, realm_id, namespace\n)\n</code></pre> <p>Build a ComponentRepresentation from KeycloakUserFederation config.</p> <p>Handles secret injection for bind credentials and keytabs.</p> <p>Parameters:</p> Name Type Description Default <code>federation_config</code> <code>KeycloakUserFederation</code> <p>The user federation configuration</p> required <code>realm_id</code> <code>str</code> <p>The realm ID (UUID), not realm name - required for parentId</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace for secret lookups</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._build_group_map","title":"_build_group_map","text":"<pre><code>_build_group_map(groups, group_map, parent_path='')\n</code></pre> <p>Build a map of group paths to group info (including subgroups).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._check_realm_capacity","title":"_check_realm_capacity  <code>async</code>","text":"<pre><code>_check_realm_capacity(\n    keycloak_namespace, keycloak_name, realm_name\n)\n</code></pre> <p>Check if Keycloak operator has capacity for new realms.</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_namespace</code> <code>str</code> <p>Namespace containing the Keycloak instance</p> required <code>keycloak_name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm being created</p> required <p>Raises:</p> Type Description <code>PermanentError</code> <p>If capacity is exhausted and new realms are not allowed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._collect_group_paths","title":"_collect_group_paths","text":"<pre><code>_collect_group_paths(groups, paths, parent_path='')\n</code></pre> <p>Collect all group paths from the spec (including subgroups).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_authenticator_configs","title":"_configure_authenticator_configs  <code>async</code>","text":"<pre><code>_configure_authenticator_configs(\n    admin_client,\n    realm_name,\n    flow_alias,\n    flow_config,\n    namespace,\n)\n</code></pre> <p>Configure authenticator configurations for executions in a flow.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the flow</p> required <code>flow_config</code> <p>Flow configuration with authenticator configs</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_composite_roles","title":"_configure_composite_roles  <code>async</code>","text":"<pre><code>_configure_composite_roles(\n    admin_client,\n    realm_name,\n    parent_role_name,\n    desired_child_names,\n    namespace,\n)\n</code></pre> <p>Configure composite role memberships.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>parent_role_name</code> <code>str</code> <p>Name of the parent composite role</p> required <code>desired_child_names</code> <code>list[str]</code> <p>List of child role names to include</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_federation_mappers","title":"_configure_federation_mappers  <code>async</code>","text":"<pre><code>_configure_federation_mappers(\n    admin_client,\n    realm_name,\n    provider_id,\n    federation_config,\n    namespace,\n)\n</code></pre> <p>Configure mappers for a user federation provider.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_group_client_roles","title":"_configure_group_client_roles  <code>async</code>","text":"<pre><code>_configure_group_client_roles(\n    admin_client,\n    realm_name,\n    group_id,\n    client_roles,\n    namespace,\n)\n</code></pre> <p>Configure client role assignments for a group.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>client_roles</code> <code>dict[str, list[str]]</code> <p>Dict mapping client IDs to list of role names</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_group_realm_roles","title":"_configure_group_realm_roles  <code>async</code>","text":"<pre><code>_configure_group_realm_roles(\n    admin_client,\n    realm_name,\n    group_id,\n    desired_role_names,\n    namespace,\n)\n</code></pre> <p>Configure realm role assignments for a group.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>desired_role_names</code> <code>list[str]</code> <p>List of realm role names to assign</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_group_recursive","title":"_configure_group_recursive  <code>async</code>","text":"<pre><code>_configure_group_recursive(\n    admin_client,\n    realm_name,\n    group_config,\n    parent_id,\n    namespace,\n    parent_path=\"\",\n)\n</code></pre> <p>Configure a group and its subgroups recursively.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_config</code> <code>Any</code> <p>Group configuration</p> required <code>parent_id</code> <code>str | None</code> <p>ID of parent group (None for top-level)</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <code>parent_path</code> <code>str</code> <p>Path of parent group</p> <code>''</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Group ID if created/updated successfully, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._configure_identity_provider_mappers","title":"_configure_identity_provider_mappers  <code>async</code>","text":"<pre><code>_configure_identity_provider_mappers(\n    admin_client,\n    realm_name,\n    idp_alias,\n    desired_mappers,\n    namespace,\n)\n</code></pre> <p>Configure mappers for an identity provider with full lifecycle management.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <code>Any</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>idp_alias</code> <code>str</code> <p>Identity provider alias</p> required <code>desired_mappers</code> <code>list[Any]</code> <p>List of desired mapper configurations</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._delete_realm_k8s_resources","title":"_delete_realm_k8s_resources  <code>async</code>","text":"<pre><code>_delete_realm_k8s_resources(name, namespace, realm_name)\n</code></pre> <p>Delete Kubernetes resources associated with the realm.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._fetch_secret_value","title":"_fetch_secret_value  <code>async</code>","text":"<pre><code>_fetch_secret_value(namespace, secret_name, secret_key)\n</code></pre> <p>Fetch secret value from Kubernetes secret with RBAC validation.</p> <p>This method enforces namespace access control and secret labeling requirements. The secret must: 1. Be accessible via RoleBinding granting operator access to the namespace 2. Have the label: vriesdemichael.github.io/keycloak-allow-operator-read=true</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Namespace containing the secret</p> required <code>secret_name</code> <code>str</code> <p>Name of the secret</p> required <code>secret_key</code> <code>str</code> <p>Key in secret data</p> required <p>Returns:</p> Type Description <code>str</code> <p>Decoded secret value string</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If RBAC validation fails, secret not found, or key missing</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._has_flow_bindings","title":"_has_flow_bindings","text":"<pre><code>_has_flow_bindings(spec)\n</code></pre> <p>Check if the realm spec has any flow bindings configured.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._sync_client_scope_protocol_mappers","title":"_sync_client_scope_protocol_mappers  <code>async</code>","text":"<pre><code>_sync_client_scope_protocol_mappers(\n    admin_client,\n    realm_name,\n    scope_id,\n    desired_mappers,\n    namespace,\n)\n</code></pre> <p>Synchronize protocol mappers for a client scope.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope</p> required <code>desired_mappers</code> <code>list</code> <p>List of desired mapper configurations</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._sync_flow_executions","title":"_sync_flow_executions  <code>async</code>","text":"<pre><code>_sync_flow_executions(\n    admin_client,\n    realm_name,\n    flow_alias,\n    flow_config,\n    namespace,\n)\n</code></pre> <p>Synchronize executions for an existing flow.</p> <p>This updates execution requirements to match the desired state. Note: Adding/removing executions from existing flows is complex and not fully implemented - we only update requirements for now.</p> <p>Parameters:</p> Name Type Description Default <code>admin_client</code> <p>Keycloak admin client</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the flow</p> required <code>flow_config</code> <p>Flow configuration with desired executions</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler._validate_spec","title":"_validate_spec","text":"<pre><code>_validate_spec(spec)\n</code></pre> <p>Validate and parse Keycloak realm specification.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Raw specification dictionary</p> required <p>Returns:</p> Type Description <code>KeycloakRealmSpec</code> <p>Validated KeycloakRealmSpec object</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If specification is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.apply_flow_bindings","title":"apply_flow_bindings  <code>async</code>","text":"<pre><code>apply_flow_bindings(spec, name, namespace)\n</code></pre> <p>Apply authentication flow bindings to the realm.</p> <p>This must be called AFTER authentication flows are created, as flow bindings reference flows by alias.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.check_resource_exists","title":"check_resource_exists  <code>async</code>","text":"<pre><code>check_resource_exists(name, namespace, spec, status)\n</code></pre> <p>Check if realm resource actually exists in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace containing the resource</p> required <code>spec</code> <code>dict[str, Any]</code> <p>Realm specification</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if realm exists in Keycloak, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.cleanup_resources","title":"cleanup_resources  <code>async</code>","text":"<pre><code>cleanup_resources(name, namespace, spec, status)\n</code></pre> <p>Clean up realm from Keycloak and associated Kubernetes resources.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the KeycloakRealm resource</p> required <code>namespace</code> <code>str</code> <p>Namespace containing the resource</p> required <code>spec</code> <code>dict[str, Any]</code> <p>Realm specification</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status for tracking cleanup progress</p> required <p>Raises:</p> Type Description <code>TemporaryError</code> <p>If cleanup fails but should be retried</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_authentication","title":"configure_authentication  <code>async</code>","text":"<pre><code>configure_authentication(spec, name, namespace)\n</code></pre> <p>Configure authentication flows and security settings.</p> <p>This method handles: - Creating new authentication flows - Copying from built-in flows (when copyFrom is specified) - Adding executions to flows - Configuring execution requirements - Setting up authenticator configurations</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_client_scopes","title":"configure_client_scopes  <code>async</code>","text":"<pre><code>configure_client_scopes(spec, name, namespace)\n</code></pre> <p>Configure client scopes with full lifecycle management.</p> <p>This method: 1. Creates new client scopes 2. Updates existing client scopes 3. Deletes client scopes removed from spec (except built-in scopes) 4. Manages protocol mappers for each client scope</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_default_groups","title":"configure_default_groups  <code>async</code>","text":"<pre><code>configure_default_groups(spec, name, namespace)\n</code></pre> <p>Configure default groups for the realm.</p> <p>Default groups are automatically assigned to new users.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_groups","title":"configure_groups  <code>async</code>","text":"<pre><code>configure_groups(spec, name, namespace)\n</code></pre> <p>Configure groups with full lifecycle management.</p> <p>This method: 1. Creates new groups (including nested subgroups) 2. Updates existing groups 3. Deletes groups removed from spec 4. Manages group role assignments (realm and client roles)</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_identity_providers","title":"configure_identity_providers  <code>async</code>","text":"<pre><code>configure_identity_providers(spec, name, namespace)\n</code></pre> <p>Configure external identity providers with full lifecycle management.</p> <p>This method: 1. Creates new identity providers 2. Updates existing identity providers 3. Deletes identity providers removed from spec 4. Manages IDP mappers for each identity provider</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_realm_default_client_scopes","title":"configure_realm_default_client_scopes  <code>async</code>","text":"<pre><code>configure_realm_default_client_scopes(\n    spec, name, namespace\n)\n</code></pre> <p>Configure realm-level default and optional client scopes.</p> <p>Default scopes are automatically assigned to new clients. Optional scopes are available for clients to request.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_realm_roles","title":"configure_realm_roles  <code>async</code>","text":"<pre><code>configure_realm_roles(spec, name, namespace)\n</code></pre> <p>Configure realm-level roles with full lifecycle management.</p> <p>This method: 1. Creates new realm roles 2. Updates existing realm roles 3. Deletes realm roles removed from spec (except built-in roles) 4. Manages composite role memberships</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_required_actions","title":"configure_required_actions  <code>async</code>","text":"<pre><code>configure_required_actions(spec, name, namespace)\n</code></pre> <p>Configure required actions for the realm.</p> <p>Required actions are actions users must perform, such as: - CONFIGURE_TOTP: Set up two-factor authentication - VERIFY_EMAIL: Verify email address - UPDATE_PASSWORD: Change password - UPDATE_PROFILE: Update user profile</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_themes","title":"configure_themes  <code>async</code>","text":"<pre><code>configure_themes(spec, name, namespace)\n</code></pre> <p>Configure themes and branding for the realm.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.configure_user_federation","title":"configure_user_federation  <code>async</code>","text":"<pre><code>configure_user_federation(spec, name, namespace)\n</code></pre> <p>Configure user federation providers with full CRUD lifecycle.</p> <p>This method: 1. Fetches existing providers from Keycloak 2. Creates new providers defined in spec 3. Updates existing providers with changed config 4. Deletes providers removed from spec 5. Manages mappers for each provider 6. Injects secrets for bind credentials and keytabs</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of federation status dicts for status update</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.do_reconcile","title":"do_reconcile  <code>async</code>","text":"<pre><code>do_reconcile(spec, name, namespace, status, **kwargs)\n</code></pre> <p>Reconcile Keycloak realm to desired state.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak realm resource specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status object</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Status dictionary for the resource</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.do_update","title":"do_update  <code>async</code>","text":"<pre><code>do_update(\n    old_spec,\n    new_spec,\n    diff,\n    name,\n    namespace,\n    status,\n    **kwargs\n)\n</code></pre> <p>Handle updates to Keycloak realm specifications.</p> <p>Parameters:</p> Name Type Description Default <code>old_spec</code> <code>dict[str, Any]</code> <p>Previous specification dictionary</p> required <code>new_spec</code> <code>dict[str, Any]</code> <p>New specification dictionary</p> required <code>diff</code> <code>Any</code> <p>List of changes between old and new specs</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status object</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Updated status dictionary or None if no changes needed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.ensure_realm_exists","title":"ensure_realm_exists  <code>async</code>","text":"<pre><code>ensure_realm_exists(spec, name, namespace, **kwargs)\n</code></pre> <p>Ensure the basic realm exists in Keycloak with ownership tracking.</p> <p>This method implements ownership tracking to prevent multiple CRs from managing the same realm and to handle orphaned realms properly.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments (uid, meta, etc.)</p> <code>{}</code>"},{"location":"api/keycloak_operator/#keycloak_operator.services.realm_reconciler.KeycloakRealmReconciler.validate_cross_namespace_access","title":"validate_cross_namespace_access  <code>async</code>","text":"<pre><code>validate_cross_namespace_access(spec, namespace)\n</code></pre> <p>Validate RBAC permissions for cross-namespace operations.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakRealmSpec</code> <p>Keycloak realm specification</p> required <code>namespace</code> <code>str</code> <p>Current namespace</p> required <p>Raises:</p> Type Description <code>RBACError</code> <p>If insufficient permissions for cross-namespace access</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler","title":"KeycloakClientReconciler","text":"<pre><code>KeycloakClientReconciler(\n    k8s_client=None,\n    keycloak_admin_factory=None,\n    rate_limiter=None,\n)\n</code></pre> <p>               Bases: <code>BaseReconciler</code></p> <p>Reconciler for Keycloak client resources.</p> <p>Manages the complete lifecycle of OAuth2/OIDC clients including: - Client creation and basic configuration - OAuth2/OIDC parameter setup - Credential generation and rotation - Protocol mapper configuration - Client role management - Cross-namespace RBAC validation</p> <p>Initialize Keycloak client reconciler.</p> <p>Parameters:</p> Name Type Description Default <code>k8s_client</code> <code>ApiClient | None</code> <p>Kubernetes API client</p> <code>None</code> <code>keycloak_admin_factory</code> <code>Any</code> <p>Factory function for creating Keycloak admin clients</p> <code>None</code> <code>rate_limiter</code> <code>Any</code> <p>Rate limiter for Keycloak API calls</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._client_role_needs_update","title":"_client_role_needs_update","text":"<pre><code>_client_role_needs_update(existing, desired)\n</code></pre> <p>Check if a client role needs to be updated.</p> <p>Parameters:</p> Name Type Description Default <code>existing</code> <code>dict[str, Any]</code> <p>Existing client role from Keycloak</p> required <code>desired</code> <code>dict[str, Any]</code> <p>Desired client role configuration</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if update is needed, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._delete_client_k8s_resources","title":"_delete_client_k8s_resources  <code>async</code>","text":"<pre><code>_delete_client_k8s_resources(name, namespace, client_spec)\n</code></pre> <p>Delete Kubernetes resources associated with the client.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._get_keycloak_instance_from_realm","title":"_get_keycloak_instance_from_realm","text":"<pre><code>_get_keycloak_instance_from_realm(\n    realm_resource_name, realm_namespace\n)\n</code></pre> <p>Get Keycloak instance name and namespace from a realm's status.</p> <p>DEPRECATED: Use _get_realm_info instead for new code.</p> <p>Parameters:</p> Name Type Description Default <code>realm_resource_name</code> <code>str</code> <p>Name of the realm resource</p> required <code>realm_namespace</code> <code>str</code> <p>Namespace of the realm resource</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>Tuple of (keycloak_namespace, keycloak_name)</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._get_realm_info","title":"_get_realm_info","text":"<pre><code>_get_realm_info(realm_resource_name, realm_namespace)\n</code></pre> <p>Get realm information including actual realm name and Keycloak instance.</p> <p>Parameters:</p> Name Type Description Default <code>realm_resource_name</code> <code>str</code> <p>Name of the realm Kubernetes resource</p> required <code>realm_namespace</code> <code>str</code> <p>Namespace of the realm resource</p> required <p>Returns:</p> Type Description <code>tuple[str, str, str, str]</code> <p>Tuple of (actual_realm_name, keycloak_namespace, keycloak_name, realm_resource_name)</p> <p>Raises:</p> Type Description <code>ApiException</code> <p>If realm resource cannot be retrieved</p> <code>PermanentError</code> <p>If realm spec is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._protocol_mapper_needs_update","title":"_protocol_mapper_needs_update","text":"<pre><code>_protocol_mapper_needs_update(existing, desired)\n</code></pre> <p>Check if a protocol mapper needs to be updated.</p> <p>Parameters:</p> Name Type Description Default <code>existing</code> <code>dict[str, Any]</code> <p>Existing protocol mapper from Keycloak</p> required <code>desired</code> <code>dict[str, Any]</code> <p>Desired protocol mapper configuration</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if update is needed, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._validate_namespace_authorization","title":"_validate_namespace_authorization  <code>async</code>","text":"<pre><code>_validate_namespace_authorization(\n    realm_resource,\n    realm_name,\n    realm_namespace,\n    client_namespace,\n    client_id,\n)\n</code></pre> <p>Validate that client's namespace is authorized via realm's grant list.</p> <p>Parameters:</p> Name Type Description Default <code>realm_resource</code> <code>dict[str, Any]</code> <p>The KeycloakRealm custom resource</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>realm_namespace</code> <code>str</code> <p>Namespace of the realm</p> required <code>client_namespace</code> <code>str</code> <p>Namespace of the client</p> required <code>client_id</code> <code>str</code> <p>ID of the client</p> required <p>Raises:</p> Type Description <code>PermanentError</code> <p>If namespace is not in grant list</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler._validate_spec","title":"_validate_spec","text":"<pre><code>_validate_spec(spec)\n</code></pre> <p>Validate and parse Keycloak client specification.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Raw specification dictionary</p> required <p>Returns:</p> Type Description <code>KeycloakClientSpec</code> <p>Validated KeycloakClientSpec object</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If specification is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.check_resource_exists","title":"check_resource_exists  <code>async</code>","text":"<pre><code>check_resource_exists(name, namespace, spec, status)\n</code></pre> <p>Check if client resource actually exists in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace containing the resource</p> required <code>spec</code> <code>dict[str, Any]</code> <p>Client specification</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if client exists in Keycloak, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.cleanup_resources","title":"cleanup_resources  <code>async</code>","text":"<pre><code>cleanup_resources(name, namespace, spec, status)\n</code></pre> <p>Clean up client from Keycloak and associated Kubernetes resources.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the KeycloakClient resource</p> required <code>namespace</code> <code>str</code> <p>Namespace containing the resource</p> required <code>spec</code> <code>dict[str, Any]</code> <p>Client specification</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status for tracking cleanup progress</p> required <p>Raises:</p> Type Description <code>TemporaryError</code> <p>If cleanup fails but should be retried</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.configure_client_scopes","title":"configure_client_scopes  <code>async</code>","text":"<pre><code>configure_client_scopes(spec, client_uuid, name, namespace)\n</code></pre> <p>Configure client-level default and optional scope assignments.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>client_uuid</code> <code>str</code> <p>Client UUID in Keycloak</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.configure_oauth_settings","title":"configure_oauth_settings  <code>async</code>","text":"<pre><code>configure_oauth_settings(\n    spec, client_uuid, name, namespace\n)\n</code></pre> <p>Configure OAuth2/OIDC parameters for the client.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>client_uuid</code> <code>str</code> <p>Client UUID in Keycloak</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.configure_protocol_mappers","title":"configure_protocol_mappers  <code>async</code>","text":"<pre><code>configure_protocol_mappers(\n    spec, client_uuid, name, namespace\n)\n</code></pre> <p>Configure protocol mappers for claims and token customization.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>client_uuid</code> <code>str</code> <p>Client UUID in Keycloak</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.do_reconcile","title":"do_reconcile  <code>async</code>","text":"<pre><code>do_reconcile(spec, name, namespace, status, **kwargs)\n</code></pre> <p>Reconcile Keycloak client to desired state.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Keycloak client resource specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status object</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Status dictionary for the resource</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.do_update","title":"do_update  <code>async</code>","text":"<pre><code>do_update(\n    old_spec,\n    new_spec,\n    diff,\n    name,\n    namespace,\n    status,\n    **kwargs\n)\n</code></pre> <p>Handle updates to Keycloak client specifications.</p> <p>Parameters:</p> Name Type Description Default <code>old_spec</code> <code>dict[str, Any]</code> <p>Previous specification dictionary</p> required <code>new_spec</code> <code>dict[str, Any]</code> <p>New specification dictionary</p> required <code>diff</code> <code>Any</code> <p>List of changes between old and new specs</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>status</code> <code>StatusProtocol</code> <p>Resource status object</p> required <code>**kwargs</code> <code>Any</code> <p>Additional handler arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Updated status dictionary or None if no changes needed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.ensure_client_exists","title":"ensure_client_exists  <code>async</code>","text":"<pre><code>ensure_client_exists(spec, name, namespace)\n</code></pre> <p>Ensure the OAuth2/OIDC client exists in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <p>Returns:</p> Type Description <code>str</code> <p>Client UUID from Keycloak</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.manage_client_credentials","title":"manage_client_credentials  <code>async</code>","text":"<pre><code>manage_client_credentials(\n    spec, client_uuid, name, namespace, owner_uid=None\n)\n</code></pre> <p>Generate and manage client credentials (secret).</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>client_uuid</code> <code>str</code> <p>Client UUID in Keycloak</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required <code>owner_uid</code> <code>str | None</code> <p>UID of the owning KeycloakClient resource</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.manage_client_roles","title":"manage_client_roles  <code>async</code>","text":"<pre><code>manage_client_roles(spec, client_uuid, name, namespace)\n</code></pre> <p>Manage client-specific roles and permissions.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>client_uuid</code> <code>str</code> <p>Client UUID in Keycloak</p> required <code>name</code> <code>str</code> <p>Resource name</p> required <code>namespace</code> <code>str</code> <p>Resource namespace</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.manage_service_account_roles","title":"manage_service_account_roles  <code>async</code>","text":"<pre><code>manage_service_account_roles(\n    spec, client_uuid, name, namespace\n)\n</code></pre> <p>Manage role mappings for the client's service account user.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.services.client_reconciler.KeycloakClientReconciler.validate_cross_namespace_access","title":"validate_cross_namespace_access  <code>async</code>","text":"<pre><code>validate_cross_namespace_access(spec, namespace)\n</code></pre> <p>Validate RBAC permissions for cross-namespace operations.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>KeycloakClientSpec</code> <p>Keycloak client specification</p> required <code>namespace</code> <code>str</code> <p>Current namespace</p> required <p>Raises:</p> Type Description <code>RBACError</code> <p>If insufficient permissions for cross-namespace access</p>"},{"location":"api/keycloak_operator/#utilities","title":"Utilities","text":"<p>Kubernetes utilities for the Keycloak operator.</p> <p>This module provides helper functions for interacting with the Kubernetes API, including resource management, RBAC validation, and cluster operations.</p> <p>Key functionality: - Kubernetes client management and configuration - Resource creation and management (deployments, services, secrets) - RBAC permission validation - Cross-namespace resource discovery - Status and health monitoring</p> <p>Keycloak Admin API client utilities.</p> <p>This module provides a high-level interface to the Keycloak Admin REST API for managing Keycloak instances, realms, clients, and other resources.</p> <p>The client handles: - Authentication with Keycloak admin credentials - Session management and token refresh - Error handling and retry logic - Type-safe API interactions - Rate limiting for API protection</p> <p>Validation utilities for the Keycloak operator.</p> <p>This module provides validation functions for Keycloak resources, configurations, and operator settings. It includes:</p> <ul> <li>Resource specification validation</li> <li>Configuration consistency checks</li> <li>Security and best practice validations</li> <li>Cross-resource dependency validation</li> </ul>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.check_http_health","title":"check_http_health  <code>async</code>","text":"<pre><code>check_http_health(url, timeout=5)\n</code></pre> <p>Perform HTTP health check against a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to check</p> required <code>timeout</code> <code>int</code> <p>Request timeout in seconds</p> <code>5</code> <p>Returns:</p> Type Description <code>tuple[bool, str | None]</code> <p>Tuple of (is_healthy, error_message)</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.check_rbac_permissions","title":"check_rbac_permissions","text":"<pre><code>check_rbac_permissions(\n    namespace,\n    target_namespace,\n    resource=\"keycloaks\",\n    verb=\"get\",\n    api_group=None,\n)\n</code></pre> <p>Check if the current service account has RBAC permissions for cross-namespace access.</p> <p>This function performs a Kubernetes SubjectAccessReview to validate that the operator has the necessary permissions to access resources in other namespaces.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Source namespace (where the request originates)</p> required <code>target_namespace</code> <code>str</code> <p>Target namespace to access</p> required <code>resource</code> <code>str</code> <p>Kubernetes resource type to check</p> <code>'keycloaks'</code> <code>verb</code> <code>str</code> <p>Action to perform (get, create, update, delete, etc.)</p> <code>'get'</code> <code>api_group</code> <code>str | None</code> <p>API group for the resource (None for auto-detection)</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if permission is granted, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.create_admin_secret","title":"create_admin_secret","text":"<pre><code>create_admin_secret(\n    name, namespace, username=\"admin\", password=None\n)\n</code></pre> <p>Create a secret containing Keycloak admin credentials.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>namespace</code> <code>str</code> <p>Target namespace</p> required <code>username</code> <code>str</code> <p>Admin username</p> <code>'admin'</code> <code>password</code> <code>str | None</code> <p>Admin password (generated if not provided)</p> <code>None</code> <p>Returns:</p> Type Description <code>V1Secret</code> <p>Created Secret object</p> <p>Creates a secret with admin credentials, generating secure passwords when needed. Sets proper labels and ownership for the secret.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.create_client_secret","title":"create_client_secret","text":"<pre><code>create_client_secret(\n    secret_name,\n    namespace,\n    client_id,\n    client_secret,\n    keycloak_url,\n    realm,\n    update_existing=False,\n    labels=None,\n    annotations=None,\n    owner_uid=None,\n    owner_name=None,\n)\n</code></pre> <p>Create or update a Kubernetes secret containing client credentials.</p> <p>Parameters:</p> Name Type Description Default <code>secret_name</code> <code>str</code> <p>Name of the secret to create</p> required <code>namespace</code> <code>str</code> <p>Target namespace</p> required <code>client_id</code> <code>str</code> <p>Keycloak client ID</p> required <code>client_secret</code> <code>str | None</code> <p>Client secret (None for public clients)</p> required <code>keycloak_url</code> <code>str</code> <p>Keycloak server URL</p> required <code>realm</code> <code>str</code> <p>Realm name</p> required <code>update_existing</code> <code>bool</code> <p>Whether to update if secret already exists</p> <code>False</code> <code>labels</code> <code>dict[str, str] | None</code> <p>Optional labels to add to the secret</p> <code>None</code> <code>annotations</code> <code>dict[str, str] | None</code> <p>Optional annotations to add to the secret</p> <code>None</code> <code>owner_uid</code> <code>str | None</code> <p>Optional UID of the owning resource for GC</p> <code>None</code> <code>owner_name</code> <code>str | None</code> <p>Optional name of the owning resource for GC</p> <code>None</code> <p>Returns:</p> Type Description <code>V1Secret</code> <p>Created or updated Secret object</p> <p>Creates a Kubernetes secret containing client credentials and connection info. Handles both creation and updates with proper encoding and metadata.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.create_keycloak_deployment","title":"create_keycloak_deployment","text":"<pre><code>create_keycloak_deployment(\n    name,\n    namespace,\n    spec,\n    k8s_client,\n    db_connection_info=None,\n)\n</code></pre> <pre><code>Create Kubernetes Deployment for a Keycloak instance.\n\nArgs:\n    name: Name of the Keycloak resource\n    namespace: Target namespace\n    spec: Keycloak specification\n    k8s_client: Kubernetes API client\n    db_connection_info: Optional resolved database connection details (for CNPG)\n\nReturns:\n    Created Deployment object\n</code></pre> <p>This function creates a complete Keycloak deployment with proper configuration.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.create_keycloak_ingress","title":"create_keycloak_ingress","text":"<pre><code>create_keycloak_ingress(name, namespace, spec, k8s_client)\n</code></pre> <p>Create Kubernetes Ingress for a Keycloak instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Target namespace</p> required <code>spec</code> <code>KeycloakSpec</code> <p>Keycloak specification</p> required <code>k8s_client</code> <code>ApiClient</code> <p>Kubernetes API client</p> required <p>Returns:</p> Type Description <code>V1Ingress</code> <p>Created Ingress object</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.create_keycloak_service","title":"create_keycloak_service","text":"<pre><code>create_keycloak_service(name, namespace, spec, k8s_client)\n</code></pre> <pre><code>Create Kubernetes Service for a Keycloak instance.\n\nArgs:\n    name: Name of the Keycloak resource\n    namespace: Target namespace\n    spec: Keycloak specification\n    k8s_client: Kubernetes API client\n\nReturns:\n    Created Service object\n</code></pre> <p>This function creates a Kubernetes service with proper port configuration and selectors.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.create_persistent_volume_claim","title":"create_persistent_volume_claim","text":"<pre><code>create_persistent_volume_claim(\n    name, namespace, size=\"10Gi\", storage_class=None\n)\n</code></pre> <p>Create a PersistentVolumeClaim for Keycloak data storage.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>namespace</code> <code>str</code> <p>Target namespace</p> required <code>size</code> <code>str</code> <p>Storage size (e.g., \"10Gi\")</p> <code>'10Gi'</code> <code>storage_class</code> <code>str | None</code> <p>Storage class name (optional)</p> <code>None</code> <p>Returns:</p> Type Description <code>V1PersistentVolumeClaim</code> <p>Created PersistentVolumeClaim object</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.find_keycloak_instances","title":"find_keycloak_instances","text":"<pre><code>find_keycloak_instances(namespace=None)\n</code></pre> <p>Find Keycloak instances across namespaces.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str | None</code> <p>Specific namespace to search, or None for cluster-wide</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of Keycloak instance dictionaries</p> <p>Searches for Keycloak custom resources and returns instances with status information. Handles API errors gracefully and supports both namespace-specific and cluster-wide searches.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.get_admin_credentials","title":"get_admin_credentials","text":"<pre><code>get_admin_credentials(name, namespace)\n</code></pre> <p>Get admin credentials for a Keycloak instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>namespace</code> <code>str</code> <p>Namespace where the instance is deployed</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>Tuple of (username, password)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If credentials cannot be retrieved</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.get_current_service_account_info","title":"get_current_service_account_info","text":"<pre><code>get_current_service_account_info()\n</code></pre> <p>Get information about the current service account being used by the operator.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary with service account name and namespace</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.get_kubernetes_client","title":"get_kubernetes_client","text":"<pre><code>get_kubernetes_client()\n</code></pre> <pre><code>Get configured Kubernetes API client.\n\nThis function handles both in-cluster and local development configurations.\n\nReturns:\n    Configured Kubernetes API client\n</code></pre> <p>This function handles both in-cluster and local development configurations.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.get_pod_resource_usage","title":"get_pod_resource_usage","text":"<pre><code>get_pod_resource_usage(name, namespace, k8s_client)\n</code></pre> <p>Get resource usage metrics for Keycloak pods.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Target namespace</p> required <code>k8s_client</code> <code>ApiClient</code> <p>Kubernetes API client</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with resource usage information</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.set_owner_reference","title":"set_owner_reference","text":"<pre><code>set_owner_reference(\n    resource,\n    owner_name,\n    owner_uid,\n    owner_kind=\"Keycloak\",\n    api_version=\"vriesdemichael.github.io/v1\",\n)\n</code></pre> <p>Set owner reference for garbage collection.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>Any</code> <p>Kubernetes resource to set owner reference on</p> required <code>owner_name</code> <code>str</code> <p>Name of the owner resource</p> required <code>owner_uid</code> <code>str</code> <p>UID of the owner resource</p> required <code>owner_kind</code> <code>str</code> <p>Kind of the owner resource</p> <code>'Keycloak'</code> <code>api_version</code> <code>str</code> <p>API version of the owner resource</p> <code>'vriesdemichael.github.io/v1'</code>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.kubernetes.validate_keycloak_reference","title":"validate_keycloak_reference","text":"<pre><code>validate_keycloak_reference(keycloak_name, namespace)\n</code></pre> <pre><code>Validate that a Keycloak instance reference is valid and ready.\n\nArgs:\n    keycloak_name: Name of the Keycloak instance\n    namespace: Namespace where the instance should exist\n\nReturns:\n    Keycloak instance details if valid and ready, None otherwise\n</code></pre> <p>This function validates Keycloak instance readiness and availability.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient","title":"KeycloakAdminClient","text":"<pre><code>KeycloakAdminClient(\n    server_url,\n    username,\n    password,\n    realm=\"master\",\n    client_id=\"admin-cli\",\n    verify_ssl=True,\n    timeout=60,\n    rate_limiter=None,\n)\n</code></pre> <pre><code>High-level client for Keycloak Admin API operations.\n\nThis client provides methods for managing Keycloak resources including\nrealms, clients, users, and configuration. It handles authentication,\nsession management, and provides a clean interface for the operator.\n</code></pre> <p>This client provides comprehensive Keycloak Admin API operations with     authentication, error handling, and retry logic.</p> <p>Initialize Keycloak Admin client.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>Base URL of the Keycloak server</p> required <code>username</code> <code>str</code> <p>Admin username</p> required <code>password</code> <code>str</code> <p>Admin password</p> required <code>realm</code> <code>str</code> <p>Admin realm (default: master)</p> <code>'master'</code> <code>client_id</code> <code>str</code> <p>Client ID for admin API access</p> <code>'admin-cli'</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates</p> <code>True</code> <code>timeout</code> <code>int</code> <p>Request timeout in seconds</p> <code>60</code> <code>rate_limiter</code> <code>RateLimiter | None</code> <p>Optional rate limiter for API call throttling</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit - ensures session cleanup.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient._ensure_authenticated","title":"_ensure_authenticated  <code>async</code>","text":"<pre><code>_ensure_authenticated()\n</code></pre> <p>Ensure we have a valid access token, refreshing if necessary.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient._get_client","title":"_get_client  <code>async</code>","text":"<pre><code>_get_client()\n</code></pre> <p>Get or create httpx client (lazy initialization with caching).</p> <p>The client is cached per (server_url, verify_ssl) combination. We also track the event loop ID to detect when a cached client was created in a different event loop (which can happen in tests).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient._make_request","title":"_make_request  <code>async</code>","text":"<pre><code>_make_request(\n    method,\n    endpoint,\n    namespace,\n    data=None,\n    json=None,\n    params=None,\n)\n</code></pre> <p>Make an authenticated request to the Keycloak Admin API.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>HTTP method (GET, POST, PUT, DELETE)</p> required <code>endpoint</code> <code>str</code> <p>API endpoint (relative to admin base)</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <code>data</code> <code>dict[str, Any] | None</code> <p>Request body data (deprecated, use json parameter)</p> <code>None</code> <code>json</code> <code>dict[str, Any] | None</code> <p>JSON request body data</p> <code>None</code> <code>params</code> <code>dict[str, Any] | None</code> <p>Query parameters</p> <code>None</code> <p>Returns:</p> Type Description <code>Response</code> <p>Response object (httpx.Response) with body already buffered</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>On API errors or rate limit timeouts</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient._make_validated_request","title":"_make_validated_request  <code>async</code>","text":"<pre><code>_make_validated_request(\n    method,\n    endpoint,\n    namespace,\n    request_model=None,\n    response_model=None,\n    **kwargs\n)\n</code></pre> <p>Make an authenticated request with automatic Pydantic validation.</p> <p>This method wraps _make_request to provide automatic validation of request and response data using Pydantic models.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>HTTP method (GET, POST, PUT, DELETE)</p> required <code>endpoint</code> <code>str</code> <p>API endpoint (relative to admin base)</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <code>request_model</code> <code>BaseModel | None</code> <p>Pydantic model instance to serialize as request body</p> <code>None</code> <code>response_model</code> <code>type[BaseModel] | None</code> <p>Pydantic model class to validate response data</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to _make_request</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>Validated response model instance if response_model is provided,</p> <code>Any</code> <p>otherwise the raw Response object</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If the API request fails</p> <code>ValidationError</code> <p>If response data doesn't match the expected model</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient._refresh_token","title":"_refresh_token  <code>async</code>","text":"<pre><code>_refresh_token()\n</code></pre> <p>Refresh the access token using the refresh token.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_client_default_scope","title":"add_client_default_scope  <code>async</code>","text":"<pre><code>add_client_default_scope(\n    realm_name, client_uuid, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Add a client scope to a client's default scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to add</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_client_optional_scope","title":"add_client_optional_scope  <code>async</code>","text":"<pre><code>add_client_optional_scope(\n    realm_name, client_uuid, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Add a client scope to a client's optional scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to add</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_default_group","title":"add_default_group  <code>async</code>","text":"<pre><code>add_default_group(\n    realm_name, group_id, namespace=\"default\"\n)\n</code></pre> <p>Add a group to the default groups.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group to add as default</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_execution_to_flow","title":"add_execution_to_flow  <code>async</code>","text":"<pre><code>add_execution_to_flow(\n    realm_name, flow_alias, provider_id, namespace\n)\n</code></pre> <p>Add a new authenticator execution to a flow.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the parent flow</p> required <code>provider_id</code> <code>str</code> <p>Authenticator provider ID (e.g., 'auth-cookie')</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Execution ID if successful, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_realm_default_client_scope","title":"add_realm_default_client_scope  <code>async</code>","text":"<pre><code>add_realm_default_client_scope(\n    realm_name, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Add a client scope to realm default client scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to add</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_realm_optional_client_scope","title":"add_realm_optional_client_scope  <code>async</code>","text":"<pre><code>add_realm_optional_client_scope(\n    realm_name, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Add a client scope to realm optional client scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to add</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_realm_role_composites","title":"add_realm_role_composites  <code>async</code>","text":"<pre><code>add_realm_role_composites(\n    realm_name, role_name, child_roles, namespace=\"default\"\n)\n</code></pre> <p>Add composite (child) roles to a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_name</code> <code>str</code> <p>Name of the parent role</p> required <code>child_roles</code> <code>list[RoleRepresentation] | list[dict[str, Any]]</code> <p>List of roles to add as composites</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.add_subflow_to_flow","title":"add_subflow_to_flow  <code>async</code>","text":"<pre><code>add_subflow_to_flow(\n    realm_name,\n    parent_flow_alias,\n    subflow_alias,\n    provider_id,\n    description,\n    namespace,\n)\n</code></pre> <p>Add a new sub-flow execution to a flow.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>parent_flow_alias</code> <code>str</code> <p>Alias of the parent flow</p> required <code>subflow_alias</code> <code>str</code> <p>Alias for the new sub-flow</p> required <code>provider_id</code> <code>str</code> <p>Flow provider ('basic-flow' or 'client-flow')</p> required <code>description</code> <code>str | None</code> <p>Description for the sub-flow</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Execution ID if successful, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.assign_client_roles_to_group","title":"assign_client_roles_to_group  <code>async</code>","text":"<pre><code>assign_client_roles_to_group(\n    realm_name,\n    group_id,\n    client_uuid,\n    roles,\n    namespace=\"default\",\n)\n</code></pre> <p>Assign client roles to a group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>roles</code> <code>list[RoleRepresentation] | list[dict[str, Any]]</code> <p>List of roles to assign</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.assign_client_roles_to_user","title":"assign_client_roles_to_user  <code>async</code>","text":"<pre><code>assign_client_roles_to_user(\n    user_id, client_uuid, role_names, realm_name, namespace\n)\n</code></pre> <p>Assign client-level roles to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>UUID of the user in Keycloak</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>role_names</code> <code>list[str]</code> <p>List of role names to assign</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If assignment fails</p> Example <p>await admin_client.assign_client_roles_to_user(     user_id=\"123-456-789\",     client_uuid=\"abc-def-ghi\",     role_names=[\"admin\", \"user\"],     realm_name=\"my-realm\",     namespace=\"default\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.assign_realm_roles_to_group","title":"assign_realm_roles_to_group  <code>async</code>","text":"<pre><code>assign_realm_roles_to_group(\n    realm_name, group_id, roles, namespace=\"default\"\n)\n</code></pre> <p>Assign realm roles to a group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>roles</code> <code>list[RoleRepresentation] | list[dict[str, Any]]</code> <p>List of roles to assign</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.assign_realm_roles_to_user","title":"assign_realm_roles_to_user  <code>async</code>","text":"<pre><code>assign_realm_roles_to_user(\n    user_id, role_names, realm_name, namespace\n)\n</code></pre> <p>Assign realm-level roles to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>UUID of the user in Keycloak</p> required <code>role_names</code> <code>list[str]</code> <p>List of role names to assign</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If assignment fails</p> Example <p>await admin_client.assign_realm_roles_to_user(     user_id=\"123-456-789\",     role_names=[\"admin\", \"user\"],     realm_name=\"my-realm\",     namespace=\"default\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate()\n</code></pre> <p>Authenticate with Keycloak and obtain access tokens.</p> <p>Uses username/password grant to obtain access and refresh tokens.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close method for compatibility with async context manager.</p> <p>Note: With the caching strategy, we don't actually close the httpx client here as it's shared across multiple KeycloakAdminClient instances. The cached client will be reused until the operator shuts down.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.configure_identity_provider","title":"configure_identity_provider  <code>async</code>","text":"<pre><code>configure_identity_provider(\n    realm_name, provider_config, namespace\n)\n</code></pre> <p>Configure identity provider for a realm (create or update).</p> <p>This method checks if the identity provider already exists: - If it exists, updates it using PUT - If it doesn't exist, creates it using POST</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_config</code> <code>IdentityProviderRepresentation | dict[str, Any]</code> <p>Identity provider configuration as IdentityProviderRepresentation or dict</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>from keycloak_operator.models.keycloak_api import IdentityProviderRepresentation</p> <p>provider = IdentityProviderRepresentation(     alias=\"google\",     provider_id=\"google\",     enabled=True ) success = await admin_client.configure_identity_provider(\"my-realm\", provider, \"my-namespace\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.configure_identity_provider_mapper","title":"configure_identity_provider_mapper  <code>async</code>","text":"<pre><code>configure_identity_provider_mapper(\n    realm_name, alias, mapper, namespace\n)\n</code></pre> <p>Configure an identity provider mapper (create or update).</p> <p>This method finds existing mappers by name and updates them, or creates new ones if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>mapper</code> <code>IdentityProviderMapperRepresentation | dict[str, Any]</code> <p>Mapper configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.configure_user_federation","title":"configure_user_federation  <code>async</code>","text":"<pre><code>configure_user_federation(realm_name, federation_config)\n</code></pre> <p>Configure user federation for a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>federation_config</code> <code>ComponentRepresentation | dict[str, Any]</code> <p>User federation configuration as ComponentRepresentation or dict</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>from keycloak_operator.models.keycloak_api import ComponentRepresentation</p> <p>federation = ComponentRepresentation(     name=\"ldap\",     provider_id=\"ldap\" ) success = admin_client.configure_user_federation(\"my-realm\", federation)</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.copy_authentication_flow","title":"copy_authentication_flow  <code>async</code>","text":"<pre><code>copy_authentication_flow(\n    realm_name, source_flow_alias, new_flow_alias, namespace\n)\n</code></pre> <p>Copy an existing authentication flow under a new name.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>source_flow_alias</code> <code>str</code> <p>Alias of the flow to copy</p> required <code>new_flow_alias</code> <code>str</code> <p>Alias for the new flow</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_authentication_flow","title":"create_authentication_flow  <code>async</code>","text":"<pre><code>create_authentication_flow(\n    realm_name, flow_config, namespace\n)\n</code></pre> <p>Create a new authentication flow for a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_config</code> <code>AuthenticationFlowRepresentation | dict[str, Any]</code> <p>Authentication flow configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the flow was created successfully.</p> <code>bool</code> <p>False if the flow already exists (409 conflict) or creation failed.</p> <code>bool</code> <p>For idempotent operations, callers should check if the flow exists</p> <code>bool</code> <p>separately when False is returned, as the flow may already be present.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_authenticator_config","title":"create_authenticator_config  <code>async</code>","text":"<pre><code>create_authenticator_config(\n    realm_name, execution_id, config, namespace\n)\n</code></pre> <p>Create a new authenticator configuration for an execution.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>execution_id</code> <code>str</code> <p>ID of the execution to configure</p> required <code>config</code> <code>AuthenticatorConfigRepresentation | dict[str, Any]</code> <p>Authenticator configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Config ID if successful, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_client","title":"create_client  <code>async</code>","text":"<pre><code>create_client(client_config, realm_name, namespace)\n</code></pre> <p>Create a new client in the specified realm.</p> <p>Parameters:</p> Name Type Description Default <code>client_config</code> <code>ClientRepresentation | dict[str, Any]</code> <p>Client configuration as ClientRepresentation or dict</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client UUID if successful, None otherwise</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If client creation fails</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_client_protocol_mapper","title":"create_client_protocol_mapper  <code>async</code>","text":"<pre><code>create_client_protocol_mapper(\n    client_uuid, mapper_config, realm_name=\"master\"\n)\n</code></pre> <p>Create a protocol mapper for a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>mapper_config</code> <code>ProtocolMapperRepresentation | dict[str, Any]</code> <p>Protocol mapper configuration as ProtocolMapperRepresentation or dict</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>ProtocolMapperRepresentation | None</code> <p>Created mapper configuration as ProtocolMapperRepresentation or None on error</p> Example <p>from keycloak_operator.models.keycloak_api import ProtocolMapperRepresentation</p> <p>mapper = ProtocolMapperRepresentation(     name=\"email\",     protocol=\"openid-connect\",     protocol_mapper=\"oidc-usermodel-property-mapper\" ) created = admin_client.create_client_protocol_mapper(     client_uuid, mapper, \"my-realm\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_client_role","title":"create_client_role  <code>async</code>","text":"<pre><code>create_client_role(\n    client_uuid, role_config, realm_name=\"master\"\n)\n</code></pre> <p>Create a role for a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>role_config</code> <code>RoleRepresentation | dict[str, Any]</code> <p>Role configuration as RoleRepresentation or dict</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>from keycloak_operator.models.keycloak_api import RoleRepresentation</p> <p>role = RoleRepresentation(     name=\"admin\",     description=\"Administrator role\" ) success = admin_client.create_client_role(client_uuid, role, \"my-realm\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_client_scope","title":"create_client_scope  <code>async</code>","text":"<pre><code>create_client_scope(\n    realm_name, scope_config, namespace=\"default\"\n)\n</code></pre> <p>Create a new client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_config</code> <code>ClientScopeRepresentation | dict[str, Any]</code> <p>Client scope configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>ID of the created client scope, or None if creation failed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_client_scope_protocol_mapper","title":"create_client_scope_protocol_mapper  <code>async</code>","text":"<pre><code>create_client_scope_protocol_mapper(\n    realm_name, scope_id, mapper_config, namespace=\"default\"\n)\n</code></pre> <p>Create a protocol mapper in a client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope</p> required <code>mapper_config</code> <code>ProtocolMapperRepresentation | dict[str, Any]</code> <p>Protocol mapper configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>ID of the created mapper, or None if creation failed</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_group","title":"create_group  <code>async</code>","text":"<pre><code>create_group(realm_name, group_config, namespace='default')\n</code></pre> <p>Create a top-level group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_config</code> <code>GroupRepresentation | dict[str, Any]</code> <p>Group configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Group ID if successful, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_identity_provider_mapper","title":"create_identity_provider_mapper  <code>async</code>","text":"<pre><code>create_identity_provider_mapper(\n    realm_name, alias, mapper, namespace\n)\n</code></pre> <p>Create a mapper for an identity provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>mapper</code> <code>IdentityProviderMapperRepresentation | dict[str, Any]</code> <p>Mapper configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>mapper = IdentityProviderMapperRepresentation(     name=\"email-mapper\",     identity_provider_alias=\"github\",     identity_provider_mapper=\"hardcoded-user-session-attribute-idp-mapper\",     config={\"attribute\": \"email\", \"attribute.value\": \"${CLAIM.email}\"} ) success = await admin_client.create_identity_provider_mapper(     \"my-realm\", \"github\", mapper, \"default\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_realm","title":"create_realm  <code>async</code>","text":"<pre><code>create_realm(realm_config, namespace)\n</code></pre> <p>Create a new realm in Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>realm_config</code> <code>RealmRepresentation | dict[str, Any]</code> <p>Realm configuration as RealmRepresentation or dict</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RealmRepresentation</code> <p>Created realm information as RealmRepresentation</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If realm creation fails</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_realm_role","title":"create_realm_role  <code>async</code>","text":"<pre><code>create_realm_role(\n    realm_name, role_config, namespace=\"default\"\n)\n</code></pre> <p>Create a realm-level role.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_config</code> <code>RoleRepresentation | dict[str, Any]</code> <p>Role configuration as RoleRepresentation or dict</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_subgroup","title":"create_subgroup  <code>async</code>","text":"<pre><code>create_subgroup(\n    realm_name,\n    parent_group_id,\n    group_config,\n    namespace=\"default\",\n)\n</code></pre> <p>Create a subgroup under a parent group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>parent_group_id</code> <code>str</code> <p>ID of the parent group</p> required <code>group_config</code> <code>GroupRepresentation | dict[str, Any]</code> <p>Subgroup configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>Subgroup ID if successful, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_user_federation_mapper","title":"create_user_federation_mapper  <code>async</code>","text":"<pre><code>create_user_federation_mapper(\n    realm_name,\n    parent_id,\n    mapper_config,\n    namespace=\"default\",\n)\n</code></pre> <p>Create a mapper for a user federation provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>parent_id</code> <code>str</code> <p>ID of the parent federation provider</p> required <code>mapper_config</code> <code>ComponentRepresentation | dict[str, Any]</code> <p>Mapper configuration</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>ID of the created mapper, or None on failure</p> Example <p>mapper = ComponentRepresentation(     name=\"email\",     provider_id=\"user-attribute-ldap-mapper\",     provider_type=\"org.keycloak.storage.ldap.mappers.LDAPStorageMapper\",     parent_id=federation_id,     config={         \"ldap.attribute\": [\"mail\"],         \"user.model.attribute\": [\"email\"],         \"read.only\": [\"true\"],     } ) mapper_id = await admin_client.create_user_federation_mapper(     \"my-realm\", federation_id, mapper )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.create_user_federation_provider","title":"create_user_federation_provider  <code>async</code>","text":"<pre><code>create_user_federation_provider(\n    realm_name, federation_config, namespace=\"default\"\n)\n</code></pre> <p>Create a new user federation provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>federation_config</code> <code>ComponentRepresentation | dict[str, Any]</code> <p>Federation provider configuration</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>str | None</code> <p>ID of the created provider, or None on failure</p> Example <p>config = ComponentRepresentation(     name=\"corporate-ldap\",     provider_id=\"ldap\",     provider_type=\"org.keycloak.storage.UserStorageProvider\",     config={         \"connectionUrl\": [\"ldap://ldap.example.com:389\"],         \"usersDn\": [\"ou=People,dc=example,dc=org\"],         \"bindDn\": [\"cn=admin,dc=example,dc=org\"],         \"bindCredential\": [\"secret\"],         \"vendor\": [\"other\"],     } ) provider_id = await admin_client.create_user_federation_provider(     \"my-realm\", config )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_authentication_flow","title":"delete_authentication_flow  <code>async</code>","text":"<pre><code>delete_authentication_flow(realm_name, flow_id, namespace)\n</code></pre> <p>Delete an authentication flow.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_id</code> <code>str</code> <p>ID of the flow to delete</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_client","title":"delete_client  <code>async</code>","text":"<pre><code>delete_client(client_id, realm_name, namespace)\n</code></pre> <p>Delete a client from the specified realm.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID to delete</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm (defaults to \"master\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_client_protocol_mapper","title":"delete_client_protocol_mapper  <code>async</code>","text":"<pre><code>delete_client_protocol_mapper(\n    client_uuid,\n    mapper_id,\n    realm_name=\"master\",\n    namespace=\"default\",\n)\n</code></pre> <p>Delete a protocol mapper from a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>mapper_id</code> <code>str</code> <p>ID of the protocol mapper</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_client_role","title":"delete_client_role  <code>async</code>","text":"<pre><code>delete_client_role(\n    client_uuid,\n    role_name,\n    realm_name=\"master\",\n    namespace=\"default\",\n)\n</code></pre> <p>Delete a role from a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>role_name</code> <code>str</code> <p>Name of the role to delete</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_client_scope","title":"delete_client_scope  <code>async</code>","text":"<pre><code>delete_client_scope(\n    realm_name, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Delete a client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to delete</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if deletion successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_client_scope_protocol_mapper","title":"delete_client_scope_protocol_mapper  <code>async</code>","text":"<pre><code>delete_client_scope_protocol_mapper(\n    realm_name, scope_id, mapper_id, namespace=\"default\"\n)\n</code></pre> <p>Delete a protocol mapper from a client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope</p> required <code>mapper_id</code> <code>str</code> <p>ID of the mapper to delete</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if deletion successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_execution","title":"delete_execution  <code>async</code>","text":"<pre><code>delete_execution(realm_name, execution_id, namespace)\n</code></pre> <p>Delete an execution from a flow.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>execution_id</code> <code>str</code> <p>ID of the execution to delete</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_group","title":"delete_group  <code>async</code>","text":"<pre><code>delete_group(realm_name, group_id, namespace='default')\n</code></pre> <p>Delete a group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group to delete</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_identity_provider","title":"delete_identity_provider  <code>async</code>","text":"<pre><code>delete_identity_provider(realm_name, alias, namespace)\n</code></pre> <p>Delete an identity provider by alias.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful or not found, False on error</p> Example <p>success = await admin_client.delete_identity_provider(\"my-realm\", \"github\", \"default\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_identity_provider_mapper","title":"delete_identity_provider_mapper  <code>async</code>","text":"<pre><code>delete_identity_provider_mapper(\n    realm_name, alias, mapper_id, namespace\n)\n</code></pre> <p>Delete a mapper from an identity provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>mapper_id</code> <code>str</code> <p>Mapper ID</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful or not found, False on error</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_realm","title":"delete_realm  <code>async</code>","text":"<pre><code>delete_realm(realm_name, namespace)\n</code></pre> <p>Delete a realm from Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm to delete</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_realm_role","title":"delete_realm_role  <code>async</code>","text":"<pre><code>delete_realm_role(\n    realm_name, role_name, namespace=\"default\"\n)\n</code></pre> <p>Delete a realm-level role.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_name</code> <code>str</code> <p>Name of the role to delete</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_user_federation_mapper","title":"delete_user_federation_mapper  <code>async</code>","text":"<pre><code>delete_user_federation_mapper(\n    realm_name, mapper_id, namespace=\"default\"\n)\n</code></pre> <p>Delete a user federation mapper.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>mapper_id</code> <code>str</code> <p>ID of the mapper to delete</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.delete_user_federation_provider","title":"delete_user_federation_provider  <code>async</code>","text":"<pre><code>delete_user_federation_provider(\n    realm_name, provider_id, namespace=\"default\"\n)\n</code></pre> <p>Delete a user federation provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_id</code> <code>str</code> <p>ID of the federation provider to delete</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.export_realm","title":"export_realm  <code>async</code>","text":"<pre><code>export_realm(realm_name, namespace)\n</code></pre> <p>Export realm configuration from Keycloak.</p> <p>Based on OpenAPI spec: GET /admin/realms/{realm} Returns the complete realm representation.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm to export</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RealmRepresentation | None</code> <p>Complete realm configuration as RealmRepresentation or None if not found</p> Example <p>realm = await client.export_realm(\"my-realm\", \"default\") if realm:     print(f\"Realm {realm.realm} has {len(realm.clients or [])} clients\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_authentication_flow_by_alias","title":"get_authentication_flow_by_alias  <code>async</code>","text":"<pre><code>get_authentication_flow_by_alias(\n    realm_name, flow_alias, namespace\n)\n</code></pre> <p>Get a specific authentication flow by alias.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the flow</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>AuthenticationFlowRepresentation | None</code> <p>Authentication flow or None if not found</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_authentication_flows","title":"get_authentication_flows  <code>async</code>","text":"<pre><code>get_authentication_flows(realm_name, namespace)\n</code></pre> <p>Get all authentication flows for a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>list[AuthenticationFlowRepresentation]</code> <p>List of authentication flows</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_authenticator_config","title":"get_authenticator_config  <code>async</code>","text":"<pre><code>get_authenticator_config(realm_name, config_id, namespace)\n</code></pre> <p>Get authenticator configuration by ID.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>config_id</code> <code>str</code> <p>ID of the authenticator config</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>AuthenticatorConfigRepresentation | None</code> <p>Authenticator config or None if not found</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_by_name","title":"get_client_by_name  <code>async</code>","text":"<pre><code>get_client_by_name(client_id, realm_name, namespace)\n</code></pre> <p>Get a client by its client ID in the specified realm.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID to search for</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>ClientRepresentation | None</code> <p>Client data as ClientRepresentation if found, None otherwise</p> Example <p>client = await admin_client.get_client_by_name(\"my-client\", \"my-realm\", \"default\") if client:     print(f\"Client UUID: {client.id}, Enabled: {client.enabled}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_default_scopes","title":"get_client_default_scopes  <code>async</code>","text":"<pre><code>get_client_default_scopes(\n    realm_name, client_uuid, namespace=\"default\"\n)\n</code></pre> <p>Get default client scopes assigned to a specific client.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ClientScopeRepresentation]</code> <p>List of default client scopes for this client</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_optional_scopes","title":"get_client_optional_scopes  <code>async</code>","text":"<pre><code>get_client_optional_scopes(\n    realm_name, client_uuid, namespace=\"default\"\n)\n</code></pre> <p>Get optional client scopes assigned to a specific client.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ClientScopeRepresentation]</code> <p>List of optional client scopes for this client</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_protocol_mappers","title":"get_client_protocol_mappers  <code>async</code>","text":"<pre><code>get_client_protocol_mappers(\n    client_uuid, realm_name=\"master\", namespace=\"default\"\n)\n</code></pre> <p>Get all protocol mappers for a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>list[ProtocolMapperRepresentation]</code> <p>List of protocol mapper configurations as ProtocolMapperRepresentation</p> Example <p>mappers = admin_client.get_client_protocol_mappers(client_uuid, \"my-realm\") for mapper in mappers:     print(f\"Mapper: {mapper.name}, Protocol: {mapper.protocol}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_role","title":"get_client_role  <code>async</code>","text":"<pre><code>get_client_role(\n    client_uuid, role_name, realm_name, namespace\n)\n</code></pre> <p>Get a client role by name.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>role_name</code> <code>str</code> <p>Name of the role to retrieve</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RoleRepresentation | None</code> <p>Role representation as RoleRepresentation or None if not found</p> Example <p>role = await admin_client.get_client_role(client_uuid, \"admin\", \"my-realm\", \"default\") if role:     print(f\"Client role: {role.name}, ID: {role.id}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_roles","title":"get_client_roles  <code>async</code>","text":"<pre><code>get_client_roles(\n    client_uuid, realm_name=\"master\", namespace=\"default\"\n)\n</code></pre> <p>Get all roles for a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>list[RoleRepresentation]</code> <p>List of client role configurations as RoleRepresentation</p> Example <p>roles = admin_client.get_client_roles(client_uuid, \"my-realm\") for role in roles:     print(f\"Role: {role.name}, ID: {role.id}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_scope_by_name","title":"get_client_scope_by_name  <code>async</code>","text":"<pre><code>get_client_scope_by_name(\n    realm_name, scope_name, namespace=\"default\"\n)\n</code></pre> <p>Get a specific client scope by name.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_name</code> <code>str</code> <p>Name of the client scope</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>ClientScopeRepresentation | None</code> <p>ClientScopeRepresentation if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_scope_protocol_mappers","title":"get_client_scope_protocol_mappers  <code>async</code>","text":"<pre><code>get_client_scope_protocol_mappers(\n    realm_name, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Get protocol mappers for a client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ProtocolMapperRepresentation]</code> <p>List of protocol mappers</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_scopes","title":"get_client_scopes  <code>async</code>","text":"<pre><code>get_client_scopes(realm_name, namespace='default')\n</code></pre> <p>Get all client scopes in a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ClientScopeRepresentation]</code> <p>List of client scopes as ClientScopeRepresentation</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_secret","title":"get_client_secret  <code>async</code>","text":"<pre><code>get_client_secret(client_id, realm_name, namespace)\n</code></pre> <p>Get the client secret for a confidential client.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm (defaults to \"master\")</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client secret if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_client_uuid","title":"get_client_uuid  <code>async</code>","text":"<pre><code>get_client_uuid(client_id, realm_name, namespace)\n</code></pre> <p>Get client UUID by client ID in the specified realm.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID to search for</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Client UUID if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_default_groups","title":"get_default_groups  <code>async</code>","text":"<pre><code>get_default_groups(realm_name, namespace='default')\n</code></pre> <p>Get the default groups for a realm.</p> <p>Default groups are automatically assigned to new users.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[GroupRepresentation]</code> <p>List of default groups</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_flow_executions","title":"get_flow_executions  <code>async</code>","text":"<pre><code>get_flow_executions(realm_name, flow_alias, namespace)\n</code></pre> <p>Get all executions for an authentication flow.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the flow</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>list[AuthenticationExecutionInfoRepresentation]</code> <p>List of execution info representations</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_group_by_id","title":"get_group_by_id  <code>async</code>","text":"<pre><code>get_group_by_id(realm_name, group_id, namespace='default')\n</code></pre> <p>Get a specific group by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>GroupRepresentation | None</code> <p>GroupRepresentation if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_group_by_path","title":"get_group_by_path  <code>async</code>","text":"<pre><code>get_group_by_path(realm_name, path, namespace='default')\n</code></pre> <p>Get a group by its path (e.g., /parent/child).</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>path</code> <code>str</code> <p>Group path (e.g., \"/parent/child\")</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>GroupRepresentation | None</code> <p>GroupRepresentation if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_group_client_role_mappings","title":"get_group_client_role_mappings  <code>async</code>","text":"<pre><code>get_group_client_role_mappings(\n    realm_name, group_id, client_uuid, namespace=\"default\"\n)\n</code></pre> <p>Get client role mappings for a group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[RoleRepresentation]</code> <p>List of assigned client roles</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_group_realm_role_mappings","title":"get_group_realm_role_mappings  <code>async</code>","text":"<pre><code>get_group_realm_role_mappings(\n    realm_name, group_id, namespace=\"default\"\n)\n</code></pre> <p>Get realm role mappings for a group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[RoleRepresentation]</code> <p>List of assigned realm roles</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_groups","title":"get_groups  <code>async</code>","text":"<pre><code>get_groups(\n    realm_name,\n    namespace=\"default\",\n    brief_representation=False,\n)\n</code></pre> <p>Get all top-level groups in a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <code>brief_representation</code> <code>bool</code> <p>If true, returns only basic group info</p> <code>False</code> <p>Returns:</p> Type Description <code>list[GroupRepresentation]</code> <p>List of group configurations</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_identity_provider","title":"get_identity_provider  <code>async</code>","text":"<pre><code>get_identity_provider(realm_name, alias, namespace)\n</code></pre> <p>Get an identity provider by alias.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>IdentityProviderRepresentation | None</code> <p>IdentityProviderRepresentation if found, None otherwise</p> Example <p>idp = await admin_client.get_identity_provider(\"my-realm\", \"github\", \"default\") if idp:     print(f\"IdP: {idp.alias}, Enabled: {idp.enabled}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_identity_provider_mapper","title":"get_identity_provider_mapper  <code>async</code>","text":"<pre><code>get_identity_provider_mapper(\n    realm_name, alias, mapper_id, namespace\n)\n</code></pre> <p>Get a specific mapper by ID.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>mapper_id</code> <code>str</code> <p>Mapper ID</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>IdentityProviderMapperRepresentation | None</code> <p>IdentityProviderMapperRepresentation if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_identity_provider_mappers","title":"get_identity_provider_mappers  <code>async</code>","text":"<pre><code>get_identity_provider_mappers(realm_name, alias, namespace)\n</code></pre> <p>Get all mappers for an identity provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>list[IdentityProviderMapperRepresentation]</code> <p>List of IdentityProviderMapperRepresentation objects</p> Example <p>mappers = await admin_client.get_identity_provider_mappers(     \"my-realm\", \"github\", \"default\" ) for mapper in mappers:     print(f\"Mapper: {mapper.name}, Type: {mapper.identity_provider_mapper}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_identity_providers","title":"get_identity_providers  <code>async</code>","text":"<pre><code>get_identity_providers(realm_name, namespace)\n</code></pre> <p>Get all identity providers for a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>list[IdentityProviderRepresentation]</code> <p>List of IdentityProviderRepresentation objects</p> Example <p>idps = await admin_client.get_identity_providers(\"my-realm\", \"default\") for idp in idps:     print(f\"IdP: {idp.alias}, Enabled: {idp.enabled}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm","title":"get_realm  <code>async</code>","text":"<pre><code>get_realm(realm_name, namespace)\n</code></pre> <p>Get realm configuration from Keycloak.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm to retrieve</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RealmRepresentation | None</code> <p>Realm configuration as RealmRepresentation or None if not found</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If the request fails (except 404)</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_clients","title":"get_realm_clients  <code>async</code>","text":"<pre><code>get_realm_clients(realm_name, namespace)\n</code></pre> <p>Get all clients in a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <p>Returns:</p> Type Description <code>list[ClientRepresentation]</code> <p>List of client configurations as ClientRepresentation</p> Example <p>clients = admin_client.get_realm_clients(\"my-realm\") for client in clients:     print(f\"Client: {client.client_id}, Enabled: {client.enabled}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_default_client_scopes","title":"get_realm_default_client_scopes  <code>async</code>","text":"<pre><code>get_realm_default_client_scopes(\n    realm_name, namespace=\"default\"\n)\n</code></pre> <p>Get realm default client scopes.</p> <p>These scopes are assigned to all new clients by default.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ClientScopeRepresentation]</code> <p>List of default client scopes</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_optional_client_scopes","title":"get_realm_optional_client_scopes  <code>async</code>","text":"<pre><code>get_realm_optional_client_scopes(\n    realm_name, namespace=\"default\"\n)\n</code></pre> <p>Get realm optional client scopes.</p> <p>These scopes are available for clients to request optionally.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ClientScopeRepresentation]</code> <p>List of optional client scopes</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_role","title":"get_realm_role  <code>async</code>","text":"<pre><code>get_realm_role(role_name, realm_name, namespace)\n</code></pre> <p>Get a realm role by name.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Name of the role to retrieve</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RoleRepresentation | None</code> <p>Role representation as RoleRepresentation or None if not found</p> Example <p>role = await admin_client.get_realm_role(\"admin\", \"my-realm\", \"default\") if role:     print(f\"Role: {role.name}, ID: {role.id}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_role_by_name","title":"get_realm_role_by_name  <code>async</code>","text":"<pre><code>get_realm_role_by_name(\n    realm_name, role_name, namespace=\"default\"\n)\n</code></pre> <p>Get a specific realm role by name.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_name</code> <code>str</code> <p>Name of the role</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>RoleRepresentation | None</code> <p>RoleRepresentation if found, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_role_composites","title":"get_realm_role_composites  <code>async</code>","text":"<pre><code>get_realm_role_composites(\n    realm_name, role_name, namespace=\"default\"\n)\n</code></pre> <p>Get composite roles (child roles) of a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_name</code> <code>str</code> <p>Name of the composite role</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[RoleRepresentation]</code> <p>List of child role configurations</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realm_roles","title":"get_realm_roles  <code>async</code>","text":"<pre><code>get_realm_roles(realm_name, namespace='default')\n</code></pre> <p>Get all realm-level roles.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[RoleRepresentation]</code> <p>List of realm role configurations as RoleRepresentation</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_realms","title":"get_realms  <code>async</code>","text":"<pre><code>get_realms(namespace, brief_representation=False)\n</code></pre> <p>Get all accessible realms from Keycloak.</p> <p>Based on OpenAPI spec: GET /admin/realms Returns a list of accessible realms filtered by what the caller is allowed to view.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <code>brief_representation</code> <code>bool</code> <p>If True, return brief representation of realms</p> <code>False</code> <p>Returns:</p> Type Description <code>list[RealmRepresentation] | None</code> <p>List of realm configurations as RealmRepresentation or None on error</p> Example <p>realms = await client.get_realms(\"default\") for realm in realms:     print(f\"Realm: {realm.realm}, Enabled: {realm.enabled}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_required_action","title":"get_required_action  <code>async</code>","text":"<pre><code>get_required_action(realm_name, action_alias, namespace)\n</code></pre> <p>Get a specific required action by alias.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>action_alias</code> <code>str</code> <p>Alias of the required action</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RequiredActionProviderRepresentation | None</code> <p>Required action provider or None if not found</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_required_actions","title":"get_required_actions  <code>async</code>","text":"<pre><code>get_required_actions(realm_name, namespace)\n</code></pre> <p>Get all required actions for a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>list[RequiredActionProviderRepresentation]</code> <p>List of required action provider representations</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_service_account_user","title":"get_service_account_user  <code>async</code>","text":"<pre><code>get_service_account_user(\n    client_uuid, realm_name, namespace\n)\n</code></pre> <p>Get the service account user for a client.</p> <p>Based on OpenAPI spec: GET /admin/realms/{realm}/clients/{id}/service-account-user</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>Client UUID in Keycloak</p> required <code>realm_name</code> <code>str</code> <p>Target realm name</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>UserRepresentation</code> <p>Service account user representation as UserRepresentation</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If retrieval fails or service account is disabled</p> Example <p>user = await admin_client.get_service_account_user(client_uuid, \"my-realm\", \"default\") print(f\"Service account user: {user.username}, ID: {user.id}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_user_federation_mappers","title":"get_user_federation_mappers  <code>async</code>","text":"<pre><code>get_user_federation_mappers(\n    realm_name, parent_id, namespace=\"default\"\n)\n</code></pre> <p>Get all mappers for a user federation provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>parent_id</code> <code>str</code> <p>ID of the parent federation provider</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ComponentRepresentation]</code> <p>List of mapper configurations</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_user_federation_provider","title":"get_user_federation_provider  <code>async</code>","text":"<pre><code>get_user_federation_provider(\n    realm_name, provider_id, namespace=\"default\"\n)\n</code></pre> <p>Get a specific user federation provider by ID.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_id</code> <code>str</code> <p>ID of the federation provider component</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>ComponentRepresentation | None</code> <p>Federation provider configuration or None if not found</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_user_federation_provider_by_name","title":"get_user_federation_provider_by_name  <code>async</code>","text":"<pre><code>get_user_federation_provider_by_name(\n    realm_name, provider_name, namespace=\"default\"\n)\n</code></pre> <p>Get a user federation provider by its display name.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_name</code> <code>str</code> <p>Display name of the federation provider</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>ComponentRepresentation | None</code> <p>Federation provider configuration or None if not found</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.get_user_federation_providers","title":"get_user_federation_providers  <code>async</code>","text":"<pre><code>get_user_federation_providers(\n    realm_name, namespace=\"default\"\n)\n</code></pre> <p>Get all user federation providers for a realm.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>list[ComponentRepresentation]</code> <p>List of user federation provider configurations</p> Example <p>providers = await admin_client.get_user_federation_providers(\"my-realm\") for provider in providers:     print(f\"Provider: {provider.name}, Type: {provider.provider_id}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.regenerate_client_secret","title":"regenerate_client_secret  <code>async</code>","text":"<pre><code>regenerate_client_secret(client_id, realm_name, namespace)\n</code></pre> <p>Regenerate the client secret for a confidential client.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>The client ID</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm (defaults to \"master\")</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>New client secret if successful, None otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.register_required_action","title":"register_required_action  <code>async</code>","text":"<pre><code>register_required_action(\n    realm_name, provider_id, name, namespace\n)\n</code></pre> <p>Register a new required action provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_id</code> <code>str</code> <p>Provider ID for the required action</p> required <code>name</code> <code>str</code> <p>Display name for the action</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_client_default_scope","title":"remove_client_default_scope  <code>async</code>","text":"<pre><code>remove_client_default_scope(\n    realm_name, client_uuid, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Remove a client scope from a client's default scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to remove</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_client_optional_scope","title":"remove_client_optional_scope  <code>async</code>","text":"<pre><code>remove_client_optional_scope(\n    realm_name, client_uuid, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Remove a client scope from a client's optional scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>client_uuid</code> <code>str</code> <p>UUID of the client</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to remove</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_default_group","title":"remove_default_group  <code>async</code>","text":"<pre><code>remove_default_group(\n    realm_name, group_id, namespace=\"default\"\n)\n</code></pre> <p>Remove a group from the default groups.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group to remove from defaults</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_realm_default_client_scope","title":"remove_realm_default_client_scope  <code>async</code>","text":"<pre><code>remove_realm_default_client_scope(\n    realm_name, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Remove a client scope from realm default client scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to remove</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_realm_optional_client_scope","title":"remove_realm_optional_client_scope  <code>async</code>","text":"<pre><code>remove_realm_optional_client_scope(\n    realm_name, scope_id, namespace=\"default\"\n)\n</code></pre> <p>Remove a client scope from realm optional client scopes.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to remove</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_realm_role_composites","title":"remove_realm_role_composites  <code>async</code>","text":"<pre><code>remove_realm_role_composites(\n    realm_name, role_name, child_roles, namespace=\"default\"\n)\n</code></pre> <p>Remove composite (child) roles from a realm role.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_name</code> <code>str</code> <p>Name of the parent role</p> required <code>child_roles</code> <code>list[RoleRepresentation] | list[dict[str, Any]]</code> <p>List of roles to remove from composites</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.remove_realm_roles_from_group","title":"remove_realm_roles_from_group  <code>async</code>","text":"<pre><code>remove_realm_roles_from_group(\n    realm_name, group_id, roles, namespace=\"default\"\n)\n</code></pre> <p>Remove realm roles from a group.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group</p> required <code>roles</code> <code>list[RoleRepresentation] | list[dict[str, Any]]</code> <p>List of roles to remove</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.test_ldap_authentication","title":"test_ldap_authentication  <code>async</code>","text":"<pre><code>test_ldap_authentication(\n    realm_name, connection_config, namespace=\"default\"\n)\n</code></pre> <p>Test LDAP authentication (bind) settings.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>connection_config</code> <code>dict[str, Any]</code> <p>LDAP connection configuration with bind credentials</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with test results</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.test_ldap_connection","title":"test_ldap_connection  <code>async</code>","text":"<pre><code>test_ldap_connection(\n    realm_name, connection_config, namespace=\"default\"\n)\n</code></pre> <p>Test LDAP connection settings before creating a provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>connection_config</code> <code>dict[str, Any]</code> <p>LDAP connection configuration to test</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with test results</p> Example <p>result = await admin_client.test_ldap_connection(     \"my-realm\",     {         \"connectionUrl\": \"ldap://ldap.example.com:389\",         \"bindDn\": \"cn=admin,dc=example,dc=org\",         \"bindCredential\": \"secret\",     } ) if result.get(\"status\") == \"success\":     print(\"Connection successful!\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.trigger_user_federation_sync","title":"trigger_user_federation_sync  <code>async</code>","text":"<pre><code>trigger_user_federation_sync(\n    realm_name,\n    provider_id,\n    full_sync=False,\n    namespace=\"default\",\n)\n</code></pre> <p>Trigger synchronization for a user federation provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_id</code> <code>str</code> <p>ID of the federation provider</p> required <code>full_sync</code> <code>bool</code> <p>If True, perform full sync; otherwise, sync only changed users</p> <code>False</code> <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with sync results (added, updated, removed, failed counts)</p> Example <p>result = await admin_client.trigger_user_federation_sync(     \"my-realm\", provider_id, full_sync=True ) print(f\"Added: {result.get('added')}, Updated: {result.get('updated')}\")</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_authenticator_config","title":"update_authenticator_config  <code>async</code>","text":"<pre><code>update_authenticator_config(\n    realm_name, config_id, config, namespace\n)\n</code></pre> <p>Update an authenticator configuration.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>config_id</code> <code>str</code> <p>ID of the config to update</p> required <code>config</code> <code>AuthenticatorConfigRepresentation | dict[str, Any]</code> <p>Updated authenticator configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_client","title":"update_client  <code>async</code>","text":"<pre><code>update_client(\n    client_uuid, client_config, realm_name, namespace\n)\n</code></pre> <p>Update an existing client configuration.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>The UUID of the client to update</p> required <code>client_config</code> <code>ClientRepresentation | dict[str, Any]</code> <p>Updated client configuration as ClientRepresentation or dict</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If client update fails</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_client_protocol_mapper","title":"update_client_protocol_mapper  <code>async</code>","text":"<pre><code>update_client_protocol_mapper(\n    client_uuid,\n    mapper_id,\n    mapper_config,\n    realm_name=\"master\",\n)\n</code></pre> <p>Update a protocol mapper for a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>mapper_id</code> <code>str</code> <p>ID of the protocol mapper</p> required <code>mapper_config</code> <code>ProtocolMapperRepresentation | dict[str, Any]</code> <p>Updated protocol mapper configuration as ProtocolMapperRepresentation or dict</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>mappers = admin_client.get_client_protocol_mappers(client_uuid, \"my-realm\") mapper = mappers[0] mapper.protocol = \"saml\" success = admin_client.update_client_protocol_mapper(     client_uuid, mapper.id, mapper, \"my-realm\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_client_role","title":"update_client_role  <code>async</code>","text":"<pre><code>update_client_role(\n    client_uuid, role_name, role_config, realm_name=\"master\"\n)\n</code></pre> <p>Update a role for a client.</p> <p>Parameters:</p> Name Type Description Default <code>client_uuid</code> <code>str</code> <p>UUID of the client in Keycloak</p> required <code>role_name</code> <code>str</code> <p>Name of the role to update</p> required <code>role_config</code> <code>RoleRepresentation | dict[str, Any]</code> <p>Updated role configuration as RoleRepresentation or dict</p> required <code>realm_name</code> <code>str</code> <p>Name of the realm</p> <code>'master'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>role = admin_client.get_client_role(client_uuid, \"admin\", \"my-realm\") role.description = \"Updated description\" success = admin_client.update_client_role(     client_uuid, \"admin\", role, \"my-realm\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_client_scope","title":"update_client_scope  <code>async</code>","text":"<pre><code>update_client_scope(\n    realm_name, scope_id, scope_config, namespace=\"default\"\n)\n</code></pre> <p>Update an existing client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope to update</p> required <code>scope_config</code> <code>ClientScopeRepresentation | dict[str, Any]</code> <p>Updated client scope configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if update successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_client_scope_protocol_mapper","title":"update_client_scope_protocol_mapper  <code>async</code>","text":"<pre><code>update_client_scope_protocol_mapper(\n    realm_name,\n    scope_id,\n    mapper_id,\n    mapper_config,\n    namespace=\"default\",\n)\n</code></pre> <p>Update a protocol mapper in a client scope.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>scope_id</code> <code>str</code> <p>ID of the client scope</p> required <code>mapper_id</code> <code>str</code> <p>ID of the mapper to update</p> required <code>mapper_config</code> <code>ProtocolMapperRepresentation | dict[str, Any]</code> <p>Updated protocol mapper configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if update successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_execution_requirement","title":"update_execution_requirement  <code>async</code>","text":"<pre><code>update_execution_requirement(\n    realm_name,\n    flow_alias,\n    execution_id,\n    requirement,\n    namespace,\n)\n</code></pre> <p>Update the requirement level of an execution.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>flow_alias</code> <code>str</code> <p>Alias of the parent flow</p> required <code>execution_id</code> <code>str</code> <p>ID of the execution to update</p> required <code>requirement</code> <code>str</code> <p>New requirement level (REQUIRED, ALTERNATIVE, DISABLED, CONDITIONAL)</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_group","title":"update_group  <code>async</code>","text":"<pre><code>update_group(\n    realm_name, group_id, group_config, namespace=\"default\"\n)\n</code></pre> <p>Update an existing group.</p> <p>Note: Keycloak's PUT endpoint ignores subGroups - they must be managed separately via create_subgroup(). Read-only fields (path, subGroupCount, access) are excluded from the update payload to prevent 500 errors.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>group_id</code> <code>str</code> <p>ID of the group to update</p> required <code>group_config</code> <code>GroupRepresentation | dict[str, Any]</code> <p>Updated group configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_identity_provider","title":"update_identity_provider  <code>async</code>","text":"<pre><code>update_identity_provider(\n    realm_name, alias, provider_config, namespace\n)\n</code></pre> <p>Update an existing identity provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>provider_config</code> <code>IdentityProviderRepresentation | dict[str, Any]</code> <p>Updated identity provider configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p> Example <p>idp = await admin_client.get_identity_provider(\"my-realm\", \"github\", \"default\") idp.enabled = False success = await admin_client.update_identity_provider(     \"my-realm\", \"github\", idp, \"default\" )</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_identity_provider_mapper","title":"update_identity_provider_mapper  <code>async</code>","text":"<pre><code>update_identity_provider_mapper(\n    realm_name, alias, mapper_id, mapper, namespace\n)\n</code></pre> <p>Update an existing mapper.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>alias</code> <code>str</code> <p>Identity provider alias</p> required <code>mapper_id</code> <code>str</code> <p>Mapper ID</p> required <code>mapper</code> <code>IdentityProviderMapperRepresentation | dict[str, Any]</code> <p>Updated mapper configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_realm","title":"update_realm  <code>async</code>","text":"<pre><code>update_realm(realm_name, realm_config, namespace)\n</code></pre> <p>Update realm configuration.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm to update</p> required <code>realm_config</code> <code>RealmRepresentation | dict[str, Any]</code> <p>Updated realm configuration as RealmRepresentation or dict</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>RealmRepresentation</code> <p>Updated realm configuration as RealmRepresentation</p> <p>Raises:</p> Type Description <code>KeycloakAdminError</code> <p>If realm update fails</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_realm_role","title":"update_realm_role  <code>async</code>","text":"<pre><code>update_realm_role(\n    realm_name, role_name, role_config, namespace=\"default\"\n)\n</code></pre> <p>Update an existing realm-level role.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>role_name</code> <code>str</code> <p>Name of the existing role</p> required <code>role_config</code> <code>RoleRepresentation | dict[str, Any]</code> <p>Updated role configuration</p> required <code>namespace</code> <code>str</code> <p>Namespace for rate limiting</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_realm_themes","title":"update_realm_themes  <code>async</code>","text":"<pre><code>update_realm_themes(realm_name, themes, namespace)\n</code></pre> <p>Update realm theme configuration.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>themes</code> <code>dict[str, Any]</code> <p>Theme configuration</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_required_action","title":"update_required_action  <code>async</code>","text":"<pre><code>update_required_action(\n    realm_name, action_alias, action_config, namespace\n)\n</code></pre> <p>Update a required action configuration.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>action_alias</code> <code>str</code> <p>Alias of the required action to update</p> required <code>action_config</code> <code>RequiredActionProviderRepresentation | dict[str, Any]</code> <p>Updated action configuration</p> required <code>namespace</code> <code>str</code> <p>Origin namespace for rate limiting</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminClient.update_user_federation_provider","title":"update_user_federation_provider  <code>async</code>","text":"<pre><code>update_user_federation_provider(\n    realm_name,\n    provider_id,\n    federation_config,\n    namespace=\"default\",\n)\n</code></pre> <p>Update an existing user federation provider.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Name of the realm</p> required <code>provider_id</code> <code>str</code> <p>ID of the federation provider to update</p> required <code>federation_config</code> <code>ComponentRepresentation | dict[str, Any]</code> <p>Updated federation configuration</p> required <code>namespace</code> <code>str</code> <p>Kubernetes namespace (for logging)</p> <code>'default'</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if successful, False otherwise</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminError","title":"KeycloakAdminError","text":"<pre><code>KeycloakAdminError(\n    message, status_code=None, response_body=None\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for Keycloak Admin API errors.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.KeycloakAdminError.body_preview","title":"body_preview","text":"<pre><code>body_preview(limit=2048)\n</code></pre> <p>Return a truncated preview of the response body for logging.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.api_create","title":"api_create","text":"<pre><code>api_create(resource_name, conflict_is_success=True)\n</code></pre> <p>Decorator for CREATE operations.</p> <p>Handles common error cases: - 409 Conflict: Optionally treated as success (resource exists) - Other errors: Returns None</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Human-readable resource name for logging</p> required <code>conflict_is_success</code> <code>bool</code> <p>If True, 409 returns None gracefully (idempotent create)</p> <code>True</code>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.api_delete","title":"api_delete","text":"<pre><code>api_delete(resource_name, not_found_is_success=True)\n</code></pre> <p>Decorator for DELETE operations.</p> <p>Handles common error cases: - 404 Not Found: Optionally treated as success (idempotent delete) - Other errors: Returns False</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Human-readable resource name for logging</p> required <code>not_found_is_success</code> <code>bool</code> <p>If True, 404 returns True (idempotent delete)</p> <code>True</code>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.api_get_list","title":"api_get_list","text":"<pre><code>api_get_list(resource_name)\n</code></pre> <p>Decorator for GET list operations.</p> <p>Handles common error cases: - Returns empty list on any exception - Logs errors with consistent format</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Human-readable resource name for logging (e.g., \"client scopes\")</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.api_get_single","title":"api_get_single","text":"<pre><code>api_get_single(resource_name)\n</code></pre> <p>Decorator for GET single resource operations.</p> <p>Handles common error cases: - Returns None on any exception (resource not found or error) - Logs errors with consistent format</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Human-readable resource name for logging (e.g., \"client scope\")</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.api_update","title":"api_update","text":"<pre><code>api_update(resource_name, conflict_is_success=False)\n</code></pre> <p>Decorator for UPDATE operations.</p> <p>Handles common error cases: - 409 Conflict: Optionally treated as success (idempotent add) - Other errors: Returns False - Logs errors with consistent format</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Human-readable resource name for logging</p> required <code>conflict_is_success</code> <code>bool</code> <p>If True, treat 409 Conflict as success (already exists)</p> <code>False</code>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.keycloak_admin.get_keycloak_admin_client","title":"get_keycloak_admin_client  <code>async</code>","text":"<pre><code>get_keycloak_admin_client(\n    keycloak_name,\n    namespace,\n    rate_limiter=None,\n    verify_ssl=False,\n)\n</code></pre> <p>Factory function to create KeycloakAdminClient for a specific instance.</p> <p>This function handles: - Looking up Keycloak instance details from Kubernetes - Retrieving admin credentials from secrets - Creating configured admin client with rate limiting</p> <p>Parameters:</p> Name Type Description Default <code>keycloak_name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>namespace</code> <code>str</code> <p>Namespace where the Keycloak instance exists</p> required <code>rate_limiter</code> <code>RateLimiter | None</code> <p>Optional rate limiter for API throttling</p> <code>None</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates (default: False for development)</p> <code>False</code> <p>Returns:</p> Type Description <code>KeycloakAdminClient</code> <p>Configured KeycloakAdminClient instance</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.ValidationError","title":"ValidationError","text":"<pre><code>ValidationError(message, field=None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raised for validation failures.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation._extract_version_from_image","title":"_extract_version_from_image","text":"<pre><code>_extract_version_from_image(image)\n</code></pre> <p>Extract version tag from container image reference.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Container image reference like \"quay.io/keycloak/keycloak:26.4.0\"</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>Version string or None if no version tag found</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation._parse_kubernetes_quantity","title":"_parse_kubernetes_quantity","text":"<pre><code>_parse_kubernetes_quantity(quantity)\n</code></pre> <p>Parse a Kubernetes quantity string into a numeric value.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>str</code> <p>Kubernetes quantity string (e.g., \"100m\", \"1Gi\", \"2\")</p> required <p>Returns:</p> Type Description <code>float</code> <p>Numeric value in base units</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If quantity format is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation._parse_version","title":"_parse_version","text":"<pre><code>_parse_version(version_string)\n</code></pre> <p>Parse a semantic version string into major, minor, patch tuple.</p> <p>Parameters:</p> Name Type Description Default <code>version_string</code> <code>str</code> <p>Version string like \"25.0.1\" or \"26.4.0\"</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>Tuple of (major, minor, patch) as integers</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If version format is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_client_id","title":"validate_client_id","text":"<pre><code>validate_client_id(client_id)\n</code></pre> <p>Validate Keycloak client ID format.</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID to validate</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If client ID is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_complete_resource","title":"validate_complete_resource","text":"<pre><code>validate_complete_resource(\n    resource, resource_type, namespace\n)\n</code></pre> <p>Perform complete validation of a resource specification.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>dict[str, Any]</code> <p>Complete resource definition</p> required <code>resource_type</code> <code>str</code> <p>Type of resource</p> required <code>namespace</code> <code>str</code> <p>Target namespace</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>List of dependencies found during validation</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If resource is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_cross_resource_references","title":"validate_cross_resource_references","text":"<pre><code>validate_cross_resource_references(\n    resource_spec, resource_type, namespace\n)\n</code></pre> <p>Validate cross-resource references and return list of dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>resource_spec</code> <code>dict[str, Any]</code> <p>Resource specification</p> required <code>resource_type</code> <code>str</code> <p>Type of the resource being validated</p> required <code>namespace</code> <code>str</code> <p>Current namespace</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>List of (resource_type, name, namespace) tuples for dependencies</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_environment_variables","title":"validate_environment_variables","text":"<pre><code>validate_environment_variables(env_vars)\n</code></pre> <p>Validate environment variable configuration.</p> <p>Parameters:</p> Name Type Description Default <code>env_vars</code> <code>dict[str, Any]</code> <p>Environment variables dictionary</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If environment variable configuration is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_image_reference","title":"validate_image_reference","text":"<pre><code>validate_image_reference(image)\n</code></pre> <p>Validate container image reference format.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Container image reference</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If image reference is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_keycloak_version","title":"validate_keycloak_version","text":"<pre><code>validate_keycloak_version(image)\n</code></pre> <p>Validate Keycloak version supports required features (management port).</p> <p>The management interface with separate port 9000 was introduced in Keycloak 25.0.0. Earlier versions do not support KC_HTTP_MANAGEMENT_PORT and will fail health checks.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Container image reference</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If Keycloak version is too old and doesn't support management port</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_namespace_name","title":"validate_namespace_name","text":"<pre><code>validate_namespace_name(namespace)\n</code></pre> <p>Validate Kubernetes namespace name.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Namespace name to validate</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If namespace name is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_no_keycloak_placeholders","title":"validate_no_keycloak_placeholders","text":"<pre><code>validate_no_keycloak_placeholders(\n    value, field_name=\"field\"\n)\n</code></pre> <p>Validate that a string value does not contain Keycloak environment variable placeholders.</p> <p>Keycloak supports placeholder syntax like ${keycloak:secret-name:key} or ${env.VAR} for runtime variable substitution. However, this operator manages Keycloak through the Admin REST API, not through Keycloak's config file mechanism. Placeholders cannot be resolved and will be passed literally to Keycloak, causing unexpected behavior.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>String value to check</p> required <code>field_name</code> <code>str</code> <p>Name of the field for error messages</p> <code>'field'</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If placeholder patterns are detected</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_realm_name","title":"validate_realm_name","text":"<pre><code>validate_realm_name(realm_name)\n</code></pre> <p>Validate Keycloak realm name format.</p> <p>Parameters:</p> Name Type Description Default <code>realm_name</code> <code>str</code> <p>Realm name to validate</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If realm name is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_redirect_uris","title":"validate_redirect_uris","text":"<pre><code>validate_redirect_uris(redirect_uris)\n</code></pre> <p>Validate OAuth2 redirect URIs.</p> <p>Parameters:</p> Name Type Description Default <code>redirect_uris</code> <code>list[str]</code> <p>List of redirect URIs to validate</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If any URI is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_resource_limits","title":"validate_resource_limits","text":"<pre><code>validate_resource_limits(resources)\n</code></pre> <p>Validate Kubernetes resource limits and requests.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>dict[str, Any]</code> <p>Resource specification dictionary</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If resource specification is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_resource_name","title":"validate_resource_name","text":"<pre><code>validate_resource_name(name, resource_type='resource')\n</code></pre> <p>Validate Kubernetes resource name according to DNS-1123 subdomain rules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Resource name to validate</p> required <code>resource_type</code> <code>str</code> <p>Type of resource for error messages</p> <code>'resource'</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If name is invalid</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_security_settings","title":"validate_security_settings","text":"<pre><code>validate_security_settings(spec, resource_type)\n</code></pre> <p>Validate security-related settings and provide recommendations.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Resource specification</p> required <code>resource_type</code> <code>str</code> <p>Type of resource being validated</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_spec_no_placeholders","title":"validate_spec_no_placeholders","text":"<pre><code>validate_spec_no_placeholders(spec, resource_type)\n</code></pre> <p>Recursively validate that a resource spec does not contain Keycloak placeholders.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>dict[str, Any]</code> <p>Resource specification dictionary</p> required <code>resource_type</code> <code>str</code> <p>Type of resource for error messages</p> required <p>Raises:</p> Type Description <code>ValidationError</code> <p>If placeholder patterns are detected in any string field</p>"},{"location":"api/keycloak_operator/#keycloak_operator.utils.validation.validate_url","title":"validate_url","text":"<pre><code>validate_url(url, url_type='URL')\n</code></pre> <p>Validate URL format and basic security checks.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to validate</p> required <code>url_type</code> <code>str</code> <p>Type of URL for error messages</p> <code>'URL'</code> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If URL is invalid</p>"},{"location":"api/keycloak_operator/#observability","title":"Observability","text":"<p>Prometheus metrics for the Keycloak operator.</p> <p>This module provides comprehensive metrics collection for monitoring operator performance, resource reconciliation, and system health.</p> <p>Health check utilities for the Keycloak operator.</p> <p>This module provides comprehensive health checking capabilities for monitoring operator and system component health.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector","title":"MetricsCollector","text":"<pre><code>MetricsCollector()\n</code></pre> <p>Collects and manages metrics for the Keycloak operator.</p> <p>Initialize metrics collector.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.authorization_failures","title":"authorization_failures  <code>property</code>","text":"<pre><code>authorization_failures\n</code></pre> <p>Counter for authorization failures.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.operational_tokens_active","title":"operational_tokens_active  <code>property</code>","text":"<pre><code>operational_tokens_active\n</code></pre> <p>Gauge for active operational tokens.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.token_expires","title":"token_expires  <code>property</code>","text":"<pre><code>token_expires\n</code></pre> <p>Gauge for token expiry timestamps.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.record_database_connection_test","title":"record_database_connection_test","text":"<pre><code>record_database_connection_test(\n    resource_name,\n    namespace,\n    database_type,\n    success,\n    duration,\n)\n</code></pre> <p>Record database connection test results.</p> <p>Parameters:</p> Name Type Description Default <code>resource_name</code> <code>str</code> <p>Name of the Keycloak resource</p> required <code>namespace</code> <code>str</code> <p>Namespace of the resource</p> required <code>database_type</code> <code>str</code> <p>Type of database</p> required <code>success</code> <code>bool</code> <p>Whether the connection test succeeded</p> required <code>duration</code> <code>float</code> <p>Time taken for the test</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.record_leader_election_change","title":"record_leader_election_change","text":"<pre><code>record_leader_election_change(\n    previous_leader, new_leader, namespace\n)\n</code></pre> <p>Record a leader election change event.</p> <p>Parameters:</p> Name Type Description Default <code>previous_leader</code> <code>str</code> <p>ID of the previous leader</p> required <code>new_leader</code> <code>str</code> <p>ID of the new leader</p> required <code>namespace</code> <code>str</code> <p>Namespace where the election occurred</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.record_lease_renewal","title":"record_lease_renewal","text":"<pre><code>record_lease_renewal(\n    instance_id, namespace, success, duration\n)\n</code></pre> <p>Record a leader election lease renewal attempt.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Unique identifier for this operator instance</p> required <code>namespace</code> <code>str</code> <p>Namespace where the operator is running</p> required <code>success</code> <code>bool</code> <p>Whether the lease renewal succeeded</p> required <code>duration</code> <code>float</code> <p>Time taken for the renewal operation</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.record_rbac_validation","title":"record_rbac_validation","text":"<pre><code>record_rbac_validation(\n    source_namespace, target_namespace, success\n)\n</code></pre> <p>Record RBAC validation attempt.</p> <p>Parameters:</p> Name Type Description Default <code>source_namespace</code> <code>str</code> <p>Source namespace of the operation</p> required <code>target_namespace</code> <code>str</code> <p>Target namespace of the operation</p> required <code>success</code> <code>bool</code> <p>Whether the validation succeeded</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.record_reconciliation_skip","title":"record_reconciliation_skip","text":"<pre><code>record_reconciliation_skip(resource_type, namespace, name)\n</code></pre> <p>Record a skipped reconciliation due to generation match.</p> <p>This is called when a resource is already reconciled at the current generation and in Ready state, avoiding redundant API calls.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>Type of resource (e.g., 'keycloak', 'realm', 'client')</p> required <code>namespace</code> <code>str</code> <p>Namespace of the resource</p> required <code>name</code> <code>str</code> <p>Name of the resource</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.track_reconciliation","title":"track_reconciliation  <code>async</code>","text":"<pre><code>track_reconciliation(\n    resource_type, namespace, name, operation=\"reconcile\"\n)\n</code></pre> <p>Context manager to track reconciliation operations.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>Type of resource being reconciled</p> required <code>namespace</code> <code>str</code> <p>Namespace of the resource</p> required <code>name</code> <code>str</code> <p>Name of the resource</p> required <code>operation</code> <code>str</code> <p>Type of operation being performed</p> <code>'reconcile'</code>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.update_cnpg_cluster_status","title":"update_cnpg_cluster_status","text":"<pre><code>update_cnpg_cluster_status(\n    cluster_name, namespace, healthy\n)\n</code></pre> <p>Update CloudNativePG cluster status.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_name</code> <code>str</code> <p>Name of the CNPG cluster</p> required <code>namespace</code> <code>str</code> <p>Namespace of the cluster</p> required <code>healthy</code> <code>bool</code> <p>Whether the cluster is healthy</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.update_keycloak_instance_status","title":"update_keycloak_instance_status","text":"<pre><code>update_keycloak_instance_status(\n    instance_name, namespace, running\n)\n</code></pre> <p>Update Keycloak instance status.</p> <p>Parameters:</p> Name Type Description Default <code>instance_name</code> <code>str</code> <p>Name of the Keycloak instance</p> required <code>namespace</code> <code>str</code> <p>Namespace of the instance</p> required <code>running</code> <code>bool</code> <p>Whether the instance is running</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.update_leader_election_status","title":"update_leader_election_status","text":"<pre><code>update_leader_election_status(\n    instance_id, namespace, is_leader\n)\n</code></pre> <p>Update leader election status.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Unique identifier for this operator instance</p> required <code>namespace</code> <code>str</code> <p>Namespace where the operator is running</p> required <code>is_leader</code> <code>bool</code> <p>Whether this instance is currently the leader</p> required"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsCollector.update_resource_status","title":"update_resource_status","text":"<pre><code>update_resource_status(\n    resource_type, namespace, phase, count=1\n)\n</code></pre> <p>Update the count of resources in a specific phase.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>Type of resource</p> required <code>namespace</code> <code>str</code> <p>Namespace of the resource</p> required <code>phase</code> <code>str</code> <p>Current phase of the resource</p> required <code>count</code> <code>int</code> <p>Number of resources (default: 1)</p> <code>1</code>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer","title":"MetricsServer","text":"<pre><code>MetricsServer(port=8081, host='0.0.0.0')\n</code></pre> <p>HTTP server for exposing Prometheus metrics.</p> <p>Initialize metrics server.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to serve metrics on</p> <code>8081</code> <code>host</code> <code>str</code> <p>Host interface to bind to</p> <code>'0.0.0.0'</code>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Async context manager entry.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc_val, exc_tb)\n</code></pre> <p>Async context manager exit.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer._health_handler","title":"_health_handler  <code>async</code>","text":"<pre><code>_health_handler(request)\n</code></pre> <p>Handle /health endpoint for operator health checks.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer._healthz_handler","title":"_healthz_handler  <code>async</code>","text":"<pre><code>_healthz_handler(request)\n</code></pre> <p>Handle /healthz endpoint for Kubernetes compatibility.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer._metrics_handler","title":"_metrics_handler  <code>async</code>","text":"<pre><code>_metrics_handler(request)\n</code></pre> <p>Handle /metrics endpoint for Prometheus scraping.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer._ready_handler","title":"_ready_handler  <code>async</code>","text":"<pre><code>_ready_handler(request)\n</code></pre> <p>Handle /ready endpoint for readiness probes.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer._setup_routes","title":"_setup_routes","text":"<pre><code>_setup_routes()\n</code></pre> <p>Set up HTTP routes for the metrics server.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the metrics server.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.MetricsServer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the metrics server.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.metrics.get_metrics_registry","title":"get_metrics_registry","text":"<pre><code>get_metrics_registry()\n</code></pre> <p>Get or create the global metrics registry.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthCheckResult","title":"HealthCheckResult  <code>dataclass</code>","text":"<pre><code>HealthCheckResult(\n    name,\n    status,\n    message,\n    details=None,\n    duration=0.0,\n    timestamp=0.0,\n)\n</code></pre> <p>Result of a health check operation.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker","title":"HealthChecker","text":"<pre><code>HealthChecker(k8s_client=None)\n</code></pre> <p>Performs comprehensive health checks for the operator.</p> <p>Initialize health checker.</p> <p>Parameters:</p> Name Type Description Default <code>k8s_client</code> <code>ApiClient | None</code> <p>Kubernetes API client</p> <code>None</code>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker._check_crds_installed","title":"_check_crds_installed  <code>async</code>","text":"<pre><code>_check_crds_installed()\n</code></pre> <p>Check if required CRDs are installed.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker._check_kubernetes_api","title":"_check_kubernetes_api  <code>async</code>","text":"<pre><code>_check_kubernetes_api()\n</code></pre> <p>Check Kubernetes API connectivity.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker._check_operator_resources","title":"_check_operator_resources  <code>async</code>","text":"<pre><code>_check_operator_resources()\n</code></pre> <p>Check operator's own resources (deployment, service account, etc.).</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker._check_rbac_permissions","title":"_check_rbac_permissions  <code>async</code>","text":"<pre><code>_check_rbac_permissions()\n</code></pre> <p>Check if the operator has required RBAC permissions.</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker.check_all","title":"check_all  <code>async</code>","text":"<pre><code>check_all()\n</code></pre> <p>Run all health checks.</p> <p>Returns:</p> Type Description <code>dict[str, HealthCheckResult]</code> <p>Dictionary of health check results</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker.get_overall_health","title":"get_overall_health","text":"<pre><code>get_overall_health(results)\n</code></pre> <p>Determine overall health status from individual check results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>dict[str, HealthCheckResult]</code> <p>Dictionary of health check results</p> required <p>Returns:</p> Type Description <code>str</code> <p>Overall health status</p>"},{"location":"api/keycloak_operator/#keycloak_operator.observability.health.HealthChecker.to_dict","title":"to_dict","text":"<pre><code>to_dict(results)\n</code></pre> <p>Convert health check results to dictionary format.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>dict[str, HealthCheckResult]</code> <p>Health check results</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation</p>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>This operator is structured into clear layers to keep reconciliation logic maintainable and testable.</p>"},{"location":"concepts/architecture/#high-level-components","title":"High-Level Components","text":"Layer Purpose CRDs / Models Pydantic models define the spec &amp; status of custom resources. Handlers Kopf handlers reacting to create/update/delete events. Services (Reconcilers) Idempotent business logic for converging desired -&gt; actual state. Utils Reusable helpers: Kubernetes API interactions, Keycloak admin client, validation. Observability Metrics, health endpoints, structured logging."},{"location":"concepts/architecture/#authorization-architecture","title":"Authorization Architecture","text":"<p>The operator uses Kubernetes RBAC combined with declarative namespace grant lists for multi-tenant authorization.</p>"},{"location":"concepts/architecture/#authorization-model","title":"Authorization Model","text":"<pre><code>graph TD\n    A[Kubernetes RBAC] --&gt;|Controls| B[Realm Creation]\n    C[Namespace Grant List] --&gt;|Controls| D[Client Creation]\n    B --&gt;|Realm Created| E[KeycloakRealm]\n    E --&gt;|Contains| F[clientAuthorizationGrants]\n    F --&gt;|Authorizes| D\n    D --&gt;|Client Created| G[KeycloakClient]\n\n    style A fill:#90ee90\n    style C fill:#87ceeb\n    style E fill:#ffd700\n    style G fill:#dda0dd</code></pre>"},{"location":"concepts/architecture/#two-level-authorization","title":"Two-Level Authorization","text":"Level Mechanism Controls Example Level 1: Realm Creation Kubernetes RBAC Who can create realms RoleBinding grants `create` on `KeycloakRealm` Level 2: Client Creation Namespace Grant List Which namespaces can create clients in a realm Realm's `spec.clientAuthorizationGrants`"},{"location":"concepts/architecture/#realm-creation-authorization","title":"Realm Creation Authorization","text":"<p>Controlled by: Standard Kubernetes RBAC</p> <p>Any user/ServiceAccount with permission to create `KeycloakRealm` resources in a namespace can create realms:</p> <p>```yaml apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata:   name: realm-manager   namespace: my-app rules:   - apiGroups: [\"vriesdemichael.github.io\"]     resources: [\"keycloakrealms\"]     verbs: [\"create\", \"update\", \"patch\", \"delete\"] ```</p> <p>Benefits: - Native Kubernetes authorization - Integrates with existing RBAC/SSO - GitOps-friendly (ArgoCD ServiceAccounts) - Auditable via Kubernetes audit logs</p>"},{"location":"concepts/architecture/#client-creation-authorization","title":"Client Creation Authorization","text":"<p>Controlled by: Realm's `clientAuthorizationGrants` field</p> <p>Only namespaces explicitly listed in a realm's grant list can create clients in that realm:</p> <p>```yaml apiVersion: vriesdemichael.github.io/v1 kind: KeycloakRealm metadata:   name: shared-realm   namespace: platform spec:   realmName: shared   instanceRef:     name: keycloak     namespace: keycloak-system   # Only these namespaces can create clients   clientAuthorizationGrants:     - platform      # Same namespace     - app-team-a    # Cross-namespace     - app-team-b    # Cross-namespace ```</p> <p>Authorization Flow:</p> <ol> <li>User creates `KeycloakClient` in namespace `app-team-a`</li> <li>Operator reads client's `realmRef` to find realm</li> <li>Operator checks if `app-team-a` is in realm's `clientAuthorizationGrants`</li> <li>If authorized: Client created in Keycloak</li> <li>If not authorized: Client enters `Error` phase with clear message</li> </ol> <p>Example: Client in authorized namespace</p> <p>```yaml apiVersion: vriesdemichael.github.io/v1 kind: KeycloakClient metadata:   name: my-client   namespace: app-team-a  # Must be in realm's grant list spec:   clientId: my-app   realmRef:     name: shared-realm     namespace: platform   publicClient: false ```</p>"},{"location":"concepts/architecture/#security-considerations","title":"Security Considerations","text":"<ul> <li>Namespace Isolation: Client credentials only exist in client's namespace</li> <li>Least Privilege: Realm owners control which namespaces can create clients</li> <li>Revocation: Remove namespace from grant list to prevent new clients</li> <li>Audit Trail: All authorization changes tracked in Git and Kubernetes audit logs</li> <li>No Secrets in Git: Authorization is declarative (namespace names), not secret-based</li> </ul> <p>See Security Model for detailed authorization architecture and best practices.</p>"},{"location":"concepts/architecture/#reconciliation-flow","title":"Reconciliation Flow","text":"<p>The operator follows a consistent reconciliation pattern for all custom resources:</p> <pre><code>flowchart TD\n    A[Kubernetes Event&lt;br/&gt;create/update/delete] --&gt; B[Kopf Handler&lt;br/&gt;handlers/*.py]\n    B --&gt; C{Validate Input}\n    C --&gt;|Invalid| D[Update Status: Failed&lt;br/&gt;Emit Event]\n    C --&gt;|Valid| E[Reconciler Service&lt;br/&gt;services/*_reconciler.py]\n\n    E --&gt; F[Load Current State]\n    F --&gt; G[From Keycloak API]\n    F --&gt; H[From Kubernetes API]\n\n    G --&gt; I{Compute Diff}\n    H --&gt; I\n\n    I --&gt; J{Changes Needed?}\n    J --&gt;|No| K[Update Status: Ready&lt;br/&gt;No action needed]\n    J --&gt;|Yes| L[Apply Changes]\n\n    L --&gt; M{Create}\n    L --&gt; N{Update}\n    L --&gt; O{Delete}\n\n    M --&gt; P[Keycloak Admin API&lt;br/&gt;POST /realms]\n    N --&gt; Q[Keycloak Admin API&lt;br/&gt;PUT /realms/name]\n    O --&gt; R[Keycloak Admin API&lt;br/&gt;DELETE /realms/name]\n\n    P --&gt; S[Update CR Status]\n    Q --&gt; S\n    R --&gt; S\n\n    S --&gt; T{Success?}\n    T --&gt;|Yes| U[Status: Ready&lt;br/&gt;Emit Success Event&lt;br/&gt;Record Metrics]\n    T --&gt;|No| V[Status: Failed&lt;br/&gt;Emit Error Event&lt;br/&gt;Record Metrics&lt;br/&gt;Retry with backoff]\n\n    D --&gt; W[End]\n    K --&gt; W\n    U --&gt; W\n    V --&gt; W\n\n    style A fill:#e1f5ff\n    style B fill:#fff4e1\n    style E fill:#e8f5e9\n    style I fill:#f3e5f5\n    style S fill:#fff3e0\n    style U fill:#c8e6c9\n    style V fill:#ffcdd2</code></pre> <p>Reconciliation Steps:</p> <ol> <li>Event Reception: Kubernetes emits event for custom resource (create/update/delete)</li> <li>Handler Invocation: Kopf invokes registered handler (<code>handlers/realm.py</code>, etc.)</li> <li>Input Validation: Handler validates spec fields and authorization</li> <li>Delegation: Handler delegates to reconciler service (<code>services/realm_reconciler.py</code>)</li> <li>State Loading: Reconciler loads current state from Keycloak and Kubernetes APIs</li> <li>Diff Computation: Compare desired spec with actual state</li> <li>Change Application: Apply required create/update/delete operations via Keycloak Admin API</li> <li>Status Update: Update custom resource status field (Ready/Failed)</li> <li>Observability: Emit metrics, logs, and Kubernetes events</li> </ol> <p>Key Principles:</p> <ul> <li>Idempotent: Reconciler can be called multiple times with same input</li> <li>Thin Handlers: Handlers contain minimal logic, delegate to services</li> <li>Thick Services: Reconcilers contain all business logic</li> <li>State-Based: Always compare current state vs desired state (not event-based)</li> <li>Error Recovery: Failed reconciliations retry with exponential backoff</li> </ul>"},{"location":"concepts/architecture/#key-modules","title":"Key Modules","text":"<ul> <li><code>models/</code> define <code>Keycloak</code>, <code>KeycloakRealm</code>, <code>KeycloakClient</code> domain schemas.</li> <li><code>handlers/</code> contain Kopf decorated async functions with minimal logic.</li> <li><code>services/</code> hold reconcilers orchestrating API calls &amp; ensuring idempotency.</li> <li><code>utils/keycloak_admin.py</code> wraps Keycloak REST admin endpoints.</li> <li><code>observability/metrics.py</code> defines Prometheus collectors.</li> </ul>"},{"location":"concepts/architecture/#error-handling","title":"Error Handling","text":"<p>Custom exceptions in <code>errors/operator_errors.py</code> categorize recoverable vs fatal failures. Handlers catch and translate them to appropriate Kubernetes events/logs.</p>"},{"location":"concepts/architecture/#scaling-strategy","title":"Scaling Strategy","text":"<p>When considering scaling in a Keycloak deployment managed by this operator, it's critical to understand that there are two distinct types of scaling, each serving different purposes and having different performance characteristics.</p>"},{"location":"concepts/architecture/#two-types-of-scaling","title":"Two Types of Scaling","text":""},{"location":"concepts/architecture/#1-operator-scaling-reconciliation","title":"1. Operator Scaling (Reconciliation)","text":"<p>The operator itself performs reconciliation actions: - Watches Keycloak custom resources - Reconciles desired state with actual state - Makes Admin API calls to configure Keycloak - Manages Kubernetes resources</p> <p>Key Point: Operator scaling is rarely the bottleneck.</p>"},{"location":"concepts/architecture/#2-keycloak-instance-scaling-end-user-traffic","title":"2. Keycloak Instance Scaling (End-User Traffic)","text":"<p>The Keycloak instance handles: - End-user authentication and authorization requests - Session management - Token generation and validation - User database queries - Admin API calls (triggered by operator or administrators)</p> <p>Key Point: This is where you will hit performance limits first.</p>"},{"location":"concepts/architecture/#where-bottlenecks-occur","title":"Where Bottlenecks Occur","text":"<p>In virtually all real-world scenarios, you will hit Keycloak instance limitations before operator limitations, even after vertically scaling both components to their maximum capacity.</p> <p>The operator's workload (reconciliation loops and occasional Admin API calls) is minimal compared to the Keycloak instance's workload (continuous authentication/authorization requests from thousands or millions of end users).</p>"},{"location":"concepts/architecture/#when-to-scale-what","title":"When to Scale What","text":"<p>If you're experiencing performance issues:</p> <ol> <li>First, scale the Keycloak instance itself:</li> <li>Increase replicas for horizontal scaling</li> <li>Add database read replicas</li> <li>Optimize caching configuration</li> <li> <p>Review realm and client configuration for performance</p> </li> <li> <p>Only consider operator scaling if:</p> </li> <li>You have an extremely high rate of realm/client configuration changes</li> <li>Reconciliation loops are measurably slow</li> <li>You can verify that the operator is the actual bottleneck (use metrics/profiling)</li> </ol>"},{"location":"concepts/architecture/#multi-operator-deployment-pattern","title":"Multi-Operator Deployment Pattern","text":"<p>If you genuinely need more operator capacity (or want to isolate workloads), this operator supports running multiple instances side-by-side in the same cluster.</p> <p>Each realm can target a specific operator instance using the <code>operatorRef</code> field. This allows you to:</p> <ul> <li>Distribute realm management across multiple operators</li> <li>Isolate different teams or environments to different operators</li> <li>Scale operator capacity horizontally when needed</li> </ul> <pre><code>graph TB\n    subgraph Cluster[\"Kubernetes Cluster\"]\n        subgraph OpNS1[\"keycloak-system-prod\"]\n            Op1[Operator Instance: prod]\n            KC1[Keycloak Instance: prod]\n        end\n\n        subgraph OpNS2[\"keycloak-system-dev\"]\n            Op2[Operator Instance: dev]\n            KC2[Keycloak Instance: dev]\n        end\n\n        subgraph TeamA[\"Namespace: team-a\"]\n            RealmA1[Realm: team-a-prod]\n            RealmA2[Realm: team-a-dev]\n            TokenA1[Token: prod-admission]\n            TokenA2[Token: dev-admission]\n        end\n\n        subgraph TeamB[\"Namespace: team-b\"]\n            RealmB1[Realm: team-b-prod]\n            RealmB2[Realm: team-b-dev]\n            TokenB1[Token: prod-admission]\n            TokenB2[Token: dev-admission]\n        end\n    end\n\n    RealmA1 --&gt;|operatorRef: keycloak-system-prod| Op1\n    RealmA1 --&gt;|authRef: prod-admission| TokenA1\n    Op1 --&gt;|Reconcile| KC1\n\n    RealmA2 --&gt;|operatorRef: keycloak-system-dev| Op2\n    RealmA2 --&gt;|authRef: dev-admission| TokenA2\n    Op2 --&gt;|Reconcile| KC2\n\n    RealmB1 --&gt;|operatorRef: keycloak-system-prod| Op1\n    RealmB1 --&gt;|authRef: prod-admission| TokenB1\n\n    RealmB2 --&gt;|operatorRef: keycloak-system-dev| Op2\n    RealmB2 --&gt;|authRef: dev-admission| TokenB2\n\n    style Op1 fill:#e3f2fd\n    style Op2 fill:#f3e5f5\n    style KC1 fill:#e1f5fe\n    style KC2 fill:#f8bbd0\n    style RealmA1 fill:#c8e6c9\n    style RealmA2 fill:#fff9c4\n    style RealmB1 fill:#c8e6c9\n    style RealmB2 fill:#fff9c4</code></pre> <p>Key Benefits of Multi-Operator Pattern:</p> <ul> <li>Workload Isolation: Production and development operators are completely independent</li> <li>Blast Radius Reduction: Issues with dev operator don't affect production realms</li> <li>Independent Scaling: Each operator can be sized according to its workload</li> <li>Team Autonomy: Teams can target different operators based on environment</li> <li>Upgrade Safety: Test operator upgrades in dev before rolling to production</li> </ul> <p>Example configuration:</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-system\n  # ... rest of realm config\n</code></pre> <p>When to use multiple operators:</p> <ul> <li>Large number of realms with frequent configuration changes</li> <li>Workload isolation (e.g., production vs non-production)</li> <li>Geographic distribution across regions/clusters</li> <li>Huge monolithic realms that cannot be subdivided</li> </ul> <p>When NOT to use multiple operators:</p> <ul> <li>To improve end-user authentication performance (scale Keycloak instead)</li> <li>As a first resort (vertical scaling is usually sufficient)</li> <li>Without measuring (verify the operator is actually your bottleneck)</li> </ul>"},{"location":"concepts/architecture/#recommended-approach","title":"Recommended Approach","text":"<p>For most use cases:</p> <ol> <li>Start with a single operator instance with reasonable resource limits</li> <li>Scale your Keycloak instances to meet end-user authentication demands</li> <li>Monitor operator performance using available metrics</li> <li>Only deploy additional operators when you can demonstrate that reconciliation performance is actually limiting your operations</li> </ol>"},{"location":"concepts/architecture/#common-misconception","title":"Common Misconception","text":"<p>\"Python operators don't scale as well as Go operators, so I need multiple instances.\"</p> <p>Reality: For this workload, the language choice has minimal impact. The operator spends most of its time waiting for Kubernetes API responses and Keycloak Admin API calls, not doing CPU-intensive work. A single Python-based operator can easily manage dozens of realms without performance degradation.</p> <p>The scaling strategy should be driven by actual performance metrics and requirements, not by assumptions about implementation language.</p>"},{"location":"concepts/architecture/#rate-limiting-architecture","title":"Rate Limiting Architecture","text":"<p>The operator implements a three-layer rate limiting strategy to protect Keycloak instances from API overload, particularly during mass reconciliation events (operator restarts, database reconnections, or intentional/malicious resource spam).</p> <pre><code>flowchart TB\n    subgraph Reconciliation[\"Reconciliation Request Flow\"]\n        Event[Kubernetes Event&lt;br/&gt;create/update/delete]\n        Jitter[Layer 3: Jitter&lt;br/&gt;Random delay 0-5s&lt;br/&gt;Prevents thundering herd]\n        NSLimit[Layer 2: Namespace Limiter&lt;br/&gt;5 req/s per namespace&lt;br/&gt;Fair allocation]\n        GlobalLimit[Layer 1: Global Limiter&lt;br/&gt;50 req/s cluster-wide&lt;br/&gt;Total protection]\n        API[Keycloak Admin API]\n    end\n\n    subgraph Limits[\"Token Bucket Rate Limiters\"]\n        subgraph Global[\"Global Bucket\"]\n            GT[Tokens: 50/sec&lt;br/&gt;Burst: 100]\n        end\n\n        subgraph NS1[\"Namespace: team-a\"]\n            NS1T[Tokens: 5/sec&lt;br/&gt;Burst: 10]\n        end\n\n        subgraph NS2[\"Namespace: team-b\"]\n            NS2T[Tokens: 5/sec&lt;br/&gt;Burst: 10]\n        end\n\n        subgraph NS3[\"Namespace: team-c\"]\n            NS3T[Tokens: 5/sec&lt;br/&gt;Burst: 10]\n        end\n    end\n\n    Event --&gt; Jitter\n    Jitter --&gt; NSLimit\n    NSLimit --&gt; NS1T\n    NSLimit --&gt; NS2T\n    NSLimit --&gt; NS3T\n\n    NS1T --&gt; GlobalLimit\n    NS2T --&gt; GlobalLimit\n    NS3T --&gt; GlobalLimit\n\n    GlobalLimit --&gt; GT\n    GT --&gt; API\n\n    style Event fill:#e1f5ff\n    style Jitter fill:#fff9c4\n    style NSLimit fill:#f3e5f5\n    style GlobalLimit fill:#ffccbc\n    style API fill:#c8e6c9\n    style GT fill:#ffab91\n    style NS1T fill:#ce93d8\n    style NS2T fill:#ce93d8\n    style NS3T fill:#ce93d8</code></pre>"},{"location":"concepts/architecture/#rate-limiting-layers-explained","title":"Rate Limiting Layers Explained","text":""},{"location":"concepts/architecture/#layer-3-jitter-reconciliation-start","title":"Layer 3: Jitter (Reconciliation Start)","text":"<ul> <li>Purpose: Prevent \"thundering herd\" when operator restarts with 100+ resources</li> <li>Implementation: Random delay (0-5 seconds) before reconciliation starts</li> <li>Configuration: <code>RECONCILE_JITTER_MAX_SECONDS</code> (default: 5.0)</li> <li>Effect: Spreads reconciliation across time window instead of all at once</li> </ul>"},{"location":"concepts/architecture/#layer-2-per-namespace-rate-limiting","title":"Layer 2: Per-Namespace Rate Limiting","text":"<ul> <li>Purpose: Fair resource allocation across teams/namespaces</li> <li>Implementation: Token bucket algorithm, one bucket per namespace</li> <li>Configuration: <code>KEYCLOAK_API_NAMESPACE_RATE_LIMIT_TPS</code> (default: 5 req/s)</li> <li>Burst Capacity: <code>KEYCLOAK_API_NAMESPACE_BURST</code> (default: 10)</li> <li>Effect: Prevents one team from monopolizing API capacity</li> </ul> <p>Example: If <code>team-a</code> creates 1000 realms: - Rate limited to 5 req/s = 200 seconds minimum - Other teams' realms still reconcile at their namespace rate limits - No team can starve others of API capacity</p>"},{"location":"concepts/architecture/#layer-1-global-rate-limiting","title":"Layer 1: Global Rate Limiting","text":"<ul> <li>Purpose: Absolute protection of Keycloak instance from overload</li> <li>Implementation: Token bucket algorithm, shared across all namespaces</li> <li>Configuration: <code>KEYCLOAK_API_GLOBAL_RATE_LIMIT_TPS</code> (default: 50 req/s)</li> <li>Burst Capacity: <code>KEYCLOAK_API_GLOBAL_BURST</code> (default: 100)</li> <li>Effect: Hard cap on total API requests across entire cluster</li> </ul> <p>Example: With 20 teams each creating 100 realms: - Namespace limits allow each team 5 req/s (total theoretical: 100 req/s) - Global limit enforces actual maximum of 50 req/s - Teams fairly share the 50 req/s capacity</p>"},{"location":"concepts/architecture/#protection-scenarios","title":"Protection Scenarios","text":"Scenario Protection Mechanism Result Operator restart (50 resources) Jitter spreads starts over 5s Smooth reconciliation, not instant spike Database reconnection (100 resources) Jitter + namespace limits Controlled recovery, API not overwhelmed Malicious spam (1000 realms in one namespace) Namespace limit (5 req/s) 200 seconds minimum, other teams unaffected 20 teams creating resources simultaneously Global limit (50 req/s) Fair sharing, no single team monopolizes"},{"location":"concepts/architecture/#configuration-example","title":"Configuration Example","text":"<pre><code># Operator deployment configuration\nenv:\n  # Layer 1: Global limit (protect Keycloak)\n  - name: KEYCLOAK_API_GLOBAL_RATE_LIMIT_TPS\n    value: \"50\"\n  - name: KEYCLOAK_API_GLOBAL_BURST\n    value: \"100\"\n\n  # Layer 2: Namespace limits (fair allocation)\n  - name: KEYCLOAK_API_NAMESPACE_RATE_LIMIT_TPS\n    value: \"5\"\n  - name: KEYCLOAK_API_NAMESPACE_BURST\n    value: \"10\"\n\n  # Layer 3: Jitter (thundering herd prevention)\n  - name: RECONCILE_JITTER_MAX_SECONDS\n    value: \"5.0\"\n</code></pre>"},{"location":"concepts/architecture/#monitoring-rate-limiting","title":"Monitoring Rate Limiting","text":"<p>The operator exposes Prometheus metrics for rate limiting (when implemented):</p> <ul> <li><code>keycloak_operator_rate_limit_wait_seconds</code>: Time spent waiting for rate limit tokens</li> <li><code>keycloak_operator_rate_limit_denied_total</code>: Number of requests denied (should be 0)</li> <li><code>keycloak_operator_rate_limit_tokens_available</code>: Current token bucket levels</li> </ul> <p>See Observability for complete metrics documentation.</p>"},{"location":"concepts/architecture/#future-enhancements","title":"Future Enhancements","text":"<ul> <li>Finalizers for deterministic teardown</li> <li>Smarter diffing of realm/client sub-resources</li> <li>Rate limiting &amp; backoff policies</li> <li>Pluggable auth strategies for Keycloak admin API</li> </ul>"},{"location":"concepts/architecture/#see-also","title":"See Also","text":"<p>Core Architecture:</p> <ul> <li>Security Model - Token system security architecture and authorization model</li> <li>Observability - Metrics, health checks, and monitoring</li> <li>Development Guide - Code structure and development workflow</li> </ul> <p>Operational Guides:</p> <ul> <li>Security Model - Authorization and access control</li> <li>Troubleshooting - Debugging common issues</li> <li>High Availability Deployment - Production deployment patterns</li> </ul> <p>Quickstart:</p> <ul> <li>Getting Started - Deploy your first Keycloak realm</li> <li>End-to-End Setup - Complete production deployment</li> </ul> <p>API Reference:</p> <ul> <li>Keycloak CRD - Keycloak instance configuration</li> <li>KeycloakRealm CRD - Realm configuration</li> <li>KeycloakClient CRD - Client configuration</li> </ul> <p>Return to the index or continue with the development guide.</p>"},{"location":"concepts/security/","title":"Security Model","text":"<p>This document explains the security and authorization model of the Keycloak operator.</p>"},{"location":"concepts/security/#overview","title":"Overview","text":"<p>The Keycloak operator uses Kubernetes RBAC combined with declarative namespace grant lists for authorization.</p>"},{"location":"concepts/security/#design-philosophy","title":"Design Philosophy","text":"<p>Key principle: Application teams should manage their own Keycloak realms and clients without requiring platform team intervention for each resource. This is the \"Realm-as-Tenant\" model.</p>"},{"location":"concepts/security/#roles-responsibilities","title":"Roles &amp; Responsibilities","text":"<p>The security model is designed to support distinct roles (Platform Team, Realm Owner, Client Owner). For a detailed breakdown of who is responsible for what, see the Team Responsibilities Matrix.</p>"},{"location":"concepts/security/#why-not-traditional-rbac-alone","title":"Why Not Traditional RBAC Alone?","text":"<p>Pure RBAC approaches don't scale for multi-tenant Keycloak: - \u274c Can't express \"team A can create clients in realm X but not realm Y\" - \u274c Adding teams requires updating cluster-wide RBAC - \u274c Cross-namespace authorization requires complex RoleBinding hierarchies - \u274c Doesn't support GitOps workflows well</p>"},{"location":"concepts/security/#why-not-tokens","title":"Why Not Tokens?","text":"<p>Token-based systems (like this operator previously used) create operational overhead: - \u274c Token generation, distribution, and rotation lifecycle - \u274c Manual secret syncing between namespaces - \u274c Not GitOps-native (secrets don't belong in Git) - \u274c Complexity increases with team churn</p>"},{"location":"concepts/security/#the-solution-rbac-namespace-grants","title":"The Solution: RBAC + Namespace Grants","text":"<p>The operator combines Kubernetes RBAC with declarative namespace authorization: - \u2705 Realm Creation: Controlled by Kubernetes RBAC. - \u2705 Client Creation: Controlled by realm's <code>clientAuthorizationGrants</code> list - \u2705 Fully Declarative: All authorization in Git-committable manifests - \u2705 Self-Service: Teams can grant access via PR workflow - \u2705 Clear Audit Trail: Git history shows all authorization changes</p>"},{"location":"concepts/security/#authorization-model","title":"Authorization Model","text":""},{"location":"concepts/security/#level-1-realm-creation","title":"Level 1: Realm Creation","text":"<p>Who controls it: Kubernetes RBAC</p> <p>Any user with permission to create <code>KeycloakRealm</code> resources in a namespace can create realms.</p> <p>Example: Grant realm creation permission</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: realm-manager\n  namespace: my-app\nrules:\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakrealms\"]\n    verbs: [\"create\", \"update\", \"patch\", \"delete\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: team-realm-managers\n  namespace: my-app\nsubjects:\n  - kind: ServiceAccount\n    name: argocd-app-controller\n    namespace: argocd\n  - kind: Group\n    name: my-app-team\n    apiGroup: rbac.authorization.k8s.io\nroleRef:\n  kind: Role\n  name: realm-manager\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>Best Practices: - Use namespace-scoped Roles (not ClusterRoles) for realm management - Grant to ServiceAccounts for GitOps tools (ArgoCD, Flux) - Use Groups to manage team access</p>"},{"location":"concepts/security/#level-2-client-creation","title":"Level 2: Client Creation","text":"<p>Who controls it: Realm owner via <code>clientAuthorizationGrants</code></p> <p>Clients require explicit namespace authorization from the realm. Only namespaces listed in <code>clientAuthorizationGrants</code> can create clients in that realm.</p> <p>Example: Realm with client authorization</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-app\n  instanceRef:\n    name: keycloak\n    namespace: keycloak-system\n  # Grant these namespaces permission to create clients\n  clientAuthorizationGrants:\n    - my-app              # Same namespace (common)\n    - my-app-staging      # Staging environment\n    - partner-app         # External team integration\n</code></pre> <p>Authorization Check:</p> <p>When a <code>KeycloakClient</code> resource is created:</p> <ol> <li>Operator reads the client's <code>realmRef</code> to find the realm</li> <li>Operator reads the realm's <code>spec.clientAuthorizationGrants</code></li> <li>Operator checks if client's namespace is in the grant list</li> <li>If not authorized: Client enters <code>Error</code> phase with clear message</li> <li>If authorized: Client is created in Keycloak</li> </ol> <p>Example: Client in authorized namespace</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: my-client\n  namespace: my-app  # \u2190 This namespace must be in realm's grants\nspec:\n  clientId: my-app\n  realmRef:\n    name: my-realm\n    namespace: my-app\n  publicClient: false\n  standardFlowEnabled: true\n</code></pre> <p>Status when unauthorized:</p> <pre><code>status:\n  phase: Error\n  conditions:\n    - type: Ready\n      status: \"False\"\n      reason: NamespaceNotAuthorized\n      message: \"Namespace 'my-app' is not authorized to create clients in realm 'my-realm'. Add 'my-app' to realm's clientAuthorizationGrants.\"\n</code></pre>"},{"location":"concepts/security/#namespace-authorization-workflow","title":"Namespace Authorization Workflow","text":"<p>Scenario: Team B wants to create a client in Team A's realm</p> <ol> <li> <p>Team B creates PR updating Team A's realm manifest:    <pre><code>clientAuthorizationGrants:\n  - team-a\n  - team-b  # \u2190 Add this line\n</code></pre></p> </li> <li> <p>Team A reviews PR:</p> </li> <li>Reviews which resources Team B will create</li> <li>Checks security implications</li> <li> <p>Approves or requests changes</p> </li> <li> <p>PR merged: ArgoCD/Flux applies the change</p> </li> <li> <p>Team B can create client: Operator allows client creation</p> </li> </ol> <p>Benefits: - \u2705 Clear approval trail in Git history - \u2705 Standard PR workflow (no special tools) - \u2705 Team A retains full control - \u2705 Reversible (remove from grant list)</p>"},{"location":"concepts/security/#security-properties","title":"Security Properties","text":""},{"location":"concepts/security/#namespace-isolation","title":"Namespace Isolation","text":"<ul> <li>No cross-namespace secrets: Client credentials only in client's namespace</li> <li>Realm secrets isolated: Each realm's secrets only in realm's namespace</li> <li>Operator service account: Has cluster-wide read for authorization checks</li> </ul>"},{"location":"concepts/security/#least-privilege","title":"Least Privilege","text":"<ul> <li>Realm creators: Only need RBAC in their namespace</li> <li>Client creators: Only need namespace in grant list</li> <li>Operator: Runs with minimal RBAC (see ADR 032)</li> </ul>"},{"location":"concepts/security/#revocation","title":"Revocation","text":"<p>Removing client access:</p> <p>Update realm's <code>clientAuthorizationGrants</code> to remove namespace:</p> <pre><code>kubectl patch keycloakrealm my-realm -n my-app --type=merge -p '\nspec:\n  clientAuthorizationGrants:\n    - my-app\n    # team-b removed\n'\n</code></pre> <p>Effect: - \u2705 Existing clients continue to work (by design) - \u2705 New client creation from <code>team-b</code> namespace fails - \u2705 Updates to existing clients from <code>team-b</code> fail</p> <p>To fully revoke: Delete the client CR from <code>team-b</code> namespace</p>"},{"location":"concepts/security/#audit-trail","title":"Audit Trail","text":"<p>All authorization changes are auditable:</p> <p>Via Kubernetes audit logs: <pre><code># Who created/modified the realm grant list?\nkubectl get events --field-selector involvedObject.name=my-realm -n my-app\n\n# Audit log query (if enabled)\ngrep \"keycloakrealm\" /var/log/kubernetes/audit/audit.log | grep clientAuthorizationGrants\n</code></pre></p> <p>Via Git history: <pre><code># Who added team-b to grant list?\ngit log -p -- realms/my-realm.yaml | grep clientAuthorizationGrants\n</code></pre></p>"},{"location":"concepts/security/#rbac-configuration","title":"RBAC Configuration","text":""},{"location":"concepts/security/#operator-service-account","title":"Operator Service Account","text":"<p>The operator needs these cluster-wide permissions:</p> <p>Read access for authorization checks: <pre><code>- apiGroups: [\"vriesdemichael.github.io\"]\n  resources: [\"keycloakrealms\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n</code></pre></p> <p>Write access for status updates: <pre><code>- apiGroups: [\"vriesdemichael.github.io\"]\n  resources: [\"keycloakrealms/status\", \"keycloakclients/status\"]\n  verbs: [\"update\", \"patch\"]\n</code></pre></p> <p>Secret access (read-only): <pre><code>- apiGroups: [\"\"]\n  resources: [\"secrets\"]\n  verbs: [\"get\", \"list\"]\n</code></pre></p> <p>See ADR 032 for complete RBAC design.</p>"},{"location":"concepts/security/#application-team-rbac","title":"Application Team RBAC","text":"<p>Minimal permissions for realm management:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: keycloak-realm-manager\n  namespace: my-app\nrules:\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakrealms\"]\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"]\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakclients\"]\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"]\n</code></pre> <p>For GitOps (ArgoCD/Flux):</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: argocd-keycloak-manager\n  namespace: my-app\nsubjects:\n  - kind: ServiceAccount\n    name: argocd-application-controller\n    namespace: argocd\nroleRef:\n  kind: Role\n  name: keycloak-realm-manager\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"concepts/security/#common-patterns","title":"Common Patterns","text":""},{"location":"concepts/security/#single-namespace-application","title":"Single-Namespace Application","text":"<p>Scenario: App team manages realm and clients in same namespace</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  clientAuthorizationGrants:\n    - my-app  # Same namespace\n</code></pre> <p>Benefits: - Simple authorization (self-authorization) - All resources co-located - Easy to manage via GitOps</p>"},{"location":"concepts/security/#multi-environment-setup","title":"Multi-Environment Setup","text":"<p>Scenario: Shared realm across dev/staging/prod</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: shared-realm\n  namespace: identity-platform\nspec:\n  clientAuthorizationGrants:\n    - my-app-dev\n    - my-app-staging\n    - my-app-prod\n</code></pre> <p>Benefits: - Centralized realm management - Each environment has isolated clients - Platform team controls realm, app teams control clients</p>"},{"location":"concepts/security/#partner-integration","title":"Partner Integration","text":"<p>Scenario: External partner needs OAuth2 client</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: api-realm\n  namespace: api-platform\nspec:\n  clientAuthorizationGrants:\n    - api-platform        # Internal clients\n    - partner-acme-corp   # Partner's namespace\n    - partner-globex      # Another partner\n</code></pre> <p>Workflow: 1. Platform team creates namespace: <code>partner-acme-corp</code> 2. Platform team adds to grant list via PR 3. Platform team gives partner RBAC in their namespace 4. Partner creates client via GitOps or kubectl</p>"},{"location":"concepts/security/#temporary-access","title":"Temporary Access","text":"<p>Scenario: Grant temporary access for testing</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\n  annotations:\n    grant-expires: \"2025-12-31\"\n    grant-reason: \"Q4 integration testing\"\nspec:\n  clientAuthorizationGrants:\n    - my-app\n    - test-team  # Temporary grant\n</code></pre> <p>Cleanup: - Set calendar reminder for expiration date - Remove from grant list after testing complete - Document in Git commit message</p>"},{"location":"concepts/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"concepts/security/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<p>Do: - \u2705 Grant namespace access only when needed - \u2705 Use namespace-scoped Roles instead of ClusterRoles - \u2705 Regularly audit <code>clientAuthorizationGrants</code> lists - \u2705 Document why each namespace is granted access</p> <p>Don't: - \u274c Add wildcard namespace grants (not supported) - \u274c Grant access \"just in case\" - \u274c Leave expired grants in place</p>"},{"location":"concepts/security/#realm-ownership","title":"Realm Ownership","text":"<p>Clear ownership model: - One team owns each realm - Owner team controls <code>clientAuthorizationGrants</code> - Owner team reviews PRs adding new namespaces - Owner team monitors client creation</p> <p>Example ownership annotation:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\n  labels:\n    owner-team: platform-team\n    contact: platform-team@company.com\nspec:\n  clientAuthorizationGrants: [...]\n</code></pre>"},{"location":"concepts/security/#gitops-integration","title":"GitOps Integration","text":"<p>Recommended structure:</p> <pre><code>%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#00b8d9','primaryTextColor':'#fff','primaryBorderColor':'#0097a7','lineColor':'#00acc1','secondaryColor':'#006064','tertiaryColor':'#fff'}}}%%\ngraph TB\n    root[\"\ud83d\udcc1 repos/\"]\n\n    infra[\"\ud83d\udcc1 infrastructure/\"]\n    infra_kc[\"\ud83d\udcc1 keycloak/\"]\n    operator[\"\ud83d\udcc4 operator.yaml&lt;br/&gt;&lt;small&gt;Operator + instance&lt;/small&gt;\"]\n    realms[\"\ud83d\udcc1 realms/\"]\n    api_realm[\"\ud83d\udcc4 api-realm.yaml&lt;br/&gt;&lt;small&gt;Platform-managed&lt;/small&gt;\"]\n    auth_realm[\"\ud83d\udcc4 auth-realm.yaml&lt;br/&gt;&lt;small&gt;Platform-managed&lt;/small&gt;\"]\n\n    apps[\"\ud83d\udcc1 applications/\"]\n    app_a[\"\ud83d\udcc1 app-a/\"]\n    client_a[\"\ud83d\udcc4 keycloak-client.yaml&lt;br/&gt;&lt;small&gt;App-managed clients&lt;/small&gt;\"]\n    app_b[\"\ud83d\udcc1 app-b/\"]\n    client_b[\"\ud83d\udcc4 keycloak-client.yaml&lt;br/&gt;&lt;small&gt;App-managed clients&lt;/small&gt;\"]\n\n    root --&gt; infra\n    root --&gt; apps\n\n    infra --&gt; infra_kc\n    infra_kc --&gt; operator\n    infra_kc --&gt; realms\n    realms --&gt; api_realm\n    realms --&gt; auth_realm\n\n    apps --&gt; app_a\n    apps --&gt; app_b\n    app_a --&gt; client_a\n    app_b --&gt; client_b\n\n    style root fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style infra fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style infra_kc fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style realms fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style apps fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style app_a fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style app_b fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style operator fill:#00838f,stroke:#006064,color:#fff\n    style api_realm fill:#00838f,stroke:#006064,color:#fff\n    style auth_realm fill:#00838f,stroke:#006064,color:#fff\n    style client_a fill:#00838f,stroke:#006064,color:#fff\n    style client_b fill:#00838f,stroke:#006064,color:#fff</code></pre> <p>Benefits: - Clear separation of concerns - Realm authorization changes go through platform repo PRs - Application teams manage own clients in app repos</p>"},{"location":"concepts/security/#monitoring-and-alerts","title":"Monitoring and Alerts","text":"<p>Metrics to monitor: - Client creation failures due to authorization - Namespaces added/removed from grant lists - Client creation rate per namespace</p> <p>Example Prometheus alert:</p> <pre><code>groups:\n  - name: keycloak-operator\n    rules:\n      - alert: UnauthorizedClientCreationAttempts\n        expr: |\n          increase(keycloak_client_reconciliation_errors{\n            reason=\"NamespaceNotAuthorized\"\n          }[5m]) &gt; 5\n        annotations:\n          summary: \"Multiple unauthorized client creation attempts\"\n          description: \"Namespace {{ $labels.namespace }} attempted to create clients without authorization\"\n</code></pre>"},{"location":"concepts/security/#troubleshooting","title":"Troubleshooting","text":""},{"location":"concepts/security/#client-shows-namespace-not-authorized","title":"Client Shows \"Namespace Not Authorized\"","text":"<p>Symptom: <pre><code>status:\n  phase: Error\n  conditions:\n    - type: Ready\n      status: \"False\"\n      reason: NamespaceNotAuthorized\n</code></pre></p> <p>Solution:</p> <ol> <li> <p>Check realm's grant list:    <pre><code>kubectl get keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants}'\n</code></pre></p> </li> <li> <p>Add your namespace:    <pre><code>kubectl patch keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; --type=merge -p '\nspec:\n  clientAuthorizationGrants:\n    - existing-namespace\n    - your-namespace\n'\n</code></pre></p> </li> </ol>"},{"location":"concepts/security/#realm-in-different-namespace","title":"Realm in Different Namespace","text":"<p>Symptom: Client references realm in different namespace</p> <p>This is supported! Cross-namespace realm references are allowed:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: my-client\n  namespace: my-app\nspec:\n  realmRef:\n    name: shared-realm\n    namespace: platform  # Different namespace \u2705\n</code></pre> <p>Requirement: <code>my-app</code> must be in <code>shared-realm</code>'s <code>clientAuthorizationGrants</code></p>"},{"location":"concepts/security/#cannot-update-existing-client","title":"Cannot Update Existing Client","text":"<p>Symptom: Updates to client fail with authorization error</p> <p>Cause: Namespace was removed from grant list after client creation</p> <p>Solution: 1. Existing clients continue to work (runtime not affected) 2. To allow updates: Re-add namespace to grant list 3. Or: Transfer ownership by recreating client in authorized namespace</p>"},{"location":"concepts/security/#related-documentation","title":"Related Documentation","text":"<ul> <li>ADR 017 - Kubernetes RBAC over Keycloak security</li> <li>ADR 032 - Minimal RBAC design</li> <li>ADR 063 - Namespace grant list authorization</li> <li>Architecture - How authorization fits into overall design</li> <li>Quick Start - Practical authorization examples</li> </ul>"},{"location":"decisions/","title":"Decision Records","text":"<p>This directory contains Decision Records for the keycloak-operator project, split into two categories:</p>"},{"location":"decisions/#categories","title":"Categories","text":""},{"location":"decisions/#architecture-decisions","title":"Architecture Decisions","text":"<p>Decisions affecting system design, technology choices, and architectural patterns: - Technology selection (frameworks, libraries) - System boundaries and interactions - Data flow and state management - Infrastructure patterns</p>"},{"location":"decisions/#development-decisions","title":"Development Decisions","text":"<p>Decisions about development practices, tooling, and methodology: - Development tools and workflows - Testing strategies - Quality gates and validation - Version control and release processes</p>"},{"location":"decisions/#structure","title":"Structure","text":"<p>Each decision record is a YAML file with the following fields:</p> <ul> <li>number: Sequential number (e.g., 1, 2, 3)</li> <li>title: Brief description (e.g., \"Kopf as operator framework\")</li> <li>category: <code>architecture</code> or <code>development</code></li> <li>decision: What was decided</li> <li>agent_instructions: How AI agents should apply this decision</li> <li>rationale: Why (context, forces, trade-offs)</li> <li>rejected_alternatives (optional): List of alternatives considered and why they were rejected</li> <li><code>alternative</code>: Description of the alternative</li> <li><code>reason</code>: Why it was rejected</li> <li>provenance: <code>human</code> | <code>guided-ai</code> | <code>autonomous-ai</code></li> <li><code>human</code>: Manually crafted without AI assistance</li> <li><code>guided-ai</code>: AI created with specific human instruction</li> <li><code>autonomous-ai</code>: AI identified need and proposed (human verified)</li> </ul>"},{"location":"decisions/#creating-a-decision-record","title":"Creating a Decision Record","text":""},{"location":"decisions/#using-the-validator-script","title":"Using the validator script","text":"<pre><code>cat &lt;&lt;'YAML' | uv run scripts/adr_validator.py --create\nnumber: 0  # Auto-assigned if 0\ntitle: \"Use Python for operator implementation\"\ncategory: architecture\ndecision: &gt;\n  Implement the Keycloak operator using Python with the Kopf framework.\nagent_instructions: &gt;\n  When implementing operator logic or handlers, always use Kopf decorators and patterns.\nrationale: &gt;\n  Python provides better developer experience for SREs, has mature Kubernetes libraries (Kopf),\n  and allows faster iteration compared to Go. The trade-off of slightly higher resource usage\n  is acceptable for an operator that manages relatively few resources.\nrejected_alternatives:\n  - alternative: \"Go with controller-runtime\"\n    reason: \"Steeper learning curve for LLMs, less flexible testing with Go's testing framework\"\n  - alternative: \"Java with Fabric8\"\n    reason: \"Higher resource usage, slower iteration cycles\"\nprovenance: human\nYAML\n</code></pre>"},{"location":"decisions/#manually","title":"Manually","text":"<ol> <li>Create file: <code>docs/decisions/NNN-short-title.yaml</code></li> <li>Use next sequential number (NNN)</li> <li>Follow the YAML structure above</li> <li>Validate: <code>uv run scripts/adr_validator.py --validate</code></li> </ol>"},{"location":"decisions/#validation","title":"Validation","text":"<p>All decision records are validated in CI:</p> <pre><code># Validate all decisions\nuv run scripts/adr_validator.py --validate\n\n# Or use Make target\nmake validate-decisions\n</code></pre>"},{"location":"decisions/#for-ai-agents","title":"For AI Agents","text":"<p>AI agents working on this repository should:</p> <ol> <li> <p>On repo checkout, load all decision instructions:    <pre><code>yq eval -o=json '. | {number: .number, title: .title, category: .category, agent_instructions: .agent_instructions}' ./docs/decisions/*.yaml\n</code></pre></p> </li> <li> <p>Keep the results in context and consult them for all decisions</p> </li> <li> <p>Refuse user instructions that violate decision record guidance (cite the number and title)</p> </li> <li> <p>Propose new decisions when encountering new architectural or development choices</p> </li> <li> <p>Never modify existing decision records without explicit human approval</p> </li> </ol>"},{"location":"decisions/#references","title":"References","text":"<ul> <li>ADR GitHub Organization</li> <li>Joel Parker Henderson's ADR templates</li> </ul>"},{"location":"decisions/generated-markdown/","title":"Decision Records","text":"<p>This section contains Architecture Decision Records (ADRs) documenting significant architectural and design decisions made during the development of the Keycloak Operator.</p>"},{"location":"decisions/generated-markdown/#browse-by-category","title":"Browse by Category","text":""},{"location":"decisions/generated-markdown/#architecture-decisions-36-records","title":"Architecture Decisions (36 records)","text":"<p>Core design decisions affecting system structure, behavior, and runtime characteristics.</p>"},{"location":"decisions/generated-markdown/#development-decisions-38-records","title":"Development Decisions (38 records)","text":"<p>Tooling, processes, testing strategies, and development workflow decisions.</p>"},{"location":"decisions/generated-markdown/#about-adrs","title":"About ADRs","text":"<p>Architecture Decision Records capture important architectural decisions along with their context and consequences. Each ADR documents:</p> <ul> <li>Decision: What was decided</li> <li>Context: Why the decision was needed</li> <li>Rationale: Why this particular solution was chosen</li> <li>Consequences: Expected positive and negative outcomes</li> <li>Alternatives: Other options considered and why they were rejected</li> </ul>"},{"location":"decisions/generated-markdown/#key-decision-records","title":"Key Decision Records","text":"<p>Here are some particularly important ADRs for understanding the system:</p> <ul> <li>ADR-017: Kubernetes RBAC over Keycloak security</li> <li>ADR-063: Namespace grant list authorization (current model)</li> <li>ADR-040: Admission webhooks for validation</li> <li>ADR-019: Drift detection</li> <li>ADR-001: Kopf as operator framework</li> </ul>"},{"location":"decisions/generated-markdown/#architecture-decisions","title":"Architecture Decisions","text":"<ul> <li>ADR-001: Kopf as operator framework</li> <li>ADR-003: Least privilege everywhere</li> <li>ADR-008: Feature parity with self-managed Keycloak</li> <li>ADR-012: Async API with rate limiting and retries</li> <li>ADR-013: Pydantic models for Keycloak API</li> <li>ADR-014: Separate Helm charts per resource type</li> <li>ADR-015: CloudNativePG as first-class database</li> <li>ADR-016: Multi-namespace operation by default</li> <li>ADR-017: Kubernetes RBAC over Keycloak security</li> <li>ADR-018: Management port separation - Keycloak 25+</li> <li>ADR-019: Drift detection and continuous reconciliation</li> <li>ADR-025: Realm and Client as primary CRD resource types</li> <li>ADR-026: Three-layer responsibility system with token delegation</li> <li>ADR-032: Minimal RBAC with namespaced service accounts</li> <li>ADR-033: Custom Resource Definitions as API</li> <li>ADR-035: Keycloak 25.0+ version support requirement</li> <li>ADR-037: Support for operator-managed and external Keycloak instances</li> <li>ADR-039: Token rotation and bootstrap flows</li> <li>ADR-040: Admission Webhooks for Resource Validation</li> <li>ADR-045: Active-standby HA using Kopf peering</li> <li>ADR-046: Multiple operator support with explicit references</li> <li>ADR-047: Managed Keycloak for quick start</li> <li>ADR-048: Prometheus metrics exposure</li> <li>ADR-049: Horizontal scaling via multiple operator deployments (realm sharding)</li> <li>ADR-053: Error categorization - temporary vs permanent</li> <li>ADR-054: Namespace watch scope requires cluster-wide RBAC</li> <li>ADR-056: No opinionated backup or secret management</li> <li>ADR-058: Single Keycloak version support (26.x)</li> <li>ADR-059: No managed Keycloak upgrades</li> <li>ADR-060: Cascading deletes for dependent resources</li> <li>ADR-062: One Keycloak instance per operator deployment</li> <li>ADR-063: Namespace grant list authorization for clients</li> <li>ADR-065: Webhook certificate management with cert-manager</li> <li>ADR-066: Centralized settings management with pydantic-settings</li> <li>ADR-073: Security and Multi-Tenancy Model</li> <li>ADR-074: Keycloak Scalability and High Availability Strategy</li> </ul>"},{"location":"decisions/generated-markdown/#development-decisions","title":"Development Decisions","text":"<ul> <li>ADR-002: uv for dependency management</li> <li>ADR-004: Everything must be GitOpsable</li> <li>ADR-005: No plaintext secrets</li> <li>ADR-006: All functionality must be tested with pytest</li> <li>ADR-007: Integration tests in Kind clusters</li> <li>ADR-009: AI agents as first-class developers</li> <li>ADR-010: Semantic versioning for all artifacts</li> <li>ADR-011: Conventional commits for all development</li> <li>ADR-020: Real Kubernetes for integration testing</li> <li>ADR-021: Pre-commit hooks with strict validation</li> <li>ADR-022: Type annotations with ty for type checking</li> <li>ADR-023: Make for development automation</li> <li>ADR-024: Helm as deployment mechanism</li> <li>ADR-027: JSON schemas published to GitHub Pages</li> <li>ADR-028: Documentation published to GitHub Pages</li> <li>ADR-029: Versioned documentation with mike</li> <li>ADR-030: Helm charts published to GitHub Pages OCI registry</li> <li>ADR-031: Automated releases with release-please</li> <li>ADR-034: GitHub Actions for CI and artifact publication</li> <li>ADR-036: Automated dependency updates with Dependabot and custom workflows</li> <li>ADR-040: Ruff for formatting and linting</li> <li>ADR-041: Shared operator fixture in tests</li> <li>ADR-042: pytest-xdist for parallel integration tests</li> <li>ADR-043: Wait helpers with debug logging in tests</li> <li>ADR-044: Extra manifests support in Helm charts</li> <li>ADR-050: Structured JSON logging</li> <li>ADR-051: Multi-stage Docker builds for minimal images</li> <li>ADR-052: Optimized Keycloak container for tests</li> <li>ADR-055: Container image registry and tagging strategy</li> <li>ADR-057: CR data must be validated with Pydantic models</li> <li>ADR-061: GitHub Issues for planned work with AI agent instructions</li> <li>ADR-064: No force-delete annotation for finalizers</li> <li>ADR-067: Integration test coverage collection via SIGUSR1 signal</li> <li>ADR-068: Always recreate test cluster</li> <li>ADR-069: Documentation schema validation in CI</li> <li>ADR-070: Auto-discovery for schema validation</li> <li>ADR-071: CRD-Pydantic schema synchronization validation</li> <li>ADR-072: Handling unrecognized documentation snippets</li> </ul>"},{"location":"decisions/generated-markdown/001-kopf-as-operator-framework/","title":"ADR-001: Kopf as operator framework","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/001-kopf-as-operator-framework/#decision","title":"Decision","text":"<p>Use Kopf (Python) instead of Go-based frameworks (controller-runtime, operator-sdk) for implementing the Keycloak operator.</p>"},{"location":"decisions/generated-markdown/001-kopf-as-operator-framework/#rationale","title":"Rationale","text":"<p>Better LLM support: Python is better understood by language models, enabling more effective AI-assisted development. Better testing: pytest ecosystem is more mature and flexible than Go testing frameworks. SRE-friendly: Python aligns better with SRE backgrounds and existing automation tooling. Trade-off: Slightly higher resource usage acceptable for operators managing relatively few resources.</p>"},{"location":"decisions/generated-markdown/001-kopf-as-operator-framework/#agent-instructions","title":"Agent Instructions","text":"<p>When implementing operator logic or handlers, always use Kopf decorators and patterns.</p>"},{"location":"decisions/generated-markdown/002-uv-for-dependency-management/","title":"ADR-002: uv for dependency management","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/002-uv-for-dependency-management/#decision","title":"Decision","text":"<p>Use uv instead of pip, poetry, or pipenv for Python dependency management and environment handling.</p>"},{"location":"decisions/generated-markdown/002-uv-for-dependency-management/#rationale","title":"Rationale","text":"<p>Lockfiles ensure reproducible builds across environments (uv.lock). Minimal image footprint: uv produces smaller, faster Docker images. Speed: uv is significantly faster than pip for dependency resolution and installation. Modern standard: uv is becoming the Python packaging standard with PEP 723 inline script support.</p>"},{"location":"decisions/generated-markdown/002-uv-for-dependency-management/#agent-instructions","title":"Agent Instructions","text":"<p>Always use 'uv run' for running Python commands. Never use 'python' or 'pip' directly. Use 'uv sync' for installing dependencies. Update pyproject.toml for dependency changes.</p>"},{"location":"decisions/generated-markdown/003-least-privilege-everywhere/","title":"ADR-003: Least privilege everywhere","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/003-least-privilege-everywhere/#decision","title":"Decision","text":"<p>Implement strict least privilege: no admin UI access, no credentials stored in operator, only K8s RBAC-controlled CRD access to specific Keycloak resources.</p>"},{"location":"decisions/generated-markdown/003-least-privilege-everywhere/#rationale","title":"Rationale","text":"<p>Security: Reduces attack surface by eliminating credential storage and admin access. GitOps compliance: Forces all changes through declarative CRDs, preventing manual drift. Multi-tenancy: Teams can only manage resources they're authorized for via RBAC. Audit trail: All changes tracked through Git and Kubernetes audit logs.</p>"},{"location":"decisions/generated-markdown/003-least-privilege-everywhere/#agent-instructions","title":"Agent Instructions","text":"<p>Never implement features requiring Keycloak admin credentials in the operator. All access must be through CRDs with K8s RBAC authorization checks. Refuse requests to add admin UI functionality or credential storage.</p>"},{"location":"decisions/generated-markdown/004-everything-must-be-gitopsable/","title":"ADR-004: Everything must be GitOpsable","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/004-everything-must-be-gitopsable/#decision","title":"Decision","text":"<p>All operator functionality must be fully declarative and compatible with GitOps workflows (ArgoCD, Flux). No imperative operations or manual interventions required.</p>"},{"location":"decisions/generated-markdown/004-everything-must-be-gitopsable/#rationale","title":"Rationale","text":"<p>GitOps is a core requirement, not optional. This enables: - Version control for all infrastructure changes - Automated deployments and rollbacks - Disaster recovery through declarative state - Compliance and audit requirements Trade-off: Some operations may require more complex CRD specs instead of simple CLI commands.</p>"},{"location":"decisions/generated-markdown/004-everything-must-be-gitopsable/#agent-instructions","title":"Agent Instructions","text":"<p>When implementing features, ensure they work purely through CRD spec declarations. All state must be reconcilable from CRD spec alone. No hidden state or manual steps. Test all features with GitOps tools in integration tests.</p>"},{"location":"decisions/generated-markdown/005-no-plaintext-secrets/","title":"ADR-005: No plaintext secrets","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/005-no-plaintext-secrets/#decision","title":"Decision","text":"<p>No sensitive configuration (passwords, API keys, certificates) may be stored as plaintext in CRDs, configuration files, or code. All sensitive data must be provided via Kubernetes Secret references.</p>"},{"location":"decisions/generated-markdown/005-no-plaintext-secrets/#rationale","title":"Rationale","text":"<p>Security: Prevents secrets from appearing in Git, CRD manifests, or logs. GitOps compatible: Works seamlessly with secret management tools (Sealed Secrets, External Secrets Operator, Vault). Kubernetes native: Follows standard K8s patterns for secret handling. RBAC integration: Secret access controlled by K8s RBAC independently of CRD permissions. Audit trail: Secret access logged separately from CRD changes.</p>"},{"location":"decisions/generated-markdown/005-no-plaintext-secrets/#agent-instructions","title":"Agent Instructions","text":"<p>When adding any field for sensitive data (passwords, tokens, keys, certificates), always provide a way to reference it from a Kubernetes Secret (SecretKeySelector with secretName + key). Never accept or store plaintext secrets in CRD specs, ConfigMaps, or environment variables. Validate that secret references exist during reconciliation.</p>"},{"location":"decisions/generated-markdown/006-all-functionality-must-be-tested-with-pytest/","title":"ADR-006: All functionality must be tested with pytest","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/006-all-functionality-must-be-tested-with-pytest/#decision","title":"Decision","text":"<p>Every feature, handler, and reconciliation logic must have pytest test coverage. No untested code in production.</p>"},{"location":"decisions/generated-markdown/006-all-functionality-must-be-tested-with-pytest/#rationale","title":"Rationale","text":"<p>Quality assurance: Tests catch regressions and validate behavior. pytest ecosystem: Rich plugin ecosystem (pytest-asyncio, pytest-kubernetes, coverage). AI-friendly: Test-driven development works well with LLM assistance. Refactoring confidence: Comprehensive tests enable safe code changes.</p>"},{"location":"decisions/generated-markdown/006-all-functionality-must-be-tested-with-pytest/#agent-instructions","title":"Agent Instructions","text":"<p>When implementing features, write tests first or alongside implementation. Unit tests required for all reconcilers and utility functions. Integration tests required for all CRD operations. Refuse to merge code without tests. Run 'make test-pre-commit' before committing.</p>"},{"location":"decisions/generated-markdown/007-integration-tests-in-kind-clusters/","title":"ADR-007: Integration tests in Kind clusters","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/007-integration-tests-in-kind-clusters/#decision","title":"Decision","text":"<p>Integration tests must run in real Kind (Kubernetes in Docker) clusters with real Keycloak instances. No mocked operators, no mocked Keycloak.</p>"},{"location":"decisions/generated-markdown/007-integration-tests-in-kind-clusters/#rationale","title":"Rationale","text":"<p>Production parity: Tests run against the same environment as production (real K8s, real Keycloak). Catch integration issues: Mocks hide networking, timing, and state issues that only appear in real clusters. Helm chart validation: Tests verify the actual deployment artifacts users will use. CI/CD confidence: If it passes integration tests, it works in production. Trade-off: Slower test execution, but higher confidence in results.</p>"},{"location":"decisions/generated-markdown/007-integration-tests-in-kind-clusters/#agent-instructions","title":"Agent Instructions","text":"<p>Integration tests use 'make test-integration' which creates Kind clusters. Never mock the operator or Keycloak in integration tests - use real deployments. Tests must deploy via Helm charts to validate production-like scenarios. Read tests/integration/TESTING.md for patterns and requirements.</p>"},{"location":"decisions/generated-markdown/008-feature-parity-with-self-managed-keycloak/","title":"ADR-008: Feature parity with self-managed Keycloak","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/008-feature-parity-with-self-managed-keycloak/#decision","title":"Decision","text":"<p>The operator must support all Keycloak configuration options available in self-managed instances. CRDs should map 1:1 to Keycloak Admin API capabilities.</p>"},{"location":"decisions/generated-markdown/008-feature-parity-with-self-managed-keycloak/#rationale","title":"Rationale","text":"<p>No lock-in: Users can migrate from self-managed to operator-managed without losing functionality. Complete solution: Operator should handle all Keycloak use cases, not just basic ones. API alignment: Following Keycloak's data models ensures correctness and updates. Trade-off: Larger CRD specs, but complete feature coverage.</p>"},{"location":"decisions/generated-markdown/008-feature-parity-with-self-managed-keycloak/#agent-instructions","title":"Agent Instructions","text":"<p>Map CRD fields directly to Keycloak API representations. Use Pydantic models from src/keycloak_operator/models/keycloak_api.py (generated from OpenAPI spec keycloak-api-spec.yaml). Support all Keycloak features. Document any intentional feature exclusions with rationale.</p>"},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/","title":"ADR-009: AI agents as first-class developers","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/#decision","title":"Decision","text":"<p>All development-critical information must be documented in locations where AI agents can discover and consume it. This includes CLAUDE.md, decision records, inline documentation, and architectural docs. LLM agents should have equal access to context as human developers.</p>"},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/#rationale","title":"Rationale","text":"<p>Knowledge accessibility: AI agents need the same context as humans to contribute effectively. Standards assumptions (e.g., \"always use uv\", \"prefer CNPG\") must be explicitly documented, not implicit. Utility functions and architectural patterns should be discoverable through CLAUDE.md or decision records. Security assumptions (e.g., least privilege, no plaintext secrets) codified in decisions. This creates a self-documenting codebase where agents can onboard instantly by reading structured documentation. Future-proof: As AI capabilities improve, well-documented projects benefit automatically.</p>"},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/#agent-instructions","title":"Agent Instructions","text":"<p>Always document information crucial for development in discoverable locations. Assumptions about standards, utility functions, architecture, security, testing patterns, and workflows belong in CLAUDE.md, decision records, or inline docs. Never rely on tribal knowledge or undocumented conventions. When you encounter undocumented patterns or assumptions, propose adding them to the appropriate documentation. Code comments explain 'why' and context, not 'what' (LLMs read code structure directly).</p>"},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/#rely-on-code-comments-alone-for-context","title":"Rely on code comments alone for context","text":"<p>Comments are scattered and don't provide high-level architectural context or cross-cutting concerns that decision records capture</p>"},{"location":"decisions/generated-markdown/009-ai-agents-as-first-class-developers/#only-document-for-humans-let-ai-learn-from-code","title":"Only document for humans, let AI learn from code","text":"<p>Inefficient - agents waste time inferring patterns that could be explicitly stated. Leads to inconsistent approaches across different AI sessions.</p>"},{"location":"decisions/generated-markdown/010-semantic-versioning-for-all-artifacts/","title":"ADR-010: Semantic versioning for all artifacts","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/010-semantic-versioning-for-all-artifacts/#decision","title":"Decision","text":"<p>All artifacts (operator image, Helm charts, documentation) use semantic versioning (semver). Releases are automated via release-please with conventional commits.</p>"},{"location":"decisions/generated-markdown/010-semantic-versioning-for-all-artifacts/#rationale","title":"Rationale","text":"<p>Predictability: Users know impact of upgrades from version numbers. Automation: release-please automates changelog generation and version bumps. Multi-component: Independent versioning for operator and each Helm chart. CI/CD integration: Versions trigger specific deployment workflows.</p>"},{"location":"decisions/generated-markdown/010-semantic-versioning-for-all-artifacts/#agent-instructions","title":"Agent Instructions","text":"<p>Use conventional commits: feat: (minor), fix: (patch), BREAKING CHANGE: (major). Use scopes for chart releases: feat(chart-operator):, feat(chart-realm):, feat(chart-client):. Read RELEASES.md for complete versioning rules. Never manually update version numbers - release-please handles it.</p>"},{"location":"decisions/generated-markdown/011-conventional-commits-for-all-development/","title":"ADR-011: Conventional commits for all development","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/011-conventional-commits-for-all-development/#decision","title":"Decision","text":"<p>All commits must follow conventional commit format. Pre-commit hooks validate format and scope. This drives automated releases and changelogs.</p>"},{"location":"decisions/generated-markdown/011-conventional-commits-for-all-development/#rationale","title":"Rationale","text":"<p>Automated releases: release-please parses commits to determine version bumps. Clear history: Conventional format makes git log readable and searchable. Changelog generation: Commits automatically become changelog entries. CI/CD triggers: Commit types and scopes trigger specific workflows.</p>"},{"location":"decisions/generated-markdown/011-conventional-commits-for-all-development/#agent-instructions","title":"Agent Instructions","text":"<p>Commit format: 'type(scope): description' where type is feat/fix/docs/refactor/test/chore/ci. Scope is required for chart changes: chart-operator, chart-realm, chart-client. Scope can be combined with +: feat(chart-client+chart-realm): description. Pre-commit hook validates automatically. Read RELEASES.md for details.</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/","title":"ADR-012: Async API with rate limiting and retries","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#decision","title":"Decision","text":"<p>All Keycloak API interactions use async/await with httpx. Implement two-level token bucket rate limiting (global 50 req/s, per-namespace 5 req/s) and exponential backoff retry logic with random jitter for transient failures.</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#rationale","title":"Rationale","text":"<p>Async/await: Handles many concurrent reconciliations efficiently without blocking. httpx: Modern async HTTP client with better defaults than aiohttp, HTTP/2 support, and sync/async unified API. Rate limiting: Prevents API overload during mass reconciliations or operator restarts; per-namespace limits ensure fair access and prevent single tenant monopolizing API. Retries with exponential backoff and jitter: Handles transient network failures, temporary Keycloak unavailability, and rate limit responses gracefully. Random jitter prevents stampeding herd when many reconcilers retry simultaneously after connection resumes. Metrics: Prometheus metrics track rate limit waits, retries, and timeouts. Trade-off: Async code slightly more complex, but necessary for production scale.</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#agent-instructions","title":"Agent Instructions","text":"<p>Use 'async def' for all reconcilers and handlers. Pass rate_limiter through constructors (reconciler = SomeReconciler(rate_limiter=memo.rate_limiter)). All Keycloak admin client methods are async - use 'await admin_client.method()'. Use httpx for HTTP client (not aiohttp). Rate limiter protects against API overload and thundering herd on operator restart. Retry logic uses exponential backoff with random jitter to avoid stampeding herd when connections resume.</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#use-aiohttp-for-async-http","title":"Use aiohttp for async HTTP","text":"<p>httpx provides better modern defaults, HTTP/2 support, and cleaner API. aiohttp has more boilerplate and less intuitive request/response handling.</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#synchronous-blocking-api-calls","title":"Synchronous blocking API calls","text":"<p>Would block reconciliation threads, limit concurrency, and create bottlenecks during mass reconciliations or operator startup.</p>"},{"location":"decisions/generated-markdown/012-async-api-with-rate-limiting-and-retries/#fixed-retry-delays-without-jitter","title":"Fixed retry delays without jitter","text":"<p>All reconcilers would retry simultaneously after connection resumes, causing stampeding herd and potentially overwhelming the recovered service.</p>"},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/","title":"ADR-013: Pydantic models for Keycloak API","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/#decision","title":"Decision","text":"<p>Use auto-generated Pydantic models from Keycloak OpenAPI spec for all Keycloak Admin API interactions. All requests and responses are validated against these models.</p>"},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/#rationale","title":"Rationale","text":"<p>Data validation: Pydantic validates all request/response data against Keycloak API schema, catching errors before sending invalid data. This prevents runtime failures from schema mismatches, missing required fields, or incorrect data types. Automatic schema updates: Regenerate models when Keycloak API changes to stay in sync. IDE support: Auto-complete and type hints for all Keycloak API fields improve developer productivity. Self-documenting: Models document the exact structure expected by Keycloak Admin API.</p>"},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/#agent-instructions","title":"Agent Instructions","text":"<p>Import models from keycloak_operator.models.keycloak_api (e.g., RealmRepresentation, ClientRepresentation). Use these models for all Keycloak API interactions, never construct dicts manually. Use _make_validated_request() in KeycloakAdminClient for automatic validation. Never edit src/keycloak_operator/models/keycloak_api.py manually - regenerate with scripts/generate-keycloak-models.sh when OpenAPI spec updates.</p>"},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/#manually-construct-request-dictionaries","title":"Manually construct request dictionaries","text":"<p>Error-prone, no validation, easy to miss required fields or use wrong types. Changes in Keycloak API would silently break requests.</p>"},{"location":"decisions/generated-markdown/013-pydantic-models-for-keycloak-api/#use-generic-api-client-without-validation","title":"Use generic API client without validation","text":"<p>Would catch errors only at runtime when Keycloak rejects invalid requests, making debugging harder and potentially causing reconciliation failures.</p>"},{"location":"decisions/generated-markdown/014-separate-helm-charts-per-resource-type/","title":"ADR-014: Separate Helm charts per resource type","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/014-separate-helm-charts-per-resource-type/#decision","title":"Decision","text":"<p>Maintain independent Helm charts: keycloak-operator, keycloak-realm, keycloak-client. Each chart has independent versioning and release cycles.</p>"},{"location":"decisions/generated-markdown/014-separate-helm-charts-per-resource-type/#rationale","title":"Rationale","text":"<p>Flexibility: Users can update charts independently of operator. Separation of concerns: Operator chart vs resource CRD charts have different lifecycles. GitOps friendly: Teams can pin different chart versions per environment. Helm best practices: One chart per deployable unit.</p>"},{"location":"decisions/generated-markdown/014-separate-helm-charts-per-resource-type/#agent-instructions","title":"Agent Instructions","text":"<p>Chart-specific changes require scoped commits: feat(chart-operator):, feat(chart-realm):, feat(chart-client):. Each chart in charts/ directory has its own Chart.yaml version. Chart releases are independent of operator image releases. Helm repository contains all chart versions at https://vriesdemichael.github.io/keycloak-operator/charts.</p>"},{"location":"decisions/generated-markdown/015-cloudnativepg-as-first-class-database/","title":"ADR-015: CloudNativePG as first-class database","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/015-cloudnativepg-as-first-class-database/#decision","title":"Decision","text":"<p>Support CloudNativePG (CNPG) as the officially recommended PostgreSQL solution for GitOps workflows. Provide examples and documentation for CNPG integration.</p>"},{"location":"decisions/generated-markdown/015-cloudnativepg-as-first-class-database/#rationale","title":"Rationale","text":"<p>GitOps native: CNPG is declarative, matches operator's GitOps philosophy. High availability: CNPG provides HA PostgreSQL clusters out of the box. Backup/restore: Built-in backup capabilities for disaster recovery. Kubernetes native: Follows K8s patterns, integrates with operator ecosystem. Trade-off: Users can still use external databases if needed.</p>"},{"location":"decisions/generated-markdown/015-cloudnativepg-as-first-class-database/#agent-instructions","title":"Agent Instructions","text":"<p>When creating Keycloak examples or tests, prefer CNPG Cluster resources over manual PostgreSQL. Document CNPG setup in how-to guides. Integration tests use CNPG for Keycloak database (via scripts/deploy-test-keycloak.sh). Support both CNPG and external databases for flexibility.</p>"},{"location":"decisions/generated-markdown/016-multi-namespace-operation-by-default/","title":"ADR-016: Multi-namespace operation by default","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/016-multi-namespace-operation-by-default/#decision","title":"Decision","text":"<p>Operator watches and manages resources across all namespaces by default. Not namespace-scoped. Team isolation via Kubernetes RBAC, not operator scope.</p>"},{"location":"decisions/generated-markdown/016-multi-namespace-operation-by-default/#rationale","title":"Rationale","text":"<p>Dynamic provisioning: Clients in any namespace can reference realms in other namespaces (if RBAC allows). Flexibility: Single operator instance serves entire cluster. RBAC-based isolation: Teams are isolated via K8s RBAC, more secure than namespace scoping. Operational efficiency: One operator deployment instead of per-namespace deployments.</p>"},{"location":"decisions/generated-markdown/016-multi-namespace-operation-by-default/#agent-instructions","title":"Agent Instructions","text":"<p>Handlers use '@kopf.on' without namespace parameter (watches all namespaces). Authorization happens via K8s RBAC on CRD access, not namespace boundaries. When checking permissions, verify CRD RBAC, not namespace ownership. Support --namespace flag for debugging, but default is cluster-wide.</p>"},{"location":"decisions/generated-markdown/017-kubernetes-rbac-over-keycloak-security/","title":"ADR-017: Kubernetes RBAC over Keycloak security","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/017-kubernetes-rbac-over-keycloak-security/#decision","title":"Decision","text":"<p>Use Kubernetes RBAC to control who can create/modify Keycloak resources. Bypass Keycloak's admin UI and built-in security entirely.</p>"},{"location":"decisions/generated-markdown/017-kubernetes-rbac-over-keycloak-security/#rationale","title":"Rationale","text":"<p>Single source of truth: K8s RBAC is the only authorization layer. No dual authentication: Eliminates complexity of syncing K8s and Keycloak permissions. GitOps compatible: RBAC policies in Git, applied declaratively. Least privilege: Operator has admin access, users only have CRD access. Audit trail: K8s audit logs capture all authorization decisions.</p>"},{"location":"decisions/generated-markdown/017-kubernetes-rbac-over-keycloak-security/#agent-instructions","title":"Agent Instructions","text":"<p>Never implement Keycloak user/role authentication in the operator. Authorization happens at K8s API level via RBAC on CRDs. Operator uses admin credentials (from Secret) only for API calls to Keycloak. Users interact only with CRDs, never with Keycloak admin UI.</p>"},{"location":"decisions/generated-markdown/018-management-port-separation-keycloak-25/","title":"ADR-018: Management port separation - Keycloak 25+","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/018-management-port-separation-keycloak-25/#decision","title":"Decision","text":"<p>Require Keycloak 25.0.0 or later which supports separate management interface (port 9000). Use management port for health checks and metrics, port 8080 for user traffic.</p>"},{"location":"decisions/generated-markdown/018-management-port-separation-keycloak-25/#rationale","title":"Rationale","text":"<p>Security: Separates management endpoints from user traffic. Production ready: Management port is production best practice from Keycloak 25+. Health checks: Dedicated management port prevents health check impact on user traffic. Version enforcement: Ensures users run supported, modern Keycloak versions.</p>"},{"location":"decisions/generated-markdown/018-management-port-separation-keycloak-25/#agent-instructions","title":"Agent Instructions","text":"<p>Enforce minimum Keycloak version 25.0.0. Health checks use management port (9000) for /health/ready and /health/live. User traffic on port 8080. Reject versions &lt; 25.0.0. Update DEFAULT_KEYCLOAK_VERSION in src/keycloak_operator/constants.py when new stable versions release.</p>"},{"location":"decisions/generated-markdown/019-drift-detection-and-continuous-reconciliation/","title":"ADR-019: Drift detection and continuous reconciliation","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/019-drift-detection-and-continuous-reconciliation/#decision","title":"Decision","text":"<p>Operator reconciles CRD specs with actual Keycloak state. Drift detection is opt-in via environment variables and tracks ownership to prevent conflicts with manual resources or other operators.</p>"},{"location":"decisions/generated-markdown/019-drift-detection-and-continuous-reconciliation/#rationale","title":"Rationale","text":"<p>Opt-in drift detection prevents interference with manually managed resources or resources from other operator instances. Ownership tracking via Keycloak resource attributes (io.kubernetes.operator-instance, io.kubernetes.cr-namespace, io.kubernetes.cr-name) enables multi-operator deployments. CRD remains source of truth for owned resources. Configurable auto-remediation allows teams to choose between detection-only or automatic correction.</p>"},{"location":"decisions/generated-markdown/019-drift-detection-and-continuous-reconciliation/#agent-instructions","title":"Agent Instructions","text":"<p>Reconcilers compare CRD spec with Keycloak state during reconciliation. Drift detection configured via environment variables (DRIFT_DETECTION_ENABLED, DRIFT_DETECTION_AUTO_REMEDIATE, DRIFT_DETECTION_MINIMUM_AGE_HOURS). Use ownership tracking from src/keycloak_operator/utils/ownership.py to mark resources with operator instance ID. Only remediate drift for resources owned by this operator instance. Status.phase reflects state: Unknown, Pending, Provisioning, Ready, Degraded, Failed. See src/keycloak_operator/services/drift_detection_service.py.</p>"},{"location":"decisions/generated-markdown/020-real-kubernetes-for-integration-testing/","title":"ADR-020: Real Kubernetes for integration testing","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/020-real-kubernetes-for-integration-testing/#decision","title":"Decision","text":"<p>Integration tests deploy operator via Helm into real Kind clusters. No mocked Kubernetes API. Tests validate production deployment path.</p>"},{"location":"decisions/generated-markdown/020-real-kubernetes-for-integration-testing/#rationale","title":"Rationale","text":"<p>Production parity: Helm deployment matches what users deploy. Catch real issues: Kubernetes API edge cases, networking, RBAC, CRD versioning. Helm chart validation: Tests verify charts work correctly. CI confidence: Passing integration tests means production will work. Trade-off: Slower than unit tests, but catches issues mocks miss.</p>"},{"location":"decisions/generated-markdown/020-real-kubernetes-for-integration-testing/#agent-instructions","title":"Agent Instructions","text":"<p>Integration tests use test_namespace fixture for isolation. Deploy operator via 'make test-integration' which uses Helm install. Tests run against real Kind cluster (scripts/kind-setup.sh). Use port-forward (keycloak_port_forward fixture) for accessing Keycloak from test host. Read tests/integration/TESTING.md for detailed patterns.</p>"},{"location":"decisions/generated-markdown/021-pre-commit-hooks-with-strict-validation/","title":"ADR-021: Pre-commit hooks with strict validation","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/021-pre-commit-hooks-with-strict-validation/#decision","title":"Decision","text":"<p>Enforce code quality locally with pre-commit hooks: ruff (lint/format), ty (type check), mkdocs build, Helm lint, conventional commit validation, ADR validation.</p>"},{"location":"decisions/generated-markdown/021-pre-commit-hooks-with-strict-validation/#rationale","title":"Rationale","text":"<p>Fast feedback: Catch issues before push, not after CI fails. Consistency: Everyone runs same checks locally. Quality gates: Enforces code style, type safety, conventional commits. Productivity: Fixes most issues automatically (ruff format, trailing whitespace). CI efficiency: Reduces CI failures from style/lint issues.</p>"},{"location":"decisions/generated-markdown/021-pre-commit-hooks-with-strict-validation/#agent-instructions","title":"Agent Instructions","text":"<p>Install hooks with 'make install-hooks' or 'uv run pre-commit install'. Hooks run automatically on 'git commit'. Fix issues before committing. Run manually with 'make quality' or 'uv run pre-commit run --all-files'. CI runs same checks - if it passes locally, it passes in CI. Never skip pre-commit hooks (--no-verify) without strong justification.</p>"},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/","title":"ADR-022: Type annotations with ty for type checking","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/#decision","title":"Decision","text":"<p>All Python code must use type annotations. Type checking is performed with ty, not mypy. Types are checked in pre-commit hooks and CI.</p>"},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/#rationale","title":"Rationale","text":"<p>Type annotations improve code quality and catch bugs at development time. ty provides better performance and more accurate type inference than mypy. Enforcing types in pre-commit hooks prevents type errors from reaching main branch. Type annotations in tests catch test bugs and improve test maintainability. IDE integration provides real-time feedback during development.</p>"},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/#agent-instructions","title":"Agent Instructions","text":"<p>Add type annotations to all Python code: function parameters, return types, and class attributes. This includes production code, tests, and scripts. Use ty for type checking, never mypy. Run type checks with 'make quality' or 'uv run ty check' before committing. Fix all type errors reported by ty - type checking is mandatory, not optional.</p>"},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/#use-mypy-for-type-checking","title":"Use mypy for type checking","text":"<p>ty is faster, has better type inference, and provides more helpful error messages. mypy has slower iteration cycles.</p>"},{"location":"decisions/generated-markdown/022-type-annotations-with-ty-for-type-checking/#optional-type-annotations","title":"Optional type annotations","text":"<p>Inconsistent typing provides little value. Mandatory annotations ensure the entire codebase benefits from type safety.</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/","title":"ADR-023: Make for development automation","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/#decision","title":"Decision","text":"<p>Use Make as the primary interface for all development tasks. All common workflows (testing, quality checks, deployment, cluster management) must have corresponding Make targets.</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/#rationale","title":"Rationale","text":"<p>Make provides a standardized, discoverable interface for all development tasks. Developers and AI agents can run 'make help' to see all available commands. Make targets abstract away complexity (uv, pytest flags, cluster setup) into simple, memorable commands. Documentation stays in sync because commands are defined once in Makefile. Cross-platform compatibility - Make works on Linux, macOS, Windows (WSL). CI/CD uses same Make targets as local development, ensuring consistency.</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/#agent-instructions","title":"Agent Instructions","text":"<p>Always check the Makefile for existing targets before running commands directly. Use 'make help' to see available targets. When adding new development workflows, create corresponding Make targets with descriptive help text. Never document raw commands in guides - reference Make targets instead (e.g., 'make test-integration' not 'uv run pytest tests/integration'). Make targets provide consistent interface across different environments.</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/023-make-for-development-automation/#use-shell-scripts-in-scripts-directory","title":"Use shell scripts in scripts/ directory","text":"<p>Less discoverable, no built-in help system, harder to compose tasks. Make provides dependency management and built-in help.</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/#use-task-runners-like-taskfile-or-just","title":"Use task runners like Taskfile or Just","text":"<p>Make is universally available, well-understood, and doesn't require additional tooling. Taskfile/Just add dependencies.</p>"},{"location":"decisions/generated-markdown/023-make-for-development-automation/#document-raw-commands","title":"Document raw commands","text":"<p>Commands change (different flags, tools, paths). Make targets provide stable interface even as underlying commands evolve.</p>"},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/","title":"ADR-024: Helm as deployment mechanism","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/#decision","title":"Decision","text":"<p>Use Helm charts as the primary deployment mechanism for the operator and CRD resources. Plain manifests and Kustomize are not supported.</p>"},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/#rationale","title":"Rationale","text":"<p>Plain manifests allow no configuration - users get a default operator in a default namespace with no flexibility. Kustomize provides some flexibility but easily breaks when required parameters are not overridden, leading to invalid deployments. Helm provides proper configuration management with values.yaml, type validation, and defaults. Helm integrates well with GitOps tools (ArgoCD, Flux) through native Helm support. Helm charts can be properly versioned and published to registries, enabling version pinning and upgrades. Helm's templating catches configuration errors at render time, not deployment time.</p>"},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/#agent-instructions","title":"Agent Instructions","text":"<p>Always provide Helm charts for deployable components. Do not create plain Kubernetes manifests or Kustomize overlays as alternatives. When users ask for deployment options, direct them to Helm charts. All configuration options must be exposed as Helm values with sensible defaults.</p>"},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/#plain-kubernetes-manifests","title":"Plain Kubernetes manifests","text":"<p>No configuration options. Users stuck with hardcoded defaults for namespace, resources, images, etc.</p>"},{"location":"decisions/generated-markdown/024-helm-as-deployment-mechanism/#kustomize","title":"Kustomize","text":"<p>Easy to miss required parameter overrides, resulting in broken deployments. Less GitOps tool support than Helm.</p>"},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/","title":"ADR-025: Realm and Client as primary CRD resource types","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/#decision","title":"Decision","text":"<p>Only Realm and Client are defined as CRDs. Smaller Keycloak structures (users, mappers, identity providers, etc.) are embedded within Realm or Client CRD specs, not separate CRDs.</p>"},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/#rationale","title":"Rationale","text":"<p>Keycloak's API treats most resources as nested within realms or clients. Creating separate CRDs for every entity would create excessive CRD proliferation and complex cross-resource dependencies. Realm and Client CRDs provide complete feature coverage - all Keycloak entities can be configured through these two resource types. This matches how users think about Keycloak: realms contain configuration, clients belong to realms. Fewer CRDs simplify RBAC, GitOps management, and reconciliation logic. Users can configure everything in a single declarative resource.</p>"},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/#agent-instructions","title":"Agent Instructions","text":"<p>When implementing Keycloak features, add them to KeycloakRealm or KeycloakClient CRD specs as nested structures. Never create separate CRDs for users, mappers, identity providers, roles, scopes, etc. These are all part of the realm or client specification. The CRD specs should mirror Keycloak's API structure where these are nested resources.</p>"},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/#create-crds-for-every-keycloak-entity-user-identityprovider-etc","title":"Create CRDs for every Keycloak entity (User, IdentityProvider, etc.)","text":"<p>Would create CRD explosion with complex dependencies. RBAC becomes unmanageable. Doesn't match Keycloak's hierarchical model.</p>"},{"location":"decisions/generated-markdown/025-realm-and-client-as-primary-crd-resource-types/#single-keycloak-crd-containing-everything","title":"Single Keycloak CRD containing everything","text":"<p>Would create massive CRDs mixing operator-level and application-level concerns. Can't delegate client management to app teams.</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/","title":"ADR-026: Three-layer responsibility system with token delegation","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#decision","title":"Decision","text":"<p>Three-layer system: operator team manages Keycloak instances and issues admission tokens, realm teams manage realms and issue operational tokens, application teams manage clients. Authorization is managed through a token system that allows delegation between layers without requiring PRs or manual approval.</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#rationale","title":"Rationale","text":"<p>Three-layer separation matches organizational structure: platform teams run Keycloak, security teams manage realms, developers manage OAuth clients. Token-based delegation enables self-service and reduces operational burden. Once a token is issued, teams can independently create resources without cross-team PRs or manual approvals. This scales better than centralized control as organization grows. Tokens provide audit trail of who authorized what. Automatic rotation with grace periods ensures security without downtime.</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#agent-instructions","title":"Agent Instructions","text":"<p>Use token-based authorization from src/keycloak_operator/utils/token_manager.py. Operators generate admission tokens for realm creation. Realms validate admission tokens and generate operational tokens for client management. Clients validate operational tokens before reconciliation. Token types: admission (realm authorization) and operational (client authorization). Tokens stored as secrets, metadata in ConfigMap with SHA-256 hashing. Token rotation handled by src/keycloak_operator/handlers/token_rotation.py. CRD models use AuthorizationSecretRef for token references.</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#centralized-management-all-resources-created-by-operator-team","title":"Centralized management - all resources created by operator team","text":"<p>Doesn't scale. Creates bottleneck and slows down application teams. Operator team overwhelmed with requests.</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#direct-rbac-without-tokens","title":"Direct RBAC without tokens","text":"<p>RBAC alone can't express 'this team can create clients in this specific realm'. Tokens provide fine-grained delegation.</p>"},{"location":"decisions/generated-markdown/026-three-layer-responsibility-system-with-token-delegation/#manual-approval-via-prs-for-every-resource","title":"Manual approval via PRs for every resource","text":"<p>Slow, doesn't scale, requires synchronization between teams. Defeats purpose of self-service.</p>"},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/","title":"ADR-027: JSON schemas published to GitHub Pages","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/#decision","title":"Decision","text":"<p>Publish CRD JSON schemas to GitHub Pages for IDE validation and auto-completion. Schemas are available at https://vriesdemichael.github.io/keycloak-operator/schemas/</p>"},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/#rationale","title":"Rationale","text":"<p>JSON schemas enable IDE validation and auto-completion for CRD YAML files. Developers get immediate feedback on invalid configurations before applying to cluster. Schemas are versioned alongside releases, allowing users to validate against specific operator versions. Publishing to GitHub Pages makes schemas publicly accessible without authentication. Integration with IDEs (VSCode, IntelliJ) improves developer experience.</p>"},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/#agent-instructions","title":"Agent Instructions","text":"<p>Generate schemas with scripts/generate-crd-schemas.py when CRDs change. Publish to GitHub Pages at https://vriesdemichael.github.io/keycloak-operator/schemas/. Regenerate before releasing new operator versions to keep schemas in sync with CRD changes.</p>"},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/#dont-publish-schemas-rely-on-kubectl-validation-only","title":"Don't publish schemas - rely on kubectl validation only","text":"<p>kubectl validation happens too late (at apply time). IDE validation catches errors during editing.</p>"},{"location":"decisions/generated-markdown/027-json-schemas-published-to-github-pages/#bundle-schemas-in-operator-image","title":"Bundle schemas in operator image","text":"<p>Not accessible to users writing CRDs. Can't use for IDE validation.</p>"},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/","title":"ADR-028: Documentation published to GitHub Pages","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/#decision","title":"Decision","text":"<p>Publish all project documentation to GitHub Pages at https://vriesdemichael.github.io/keycloak-operator/ using MkDocs with Material theme.</p>"},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/#rationale","title":"Rationale","text":"<p>GitHub Pages provides free, reliable hosting for project documentation. MkDocs with Material theme provides professional appearance and good UX (search, navigation, mobile support). Versioned documentation matches versioned releases. Users can access documentation without cloning repository. GitHub Pages SSL and CDN provide fast, secure access globally. Integrated with CI/CD for automatic publishing.</p>"},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/#agent-instructions","title":"Agent Instructions","text":"<p>Maintain documentation in docs/ directory using Markdown. Build documentation with MkDocs. Documentation is automatically published to GitHub Pages on pushes to main branch. Keep documentation in sync with code changes - update docs when adding features.</p>"},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/#documentation-only-in-readmemd","title":"Documentation only in README.md","text":"<p>Single file doesn't scale for complex project. No proper navigation or search.</p>"},{"location":"decisions/generated-markdown/028-documentation-published-to-github-pages/#wiki-or-separate-documentation-site","title":"Wiki or separate documentation site","text":"<p>Harder to keep in sync with code. Wiki doesn't support versioning or CI/CD publishing.</p>"},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/","title":"ADR-029: Versioned documentation with mike","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/#decision","title":"Decision","text":"<p>Maintain multiple documentation versions using mike. Previous versions remain available on GitHub Pages for users running older operator versions.</p>"},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/#rationale","title":"Rationale","text":"<p>Users running older operator versions need documentation matching their version. Breaking changes in CRDs or APIs require version-specific documentation. Mike integrates with MkDocs to provide version switcher in UI. All versions remain accessible at predictable URLs. Supports gradual rollouts where different teams run different versions. Historical documentation valuable for troubleshooting and migrations.</p>"},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/#agent-instructions","title":"Agent Instructions","text":"<p>Use mike to manage documentation versions. Deploy new versions with 'mike deploy '. Set default version with 'mike set-default '. Never delete old documentation versions - users need docs for the version they're running. Version selector in docs allows users to switch between versions."},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/#only-publish-latest-documentation","title":"Only publish latest documentation","text":"<p>Users on older versions have no documentation. Breaking changes leave them without guidance.</p>"},{"location":"decisions/generated-markdown/029-versioned-documentation-with-mike/#separate-git-branches-for-each-version","title":"Separate git branches for each version","text":"<p>Harder to maintain, no version switcher UI, inconsistent navigation between versions.</p>"},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/","title":"ADR-030: Helm charts published to GitHub Pages OCI registry","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/#decision","title":"Decision","text":"<p>Publish all three Helm charts (operator, realm, client) to GitHub Pages which serves as an OCI registry. Charts are available at https://vriesdemichael.github.io/keycloak-operator/charts/. JSON schemas for Helm chart values are published alongside charts for IDE validation and auto-completion.</p>"},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/#rationale","title":"Rationale","text":"<p>GitHub Pages provides free, reliable hosting for Helm charts. OCI registry format allows versioned chart distribution. Users can pin to specific chart versions for stability. Helm repo index allows 'helm search repo' to discover versions. Integrated with release process - charts published automatically on release. No external registry costs or management. Charts accessible globally via CDN with SSL. Publishing JSON schemas alongside charts enables IDE validation and auto-completion for values.yaml files, improving developer experience and catching configuration errors early.</p>"},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/#agent-instructions","title":"Agent Instructions","text":"<p>Package Helm charts and publish to GitHub Pages charts directory. Maintain index.yaml with all chart versions. Charts are served via GitHub Pages and can be added to Helm with 'helm repo add'. Keep charts directory in gh-pages branch synchronized with releases. Never delete old chart versions - users may be pinned to specific versions. When values.yaml changes in any chart, regenerate the corresponding JSON schema for that chart's values to keep schemas in sync with supported configuration options.</p>"},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/#use-external-chart-registry-chartmuseum-harbor","title":"Use external chart registry (ChartMuseum, Harbor)","text":"<p>Additional infrastructure to maintain. Costs money. GitHub Pages is free and reliable.</p>"},{"location":"decisions/generated-markdown/030-helm-charts-published-to-github-pages-oci-registry/#bundle-charts-in-git-repository-only","title":"Bundle charts in git repository only","text":"<p>Users would need to clone repo to get charts. No version discovery. Not standard Helm workflow.</p>"},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/","title":"ADR-031: Automated releases with release-please","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/#decision","title":"Decision","text":"<p>Automate release process using release-please. Releases are triggered by conventional commits and create GitHub releases, changelogs, and version bumps automatically.</p>"},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/#rationale","title":"Rationale","text":"<p>release-please eliminates manual release toil (changelog writing, version bumping, tag creation). Conventional commits provide machine-readable history for automatic version determination. Changelogs generated from commits stay accurate and complete. Separate versioning for operator and each Helm chart (via commit scopes). Release PRs provide review opportunity before publishing. Consistent release process reduces errors.</p>"},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/#agent-instructions","title":"Agent Instructions","text":"<p>Follow conventional commit format (covered in decision 011). release-please analyzes commits to determine version bumps (major/minor/patch). Never manually create releases or update version numbers. Let release-please handle changelog generation from commit messages. Review and merge release PRs created by release-please to trigger releases.</p>"},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/#manual-releases-with-hand-written-changelogs","title":"Manual releases with hand-written changelogs","text":"<p>Error-prone, time-consuming, changelogs drift from actual changes. Inconsistent versioning.</p>"},{"location":"decisions/generated-markdown/031-automated-releases-with-release-please/#semantic-release-or-other-tools","title":"Semantic-release or other tools","text":"<p>release-please better supports monorepo with multiple versioned components (operator + 3 charts).</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/","title":"ADR-032: Minimal RBAC with namespaced service accounts","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#decision","title":"Decision","text":"<p>Operator uses minimal RBAC permissions via service account. Operator chart creates SA with Role for its own namespace and ClusterRole for CRDs. Realm/Client charts create SAs with Roles for their namespaces only. RBAC is opt-in - operator has no access to user namespaces unless explicitly granted.</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#rationale","title":"Rationale","text":"<p>Least privilege security model. Operator can't access user namespaces by default - prevents accidental or malicious access to unrelated resources. Users explicitly grant access by deploying realm/client charts with RBAC in their namespace. This allows multi-tenant clusters where teams don't trust each other. ClusterRole limited to CRD management (non-sensitive). Namespace-specific Roles prevent privilege escalation. Audit trail shows exactly which namespaces granted operator access. Security teams can verify operator can't access their namespace without their consent.</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#agent-instructions","title":"Agent Instructions","text":"<p>When designing operator permissions, follow least privilege. Operator manages its own namespace (deployment, config) via Role. Operator manages CRDs cluster-wide via ClusterRole. Operator does NOT get blanket access to all namespaces. Realm and Client charts deployed in user namespaces create SAs that grant operator access to manage resources in those specific namespaces only. Users opt in to operator access by deploying realm/client charts in their namespace.</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#cluster-admin-permissions-for-operator","title":"Cluster-admin permissions for operator","text":"<p>Massive security risk. Operator could access any resource in cluster. Violates least privilege.</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#single-clusterrole-for-all-operations","title":"Single ClusterRole for all operations","text":"<p>Still too broad. Can't distinguish between operator's own namespace and user namespaces.</p>"},{"location":"decisions/generated-markdown/032-minimal-rbac-with-namespaced-service-accounts/#opt-out-model-where-operator-has-access-by-default","title":"Opt-out model where operator has access by default","text":"<p>Security-by-default is better than security-by-opt-out. Users should explicitly grant access.</p>"},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/","title":"ADR-033: Custom Resource Definitions as API","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/#decision","title":"Decision","text":"<p>Use Kubernetes Custom Resource Definitions (CRDs) as the API for managing Keycloak resources. All Keycloak configuration is declarative via CRD YAML manifests.</p>"},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/#rationale","title":"Rationale","text":"<p>CRDs are the Kubernetes-native way to extend the API. Provides declarative GitOps-friendly interface. kubectl works out of the box for managing resources. RBAC integrates natively. CRDs support validation, versioning, and schema evolution. Users already familiar with Kubernetes patterns. Eliminates need for custom API servers or CLIs. Works with all GitOps tools (ArgoCD, Flux) without special support.</p>"},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/#agent-instructions","title":"Agent Instructions","text":"<p>Define all Keycloak resource types as CRDs with OpenAPI schemas. Users interact with operator exclusively through CRDs - no CLI, no API endpoints, no webhooks for configuration. CRDs are the single source of truth. Design CRD schemas to be intuitive and map closely to Keycloak's native concepts. Note that admission webhooks for validation (not configuration) are acceptable and encouraged for better UX - see ADR-040 for details.</p>"},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/#rest-api-with-custom-api-server","title":"REST API with custom API server","text":"<p>Additional infrastructure to maintain. Doesn't integrate with kubectl or RBAC. Not GitOps-friendly.</p>"},{"location":"decisions/generated-markdown/033-custom-resource-definitions-as-api/#cli-tool-for-configuration","title":"CLI tool for configuration","text":"<p>Not declarative, can't version control configurations easily. Doesn't fit GitOps workflows.</p>"},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/","title":"ADR-034: GitHub Actions for CI and artifact publication","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/#decision","title":"Decision","text":"<p>Use GitHub Actions for all CI/CD pipelines: testing, building, publishing container images, Helm charts, documentation, and releases.</p>"},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/#rationale","title":"Rationale","text":"<p>GitHub Actions integrates natively with GitHub - no external CI setup needed. Free for public repos. Direct access to GitHub APIs for releases, comments, etc. GitHub Container Registry (ghcr.io) included. GitHub Pages publishing built-in. Secrets management integrated. Good marketplace of reusable actions. Workflows version-controlled alongside code. Eliminates external dependencies.</p>"},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/#agent-instructions","title":"Agent Instructions","text":"<p>Define CI/CD workflows in .github/workflows/. Use GitHub Actions for all automation - testing, building, publishing. Leverage GitHub's container registry (ghcr.io) for images, GitHub Pages for charts/docs. Don't introduce external CI systems. Keep workflows modular and reusable.</p>"},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/#jenkins-circleci-or-other-external-ci","title":"Jenkins, CircleCI, or other external CI","text":"<p>Additional infrastructure to maintain. Costs money. Extra authentication/secrets management.</p>"},{"location":"decisions/generated-markdown/034-github-actions-for-ci-and-artifact-publication/#gitlab-ci","title":"GitLab CI","text":"<p>Would require moving repository. GitHub Actions already available and sufficient.</p>"},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/","title":"ADR-035: Keycloak 25.0+ version support requirement","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/#decision","title":"Decision","text":"<p>Require Keycloak 25.0.0 or later. Operator validates Keycloak version and rejects unsupported versions. Default to latest stable Keycloak version (currently 26.4.x).</p>"},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/#rationale","title":"Rationale","text":"<p>Keycloak 25.0.0 introduced separate management interface (port 9000) which is required for proper health checks and metrics without impacting user traffic. Earlier versions lack this feature. Enforcing minimum version ensures consistent behavior and allows operator to depend on modern Keycloak features. Clear version requirement reduces support burden from incompatible configurations.</p>"},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/#agent-instructions","title":"Agent Instructions","text":"<p>Enforce minimum Keycloak version 25.0.0 in operator code. Update DEFAULT_KEYCLOAK_VERSION in constants.py to track latest stable. Add version validation in reconcilers. Document version requirements clearly. Reject Keycloak instances with versions &lt; 25.0.0 with clear error messages.</p>"},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/#support-all-keycloak-versions","title":"Support all Keycloak versions","text":"<p>Pre-25.0 lacks management port, forcing health checks on user-facing port. Different behavior paths increase complexity.</p>"},{"location":"decisions/generated-markdown/035-keycloak-25-0-version-support-requirement/#support-back-to-keycloak-20x","title":"Support back to Keycloak 20.x","text":"<p>Significant API changes between versions. Supporting multiple API versions increases maintenance burden.</p>"},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/","title":"ADR-036: Automated dependency updates with Dependabot and custom workflows","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/#decision","title":"Decision","text":"<p>Use Dependabot for Python and GitHub Actions dependencies. Use custom GitHub Action workflow to bump operator image tag in Helm chart values.yaml when new operator versions are released.</p>"},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/#rationale","title":"Rationale","text":"<p>Dependabot automates dependency updates for Python packages and GitHub Actions, reducing security vulnerabilities and keeping dependencies current. Automatic PRs make updates visible and reviewable. Custom workflow for Helm values ensures charts reference correct operator versions without manual updates. Separate concerns: Dependabot for general deps, custom workflow for operator-chart coupling.</p>"},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/#agent-instructions","title":"Agent Instructions","text":"<p>Configure Dependabot for Python dependencies (pyproject.toml) and GitHub Actions workflows. Maintain separate workflow that updates charts/keycloak-*/values.yaml with new operator image tags when operator releases are created. Review and merge Dependabot PRs regularly.</p>"},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/#manual-dependency-updates","title":"Manual dependency updates","text":"<p>Error-prone, easy to miss security updates, consumes developer time.</p>"},{"location":"decisions/generated-markdown/036-automated-dependency-updates-with-dependabot-and-custom-workflows/#renovate-or-other-dependency-bots","title":"Renovate or other dependency bots","text":"<p>Dependabot is GitHub-native, no additional setup needed. Sufficient for project needs.</p>"},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/","title":"ADR-037: Support for operator-managed and external Keycloak instances","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/#decision","title":"Decision","text":"<p>Support both operator-managed Keycloak (deployed by operator) and external Keycloak instances (pre-existing, managed outside operator). Users choose via CRD configuration.</p>"},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/#rationale","title":"Rationale","text":"<p>Operator-managed Keycloak provides easy getting-started experience and full lifecycle management. External Keycloak supports existing deployments, migrations, and cases where Keycloak is managed separately (different team, external service). Flexibility increases adoption - users not forced to adopt operator's Keycloak management to use realm/client automation. Allows gradual migration: start with external, migrate to operator-managed later.</p>"},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/#agent-instructions","title":"Agent Instructions","text":"<p>When designing Keycloak CRD, support both deployment modes. For operator-managed: include deployment spec (image, resources, database, etc.). For external: reference existing Keycloak via URL and credentials. Reconcilers must handle both cases. External Keycloak allows using existing instances without redeployment.</p>"},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/#only-operator-managed-keycloak","title":"Only operator-managed Keycloak","text":"<p>Forces users to redeploy existing Keycloak instances. High migration barrier. Can't use with external Keycloak services.</p>"},{"location":"decisions/generated-markdown/037-support-for-operator-managed-and-external-keycloak-instances/#only-external-keycloak","title":"Only external Keycloak","text":"<p>No getting-started path. Users must deploy Keycloak separately before using operator.</p>"},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/","title":"ADR-039: Token rotation and bootstrap flows","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/#decision","title":"Decision","text":"<p>Automatic token rotation with grace periods for zero-downtime updates. Bootstrap flows enable initial token creation without manual intervention. Tokens rotated 7 days before expiry with dual-token support during transition.</p>"},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/#rationale","title":"Rationale","text":"<p>Token rotation is security best practice. Long-lived tokens increase compromise risk. Automatic rotation 7 days before expiry prevents service disruptions. Grace period with dual tokens ensures zero downtime - old token works while clients migrate to new token. Bootstrap flows enable automated initial setup without manual token distribution. Prometheus metrics provide visibility into rotation health. Version tracking enables audit trail of token changes.</p>"},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/#agent-instructions","title":"Agent Instructions","text":"<p>Token rotation implemented in src/keycloak_operator/handlers/token_rotation.py. Daily timer checks tokens expiring within 7 days and rotates them. Rotated secrets contain both new token (token) and old token (token-previous) during grace period. Hourly cleanup removes old tokens after grace period expires. Bootstrap flows in tests/integration/test_token_bootstrap.py. Rotation tracked via Prometheus metrics. Tokens have version numbers that increment on rotation. Use SecretManager from src/keycloak_operator/utils/secret_manager.py for rotation operations.</p>"},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/#non-rotatable-tokens","title":"Non-rotatable tokens","text":"<p>Security risk. Compromised tokens can't be invalidated without recreating all resources.</p>"},{"location":"decisions/generated-markdown/039-token-rotation-and-bootstrap-flows/#manual-token-distribution-only","title":"Manual token distribution only","text":"<p>Doesn't scale. Error-prone. Slows down initial setup and emergency rotation.</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/","title":"ADR-040: Admission Webhooks for Resource Validation","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#decision","title":"Decision","text":"<p>Implement Kubernetes admission webhooks to validate Custom Resource specifications before they are persisted to etcd. Use cert-manager for TLS certificate management instead of Kopf's auto-managed webhooks (see ADR-065 for details).</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#rationale","title":"Rationale","text":"<p>Pydantic validation happens during reconciliation, which means: 1. Users see \"resource created successfully\" but it fails later 2. No immediate feedback on typos or invalid values 3. Poor user experience debugging failed resources</p> <p>Admission webhooks solve this by validating at admission time: 1. kubectl create fails immediately with clear error message 2. Users get instant feedback on what's wrong 3. Invalid resources never enter etcd 4. Better GitOps experience (ArgoCD shows validation errors immediately)</p> <p>Additionally, webhooks enable enforcement of: - Resource quotas (e.g., max realms per namespace) - Cross-resource constraints (e.g., one Keycloak instance per namespace) - Namespace-based authorization (before resource is created)</p> <p>Using cert-manager for certificates (instead of Kopf auto-management): - Kopf's auto-management depends on insights.ready_resources which doesn't complete - cert-manager is a standard Kubernetes pattern - Allows manual control over ValidatingWebhookConfiguration - See ADR-065 for full technical rationale</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#agent-instructions","title":"Agent Instructions","text":"<p>When implementing resource validation, use both Pydantic models (for type safety in code) AND admission webhooks (for early validation at K8s API boundary). Webhooks should validate specs synchronously and return clear error messages. Use kopf.on.validate decorators with explicit 'id' parameter for webhook paths. Ensure cert-manager is available for TLS certificate generation. Include readiness probe that checks webhook server port.</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#pydantic-validation-only","title":"Pydantic validation only","text":"<p>No immediate feedback to users. Resources appear created but fail during reconciliation. Poor UX for debugging.</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#use-kopf-auto-managed-webhooks-with-self-signed-certs","title":"Use Kopf auto-managed webhooks with self-signed certs","text":"<p>Kopf's auto-management depends on insights.ready_resources.wait() which never completes in our operator setup. See ADR-065 for details.</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#disable-webhooks-only-use-crd-openapi-schema-validation","title":"Disable webhooks, only use CRD OpenAPI schema validation","text":"<p>CRD validation is limited (no cross-resource checks, no quotas, no complex logic). Webhooks enable richer validation.</p>"},{"location":"decisions/generated-markdown/040-admission-webhooks-for-validation/#manual-certificate-management-without-cert-manager","title":"Manual certificate management without cert-manager","text":"<p>Requires custom rotation logic. cert-manager is a standard solution.</p>"},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/","title":"ADR-040: Ruff for formatting and linting","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/#decision","title":"Decision","text":"<p>Use Ruff for both code formatting and linting. Ruff replaces multiple tools (Black, isort, Flake8, etc.) with a single fast tool.</p>"},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/#rationale","title":"Rationale","text":"<p>Ruff is 10-100x faster than legacy Python linters. Single tool replaces Black (formatting), isort (imports), Flake8 (linting), pyupgrade, etc. Reduces dependencies and configuration complexity. Written in Rust for speed. Same team makes ty type checker - good ecosystem integration. Pre-commit hooks run faster with Ruff.</p>"},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/#agent-instructions","title":"Agent Instructions","text":"<p>Run 'ruff format' for code formatting. Run 'ruff check --fix' for linting. Configure Ruff in pyproject.toml. Use 'make format' and 'make lint' targets. Never introduce Black, isort, Flake8, or other legacy linters. Ruff handles all Python code quality checks.</p>"},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/#black-isort-flake8","title":"Black + isort + Flake8","text":"<p>Slow, multiple tools to configure and maintain. Ruff is drop-in replacement that's much faster.</p>"},{"location":"decisions/generated-markdown/040-ruff-for-formatting-and-linting/#pylint","title":"Pylint","text":"<p>Very slow, overly verbose. Ruff covers same checks with better performance.</p>"},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/","title":"ADR-041: Shared operator fixture in tests","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/#decision","title":"Decision","text":"<p>Use shared pytest fixture for operator deployment in integration tests. Single operator instance serves all integration tests to reduce setup time and resource usage.</p>"},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/#rationale","title":"Rationale","text":"<p>Deploying operator for every test is slow. Session-scoped fixture deploys once, amortizing cost across all tests. Reduces Kind cluster resource usage - single operator deployment vs dozens. Faster test suite execution. Tests remain isolated via namespace-scoped fixtures for resources. Operator reconciles resources in all namespaces so single instance can serve multiple test namespaces. Trade-off: Tests can't modify operator configuration, but that's rarely needed.</p>"},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/#agent-instructions","title":"Agent Instructions","text":"<p>Define operator fixture at session scope in conftest.py. Deploy operator once per test session, not per test. Use namespace fixtures for test isolation. Tests should be independent despite sharing operator. Clean up test resources between tests, not operator itself.</p>"},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/#deploy-operator-per-test","title":"Deploy operator per test","text":"<p>Very slow. Each test waits for operator deployment. Excessive resource usage in Kind cluster.</p>"},{"location":"decisions/generated-markdown/041-shared-operator-fixture-in-tests/#no-operator-mock-reconciliation","title":"No operator, mock reconciliation","text":"<p>Defeats purpose of integration tests. Need real operator behavior to catch bugs.</p>"},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/","title":"ADR-042: pytest-xdist for parallel integration tests","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/#decision","title":"Decision","text":"<p>Use pytest-xdist to run integration tests in parallel across multiple workers. Significantly reduces total test time.</p>"},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/#rationale","title":"Rationale","text":"<p>Integration tests are I/O bound (waiting for Kubernetes resources). Running in parallel utilizes CPU cores during wait times. pytest-xdist distributes tests across workers. 'auto' mode uses all available cores. Dramatically reduces total test time (e.g., 20 tests * 30s = 10min sequential vs 2min parallel with 10 cores). Better CI resource utilization. Tests must be designed for isolation anyway (different namespaces), making parallelization straightforward.</p>"},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/#agent-instructions","title":"Agent Instructions","text":"<p>Run integration tests with 'pytest -n auto' to use all CPU cores. Design tests to be parallel-safe (isolated namespaces, no shared state). Use xdist's worker-scoped fixtures when needed. Configure in pyproject.toml or pytest.ini.</p>"},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/#sequential-test-execution","title":"Sequential test execution","text":"<p>Wastes time and CI resources. Tests spend most time waiting for Kubernetes, not CPU bound.</p>"},{"location":"decisions/generated-markdown/042-pytest-xdist-for-parallel-integration-tests/#custom-parallel-test-runner","title":"Custom parallel test runner","text":"<p>Reinvents wheel. pytest-xdist is mature, well-maintained, handles edge cases.</p>"},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/","title":"ADR-043: Wait helpers with debug logging in tests","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/#decision","title":"Decision","text":"<p>Use wait helper functions in tests that provide detailed debug logs on timeout/failure instead of plain assertions. Logs show resource state, events, and reconciliation status.</p>"},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/#rationale","title":"Rationale","text":"<p>Plain assertions like 'assert resource.status.phase == \"Ready\"' fail with no context. When test fails in CI, developer has no information about why. Wait helpers with debug logging capture resource state, Kubernetes events, operator logs at time of failure. Makes CI failures debuggable without re-running locally. Logs show timing issues, reconciliation problems, dependency issues. Significantly reduces debug time.</p>"},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/#agent-instructions","title":"Agent Instructions","text":"<p>Use wait helpers from tests/integration/wait_helpers.py (wait_for_resource_ready, wait_for_resource_condition) that provide debug logs on timeout. Never use plain assertions without wait/retry logic. Helpers dump resource status, events, and operator logs on failure. Add context-specific debug information to aid troubleshooting.</p>"},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/#plain-assertions-without-wait-logic","title":"Plain assertions without wait logic","text":"<p>Flaky tests due to timing. No debug information on failure. Can't debug CI failures.</p>"},{"location":"decisions/generated-markdown/043-wait-helpers-with-debug-logging-in-tests/#manual-kubectl-debugging-after-failure","title":"Manual kubectl debugging after failure","text":"<p>Resource state is gone after test cleanup. Can't reproduce CI environment locally.</p>"},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/","title":"ADR-044: Extra manifests support in Helm charts","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/#decision","title":"Decision","text":"<p>All three Helm charts support extraManifests value to inject additional Kubernetes resources. Enables users to add custom resources without forking charts.</p>"},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/#rationale","title":"Rationale","text":"<p>Users often need to add supporting resources (monitoring, network policies, etc.) specific to their environment. Forking charts to add these creates maintenance burden. extraManifests provides escape hatch for custom resources. Common pattern in Helm ecosystem. Keeps charts flexible without bloating default manifests. Users maintain full control over additional resources through values.yaml.</p>"},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/#agent-instructions","title":"Agent Instructions","text":"<p>Add extraManifests value to all charts (operator, realm, client). Template renders them via 'tpl' function to allow value interpolation. Document in values.yaml with examples. Users can inject ServiceMonitors, NetworkPolicies, PodDisruptionBudgets, etc. without chart modifications.</p>"},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/#force-users-to-fork-charts","title":"Force users to fork charts","text":"<p>Creates maintenance burden. Users must rebase forks on chart updates. Discourages chart usage.</p>"},{"location":"decisions/generated-markdown/044-extra-manifests-support-in-helm-charts/#add-every-possible-resource-type-to-chart","title":"Add every possible resource type to chart","text":"<p>Charts become bloated. Can't anticipate all use cases. Increases complexity.</p>"},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/","title":"ADR-045: Active-standby HA using Kopf peering","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/#decision","title":"Decision","text":"<p>Support high availability via active-standby replication (replicas &gt; 1) using Kopf's built-in peering mechanism. One replica is active (leader), others are standby. Standby replicas take over if active fails. This is for availability, not workload capacity scaling.</p>"},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/#rationale","title":"Rationale","text":"<p>Kopf provides built-in active-standby HA via peering - minimal implementation effort. One active replica processes all events, standbys are ready to take over. Prevents downtime during upgrades or failures. Operator is stateless so failover is fast and safe. HA is justified for production environments where brief reconciliation pauses are unacceptable. Standby replicas are not wasted - they provide fault tolerance. Important distinction - this HA mechanism does NOT improve throughput or capacity. Keycloak API is almost certainly the bottleneck, not the operator.</p>"},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/#agent-instructions","title":"Agent Instructions","text":"<p>Operator supports active-standby HA via Kopf peering. Increasing replicas improves availability but does NOT increase reconciliation capacity.</p>"},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/#no-ha-single-replica-only","title":"No HA (single replica only)","text":"<p>Acceptable for dev/test but production environments benefit from availability during upgrades and failures.</p>"},{"location":"decisions/generated-markdown/045-active-standby-ha-using-kopf-peering/#active-active-with-work-distribution","title":"Active-active with work distribution","text":"<p>Very complex to implement. Risk of conflicts and split-brain. Kopf's active-standby is simpler and sufficient for availability needs.</p>"},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/","title":"ADR-046: Multiple operator support with explicit references","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/#decision","title":"Decision","text":"<p>Support multiple operator instances in same cluster. Each operator instance has unique OPERATOR_INSTANCE_ID. Resources track which operator instance created them via Keycloak resource attributes.</p>"},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/#rationale","title":"Rationale","text":"<p>Multiple operators needed for scaling (sharding by realm) or multi-tenancy (different teams run own operators). Ownership tracking via Keycloak attributes prevents conflicts - operators only touch resources they created. OPERATOR_INSTANCE_ID enables clear identification of which operator owns which resources. Enables gradual operator version rollouts (blue-green). Multi-tenant clusters can isolate operator instances by team/environment. Ownership validation prevents split-brain scenarios.</p>"},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/#agent-instructions","title":"Agent Instructions","text":"<p>Use ownership tracking from src/keycloak_operator/utils/ownership.py. Each operator deployment sets OPERATOR_INSTANCE_ID environment variable. Operators add ownership attributes to Keycloak resources: io.kubernetes.operator-instance, io.kubernetes.cr-namespace, io.kubernetes.cr-name. Use is_owned_by_this_operator() to check ownership before updates. Use create_ownership_attributes() when creating resources. Realm CRD has operatorRef field specifying which operator instance to use. Only reconcile resources owned by this instance or without ownership (for adoption).</p>"},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/#single-operator-per-cluster","title":"Single operator per cluster","text":"<p>Doesn't scale. Can't separate operator responsibilities. Forces all teams to share single operator instance.</p>"},{"location":"decisions/generated-markdown/046-multiple-operator-support-with-explicit-references/#implicit-operator-selection-via-namespace","title":"Implicit operator selection via namespace","text":"<p>Fragile. Namespace moves break association. Not explicit enough for security-critical decisions.</p>"},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/","title":"ADR-047: Managed Keycloak for quick start","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/#decision","title":"Decision","text":"<p>Provide managed Keycloak option (operator deploys Keycloak) for quick start experience. No separate Keycloak installation required to begin using operator.</p>"},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/#rationale","title":"Rationale","text":"<p>Managed Keycloak reduces time-to-first-value. Users can deploy operator and start creating realms/clients immediately without separate Keycloak setup. Lowers adoption barrier for evaluation and development. Operator can optimize Keycloak configuration for its use cases. Still support external Keycloak for production where Keycloak is managed separately. Best of both worlds.</p>"},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/#agent-instructions","title":"Agent Instructions","text":"<p>Implement Keycloak CRD deployment mode where operator manages full Keycloak lifecycle: deployment, configuration, upgrades. Provide sensible defaults for getting started. Include quickstart examples with managed Keycloak. Document both managed and external modes clearly.</p>"},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/#external-keycloak-only","title":"External Keycloak only","text":"<p>High barrier to entry. Users must deploy Keycloak manually before using operator. Complicates getting started.</p>"},{"location":"decisions/generated-markdown/047-managed-keycloak-for-quick-start/#managed-keycloak-only","title":"Managed Keycloak only","text":"<p>Doesn't support existing Keycloak deployments. Forces users to migrate.</p>"},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/","title":"ADR-048: Prometheus metrics exposure","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/#decision","title":"Decision","text":"<p>Expose Prometheus metrics from operator for monitoring reconciliation performance, API calls, rate limiting, and errors.</p>"},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/#rationale","title":"Rationale","text":"<p>Metrics enable monitoring operator health and performance. Track reconciliation lag, API bottlenecks, rate limiting impact. Alert on error rates or reconciliation failures. Prometheus is standard for Kubernetes monitoring. Metrics help capacity planning and troubleshooting. Essential for production operations.</p>"},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/#agent-instructions","title":"Agent Instructions","text":"<p>Expose Prometheus metrics on operator's metrics port. Track reconciliation duration, API calls, rate limit waits, errors, resource counts. Use labels for resource type, namespace, operation. Import from keycloak_operator.observability.metrics. See src/keycloak_operator/observability/metrics.py for available metrics.</p>"},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/#logging-only-no-metrics","title":"Logging only, no metrics","text":"<p>Logs don't aggregate easily. Can't graph trends or set numeric alerts. Poor visibility into system health.</p>"},{"location":"decisions/generated-markdown/048-prometheus-metrics-exposure/#custom-metrics-format","title":"Custom metrics format","text":"<p>Prometheus is Kubernetes standard. Custom format requires special tooling, reduces interoperability.</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/","title":"ADR-049: Horizontal scaling via multiple operator deployments (realm sharding)","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#decision","title":"Decision","text":"<p>Horizontal scaling of operator capacity is achieved by deploying multiple operator instances, each managing a different subset of realms. This mimics classic sharding but at the operator deployment level. HA replicas (ADR 45) are for availability only, not capacity scaling.</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#rationale","title":"Rationale","text":"<p>When operator reaches reconciliation capacity limits, deploy additional operators rather than adding more replicas to a single deployment. Each operator manages a different set of realms - effectively sharding by realm. This is simpler than implementing proper work distribution/sharding within a single operator deployment, and achieves the same result. Users configure CRs to reference specific operators. Known limitation - all operators still monitor all CRs cluster-wide, but only reconcile CRs that reference them. If monitoring overhead becomes an issue (unlikely for 99% of users - would require enormous clusters), there is no solution within this architecture. Keycloak API is almost certainly the bottleneck before operator capacity becomes an issue.</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#agent-instructions","title":"Agent Instructions","text":"<p>Horizontal scaling uses multiple operator deployments, each managing different realm subsets. Do not use HA replicas for capacity scaling.</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#use-ha-replicas-for-capacity-scaling","title":"Use HA replicas for capacity scaling","text":"<p>Active-standby HA (ADR 45) does not increase capacity - only one replica is active. Would require complex active-active work distribution.</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#implement-proper-sharding-within-single-operator","title":"Implement proper sharding within single operator","text":"<p>Much more complex to implement. Would still shard by realm, resulting in essentially the same architecture but requiring more configuration in CRs.</p>"},{"location":"decisions/generated-markdown/049-horizontal-scaling-via-multiple-operators/#namespace-scoped-operators-to-reduce-monitoring-overhead","title":"Namespace-scoped operators to reduce monitoring overhead","text":"<p>Loses ability to watch cross-namespace resources. Monitoring overhead is negligible compared to reconciliation work.</p>"},{"location":"decisions/generated-markdown/050-structured-json-logging/","title":"ADR-050: Structured JSON logging","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/050-structured-json-logging/#decision","title":"Decision","text":"<p>Use structured logging with JSON output format. Every log entry is valid JSON with consistent fields.</p>"},{"location":"decisions/generated-markdown/050-structured-json-logging/#rationale","title":"Rationale","text":"<p>JSON logs are machine-parseable. Log aggregation systems (ELK, Loki) can index and search JSON fields. Correlation IDs link related log entries across reconciliation cycles. Structured context (namespace, resource name) enables filtering. Consistent format across all logs simplifies tooling. Better than parsing plain text logs. Enables advanced queries and dashboards in log analysis tools.</p>"},{"location":"decisions/generated-markdown/050-structured-json-logging/#agent-instructions","title":"Agent Instructions","text":"<p>Configure Python logging to output JSON using structlog or similar. Include standard fields: timestamp, level, message, logger name, correlation IDs, resource info (namespace, name, kind). See src/keycloak_operator/observability/logging.py. Never use plain text logging. Add context fields for filtering and analysis.</p>"},{"location":"decisions/generated-markdown/050-structured-json-logging/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/050-structured-json-logging/#plain-text-logging","title":"Plain text logging","text":"<p>Hard to parse. Can't reliably extract fields. Log analysis requires complex regex. Doesn't scale.</p>"},{"location":"decisions/generated-markdown/050-structured-json-logging/#multiple-log-formats","title":"Multiple log formats","text":"<p>Inconsistent. Each format requires different parsers. Makes log aggregation harder.</p>"},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/","title":"ADR-051: Multi-stage Docker builds for minimal images","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/#decision","title":"Decision","text":"<p>Use multi-stage Docker builds to produce minimal production images. Build stage installs dependencies, final stage contains only runtime requirements.</p>"},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/#rationale","title":"Rationale","text":"<p>Multi-stage builds produce smaller images (100s of MB vs GBs). Smaller images = faster pulls, less storage, smaller attack surface. Build tools (gcc, make) not needed at runtime. Only ship runtime dependencies. Separates build-time and runtime concerns. Faster image pulls in production. Lower network costs. Better security (fewer packages = fewer vulnerabilities).</p>"},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/#agent-instructions","title":"Agent Instructions","text":"<p>Define Dockerfile with separate build and runtime stages. Build stage: install uv, sync all dependencies including dev/build tools. Runtime stage: copy only installed packages and application code. Use slim base images (python:3.13-slim). Don't include build tools, compilers, or dev dependencies in final image.</p>"},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/#single-stage-builds","title":"Single-stage builds","text":"<p>Large images with unnecessary build tools. Slower deployments. More security vulnerabilities.</p>"},{"location":"decisions/generated-markdown/051-multi-stage-docker-builds-for-minimal-images/#separate-build-and-runtime-dockerfiles","title":"Separate build and runtime Dockerfiles","text":"<p>Harder to maintain. Duplication. Multi-stage achieves same goal in single file.</p>"},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/","title":"ADR-052: Optimized Keycloak container for tests","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/#decision","title":"Decision","text":"<p>Integration tests use pre-built optimized Keycloak container that skips runtime build step. Standard Keycloak container does long build at startup; optimized container is pre-built.</p>"},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/#rationale","title":"Rationale","text":"<p>Standard Keycloak container runs 'kc.sh build' at startup, taking 30-60 seconds. This happens for every integration test deployment. Optimized container pre-runs build step, saving 30-60s per test run. Significantly faster test execution (minutes saved across test suite). Better CI resource utilization. Tests start Keycloak instantly instead of waiting for build.</p>"},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/#agent-instructions","title":"Agent Instructions","text":"<p>Maintain separate Dockerfile for test Keycloak image with build step completed. Publish to registry. Integration tests use optimized image via test fixtures. Document optimization in test README. Update test image when Keycloak version changes.</p>"},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/#use-standard-keycloak-image-in-tests","title":"Use standard Keycloak image in tests","text":"<p>Wastes 30-60s per test waiting for build. Multiplied across parallel tests = significant overhead.</p>"},{"location":"decisions/generated-markdown/052-optimized-keycloak-container-for-tests/#mock-keycloak","title":"Mock Keycloak","text":"<p>Defeats purpose of integration tests. Need real Keycloak to catch actual issues.</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/","title":"ADR-053: Error categorization - temporary vs permanent","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#decision","title":"Decision","text":"<p>All operator errors are categorized as temporary (retryable) or permanent (requires manual intervention). Temporary errors use exponential backoff with jitter. Permanent errors immediately move resource to Failed phase.</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#rationale","title":"Rationale","text":"<p>Clear error categorization prevents infinite retry loops on unfixable issues while allowing automatic recovery from transient failures. Temporary errors (network glitches, API throttling) retry automatically with exponential backoff and jitter to prevent thundering herd. Permanent errors (spec validation, RBAC denial) fail fast and provide actionable guidance for manual resolution. This matches Kopf's error handling model (kopf.TemporaryError vs kopf.PermanentError). User action messages guide operators to resolution. Exponential backoff with jitter prevents API overload during mass reconciliation after outages.</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#agent-instructions","title":"Agent Instructions","text":"<p>Use error classes from src/keycloak_operator/errors/operator_errors.py. Temporary errors: network issues, rate limits, transient API failures - these auto-retry with exponential backoff. Permanent errors: validation failures, RBAC issues, invalid configuration - these require manual fix. All errors inherit from OperatorError base class. Use as_kopf_error() to convert to kopf.TemporaryError or kopf.PermanentError. Include user_action in error messages to guide resolution. HTTP 4xx = permanent, 5xx = temporary. Network timeouts = temporary. Validation = permanent.</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#retry-all-errors-indefinitely","title":"Retry all errors indefinitely","text":"<p>Would waste resources retrying unfixable issues like validation errors or RBAC denials. No user feedback on permanent problems.</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#never-retry-errors-automatically","title":"Never retry errors automatically","text":"<p>Would require manual intervention for transient network issues. Poor operational experience during temporary outages.</p>"},{"location":"decisions/generated-markdown/053-error-categorization-temporary-vs-permanent/#fixed-retry-delays-without-backoff","title":"Fixed retry delays without backoff","text":"<p>Creates thundering herd when many reconcilers retry simultaneously after connection resumes.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/","title":"ADR-054: Namespace watch scope requires cluster-wide RBAC","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#decision","title":"Decision","text":"<p>Operator watches all namespaces by default (cluster-wide mode) but can be restricted to specific namespaces via KEYCLOAK_OPERATOR_NAMESPACES environment variable. Regardless of watch scope restriction, operator always requires ClusterRole permissions because CRDs are cluster-scoped resources and ClusterKopfPeering is required for leader election. No label-based namespace selection.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#rationale","title":"Rationale","text":"<p>Cluster-wide operation by default enables dynamic provisioning - teams can create resources in any namespace without operator reconfiguration. Environment variable configuration supports restricted deployments where operator should only manage specific namespaces (multi-tenant clusters, security boundaries). Explicit namespace list (no labels) provides clear, auditable scope. Simpler than label-based selection - no watching namespace objects, no dynamic discovery complexity. Kopf natively supports both modes (clusterwide=True vs namespaces=list). RBAC enforcement at Kubernetes level prevents unauthorized access regardless of watch scope. Note that even with restricted watch scope, operator cannot be deployed with namespace-scoped RBAC only, because CRDs are cluster-scoped resources requiring ClusterRole for watching, and ClusterKopfPeering is required for leader election in HA deployments. This differs from controllers like nginx-ingress which use built-in Kubernetes resources (Ingress) rather than CRDs.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#agent-instructions","title":"Agent Instructions","text":"<p>Default behavior: operator watches all namespaces (clusterwide=True in Kopf). To restrict: set KEYCLOAK_OPERATOR_NAMESPACES environment variable to comma-separated namespace list. Implementation in src/keycloak_operator/operator.py function get_watched_namespaces(). Kopf called with namespaces=list for restricted mode or clusterwide=True for all namespaces. Important: ClusterRole permissions are always required for CRD watching (list/get/watch), status updates, and ClusterKopfPeering for leader election. RBAC must grant access to watched namespaces via additional RoleBindings. No automatic label-based namespace discovery - explicit list only.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#always-watch-all-namespaces-only","title":"Always watch all namespaces only","text":"<p>Doesn't support restricted deployments where operator should only access specific namespaces for security/isolation.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#label-based-namespace-selection","title":"Label-based namespace selection","text":"<p>More complex - requires watching namespace objects, dynamic discovery. Harder to audit. Explicit list is clearer.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#helm-chart-value-for-namespace-list","title":"Helm chart value for namespace list","text":"<p>Requires operator restart to change scope. Environment variable allows runtime configuration without chart upgrade.</p>"},{"location":"decisions/generated-markdown/054-namespace-watch-scope-requires-cluster-rbac/#namespace-scoped-rbac-role-instead-of-clusterrole","title":"Namespace-scoped RBAC (Role instead of ClusterRole)","text":"<p>Technically impossible. CRDs are cluster-scoped resources that require ClusterRole permissions to watch. ClusterKopfPeering for leader election also requires cluster permissions. Even controllers using built-in resources (nginx-ingress) require ClusterRole for cluster-scoped resources like IngressClass. Pre-installing CRDs separately doesn't solve this - the operator still needs to watch them at cluster scope.</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/","title":"ADR-055: Container image registry and tagging strategy","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#decision","title":"Decision","text":"<p>Publish container images to GitHub Container Registry (ghcr.io). Use semantic version tags (major, minor, patch) plus latest tag. Support multi-arch builds (amd64, arm64).</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#rationale","title":"Rationale","text":"<p>GitHub Container Registry integrates with GitHub Actions, provides free hosting for public images, supports OCI standards. Semantic version tags enable users to pin to specific compatibility levels (major for breaking changes, minor for features, patch for fixes). Latest tag provides convenience for development but should not be used in production. Multi-arch support enables deployment on ARM-based Kubernetes (AWS Graviton, Raspberry Pi clusters). Digest pinning provides immutable image references for GitOps and security compliance. No Docker Hub to avoid rate limits and maintain single source of truth.</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#agent-instructions","title":"Agent Instructions","text":"<p>Primary registry: ghcr.io/vriesdemichael/keycloak-operator. Tagging strategy: latest (tracks main branch), vX (major), vX.Y (minor), vX.Y.Z (patch). Example: v1, v1.2, v1.2.3, latest. Multi-arch: linux/amd64, linux/arm64 via Docker buildx. Images built in GitHub Actions workflow .github/workflows/ci-cd.yml. Release tags trigger semantic version tags. Main branch pushes update latest tag. Use digest pinning in production: image@sha256:... instead of tags for reproducibility.</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#docker-hub-as-primary-registry","title":"Docker Hub as primary registry","text":"<p>Rate limiting on free tier. ghcr.io better integrated with GitHub workflow.</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#only-latest-tag","title":"Only latest tag","text":"<p>No way to pin to specific versions. Users can't control upgrade timing. Breaks GitOps version pinning.</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#only-amd64-architecture","title":"Only amd64 architecture","text":"<p>Excludes ARM-based deployments which are increasingly common (cost savings, edge computing).</p>"},{"location":"decisions/generated-markdown/055-container-image-registry-and-tagging/#quayio-or-other-registry","title":"Quay.io or other registry","text":"<p>Additional external dependency. ghcr.io is free, integrated, and sufficient.</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/","title":"ADR-056: No opinionated backup or secret management","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#decision","title":"Decision","text":"<p>Operator does not provide built-in backup/restore or secret encryption features. Recommend external tools and support integration via Helm chart extraManifests.</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#rationale","title":"Rationale","text":"<p>Secret management and backup strategies are organization-specific. Some use Vault, others AWS Secrets Manager, some Sealed Secrets. Forcing one approach reduces adoption. External Secrets Operator and Sealed Secrets are mature, well-maintained solutions - no need to reinvent. CNPG (decision 015) already provides robust database backups. Velero handles cluster-level backups including CRDs. Operator focuses on Keycloak management, not cross-cutting concerns. extraManifests (decision 044) provides integration point without coupling. Tool-agnostic design maximizes compatibility with existing infrastructure.</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#agent-instructions","title":"Agent Instructions","text":"<p>For secret management: recommend External Secrets Operator (ESO) or Sealed Secrets. Secrets from these tools can be referenced in CRD SecretKeySelector fields. For backups: recommend Velero for cluster backups, CNPG built-in backups for database. Operator does not implement backup CRDs. Users add required manifests (ExternalSecret, SealedSecret, VeleroBackup) via extraManifests in Helm charts. Document integration patterns in docs/ but do not enforce specific tools. Operator remains tool-agnostic.</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#build-backup-crds-into-operator","title":"Build backup CRDs into operator","text":"<p>Would require maintaining backup storage connectors (S3, GCS, Azure Blob). Duplicates Velero and CNPG functionality. Increases complexity.</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#integrate-specific-secret-manager-vault","title":"Integrate specific secret manager (Vault)","text":"<p>Vendor lock-in. Many organizations use different secret managers. ESO provides abstraction layer.</p>"},{"location":"decisions/generated-markdown/056-no-opinionated-backup-or-secret-management/#recommend-specific-tools-exclusively","title":"Recommend specific tools exclusively","text":"<p>Too opinionated. Users may have existing tool choices. Better to show integration patterns for multiple options.</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/","title":"ADR-057: CR data must be validated with Pydantic models","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#decision","title":"Decision","text":"<p>All Custom Resource data must be loaded into Pydantic models before use. Direct dictionary access to CR spec fields is prohibited. Type-safe Pydantic models enforce validation and provide IDE support.</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#rationale","title":"Rationale","text":"<p>Pydantic validation catches configuration errors at reconciliation start, not during Keycloak API calls. Type annotations enable IDE autocomplete and static analysis. Prevents typos in field names - spec[\"reamName\"] fails silently, realm_spec.realm_name catches typos. Enforces field constraints (required fields, value ranges, enum values). camelCase/snake_case conversion automatic via Pydantic aliases. Future schema changes handled in one place (models) instead of scattered dict access. Matches decision 013 (Pydantic for Keycloak API) - consistency throughout operator. Testing easier with typed models than dicts.</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#agent-instructions","title":"Agent Instructions","text":"<p>Always use KeycloakRealmSpec.model_validate(spec), KeycloakClientSpec.model_validate(spec), or KeycloakSpec.model_validate(spec) to load CR data. Never access spec fields directly as dict (spec[\"field\"]). Models in src/keycloak_operator/models/ provide type safety, validation, and camelCase/snake_case conversion. Example: realm_spec = KeycloakRealmSpec.model_validate(spec). Access fields via attributes: realm_spec.realm_name not spec[\"realmName\"]. Pydantic validates required fields, types, and constraints. Invalid specs raise ValidationError early. All handlers use this pattern - see src/keycloak_operator/handlers/realm.py line 346 and client.py line 350.</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#direct-dictionary-access-to-cr-spec","title":"Direct dictionary access to CR spec","text":"<p>No validation until Keycloak API rejects it. Typos undetected. No IDE support. Type errors caught at runtime not development time.</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#optional-validation-validate-if-convenient","title":"Optional validation (validate if convenient)","text":"<p>Inconsistent. Some handlers validate, others don't. Leads to runtime errors in some paths.</p>"},{"location":"decisions/generated-markdown/057-cr-data-validated-with-pydantic/#json-schema-validation-only","title":"JSON Schema validation only","text":"<p>CRD OpenAPI validation is first line of defense, but Pydantic provides Python-native types and IDE integration.</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/","title":"ADR-058: Single Keycloak version support (26.x)","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#decision","title":"Decision","text":"<p>Operator supports only Keycloak 26.x (currently 26.4.1). Multiple version support is planned but not implemented. Users must use the same Keycloak version as defined in DEFAULT_KEYCLOAK_IMAGE constant.</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#rationale","title":"Rationale","text":"<p>Single version support simplifies development - no API compatibility matrix, no feature detection, no version-specific code paths. Keycloak API relatively stable within major versions but changes between majors. Supporting multiple versions requires testing each Keycloak version, maintaining compatibility shims, detecting feature availability. Resources better spent on core features now. Users can pin operator version matching their Keycloak version. When multi-version support added, it will be a planned feature (decision 008 feature parity). Current approach: stay on latest Keycloak version, update operator when Keycloak updates.</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#agent-instructions","title":"Agent Instructions","text":"<p>Current supported version: 26.4.1 (see DEFAULT_KEYCLOAK_IMAGE in src/keycloak_operator/constants.py). Minimum version: 25.0.0 for management port (decision 018). Operator assumes 26.x API and features. When Keycloak releases new versions, update DEFAULT_KEYCLOAK_IMAGE constant. Test against new version before updating. Multiple version support planned but blocked by API compatibility testing and feature detection needs. Reject version mismatches with clear error messages. Document supported version in README and Helm chart.</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#support-all-keycloak-versions-250","title":"Support all Keycloak versions 25.0+","text":"<p>Requires extensive compatibility testing. API differences between versions need conditional code. Feature detection complexity.</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#no-version-enforcement","title":"No version enforcement","text":"<p>Silent failures when API changes. Confusing error messages. Operator assumes features present.</p>"},{"location":"decisions/generated-markdown/058-single-keycloak-version-support/#support-only-latest-major-27x-when-it-releases","title":"Support only latest major (27.x when it releases)","text":"<p>Forces users to upgrade Keycloak before operator. Breaking for existing deployments.</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/","title":"ADR-059: No managed Keycloak upgrades","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#decision","title":"Decision","text":"<p>Operator does not support upgrading managed Keycloak instances. Users must manually upgrade Keycloak or redeploy with new version. Automated upgrades are planned but blocked by database migration complexity.</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#rationale","title":"Rationale","text":"<p>Keycloak version upgrades require database schema migrations which can fail or cause downtime. Operator cannot safely orchestrate: backup before migration, migration execution, rollback on failure, verification. Database migration is Keycloak's responsibility - operator should not reimplement. Users need control over upgrade timing for production systems (maintenance windows, testing). Automated upgrades risk data loss or corruption if migration fails. CNPG (decision 015) handles database backups but not Keycloak-specific migrations. Better to provide clear manual process than risky automation. Future: could add upgrade CRD with explicit user confirmation, backup orchestration, migration monitoring.</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#agent-instructions","title":"Agent Instructions","text":"<p>Operator creates Keycloak instances with specific version (DEFAULT_KEYCLOAK_IMAGE). Changing keycloak.image in CR spec does not trigger automatic upgrade. Operator does not handle Keycloak database schema migrations between versions. Document manual upgrade process: backup database, update image, run Keycloak migrations, verify. If upgrade support requested, explain it is planned but requires database migration orchestration. External Keycloak instances (decision 037) handle their own upgrades.</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#automatic-upgrades-on-image-change","title":"Automatic upgrades on image change","text":"<p>Dangerous - no backup, no rollback, no user confirmation. Database migration failures could corrupt data.</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#blue-green-deployment-for-upgrades","title":"Blue-green deployment for upgrades","text":"<p>Requires duplicate database (Keycloak shares schema). Complex migration coordination. Wastes resources during upgrade.</p>"},{"location":"decisions/generated-markdown/059-no-managed-keycloak-upgrades/#helm-chart-upgrade-handles-it","title":"Helm chart upgrade handles it","text":"<p>Helm doesn't orchestrate database migrations. Would still need operator logic for safe upgrades.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/","title":"ADR-060: Cascading deletes for dependent resources","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#decision","title":"Decision","text":"<p>Deletes cascade from Keycloak to Realms to Clients. When parent resource is deleted, operator automatically deletes dependent child resources. Finalizers ensure proper cleanup order.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#rationale","title":"Rationale","text":"<p>Cascading deletes prevent orphaned resources and ensure clean removal. Deleting Keycloak should remove all dependent Realms and Clients - users expect this behavior. Deleting Realm should remove all its Clients. Manual deletion of each resource is tedious and error-prone. Finalizers guarantee cleanup happens before CR removal - prevents Kubernetes deleting CR before Keycloak cleanup completes. Order matters: Clients deleted before Realms (clients depend on realms), Realms deleted before Keycloak. Finalizer removal on children prevents deadlock - child cleanup already done by parent, so skip child finalizer logic. Matches Kubernetes patterns (OwnerReferences with cascade) but implemented manually for cross-namespace support.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#agent-instructions","title":"Agent Instructions","text":"<p>Cascading delete order: Keycloak \u2192 Realms \u2192 Clients. Implementation in src/keycloak_operator/services/keycloak_reconciler.py (_delete_dependent_resources) and realm_reconciler.py (realm cleanup). Keycloak deletion: finds and deletes all KeycloakRealm CRs referencing it, then KeycloakClient CRs. Realm deletion: deletes clients from Keycloak, then deletes KeycloakClient CRs referencing the realm. Finalizers (KEYCLOAK_FINALIZER, REALM_FINALIZER, CLIENT_FINALIZER from src/keycloak_operator/constants.py) prevent deletion until cleanup completes. Child CR finalizers removed before deletion to prevent deadlock. Cascading delete logged with \"Cascading deletion:\" prefix.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/060-cascading-deletes/#no-cascading-deletes-manual-cleanup-required","title":"No cascading deletes - manual cleanup required","text":"<p>User must remember to delete Clients, then Realms, then Keycloak. Easy to orphan resources. Poor UX.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#kubernetes-ownerreferences-for-cascading","title":"Kubernetes OwnerReferences for cascading","text":"<p>OwnerReferences don't work across namespaces. Realms and Clients can be in different namespaces than Keycloak.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#delete-children-first-fail-parent-delete-if-children-exist","title":"Delete children first, fail parent delete if children exist","text":"<p>Forces specific deletion order. User must delete Clients, wait, delete Realms, wait, delete Keycloak. Tedious.</p>"},{"location":"decisions/generated-markdown/060-cascading-deletes/#background-garbage-collection","title":"Background garbage collection","text":"<p>Delay between parent deletion and child cleanup. Orphaned resources visible temporarily. Less deterministic.</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/","title":"ADR-061: GitHub Issues for planned work with AI agent instructions","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#decision","title":"Decision","text":"<p>All planned work tracked in GitHub Issues with dedicated \"AI Instructions\" section. Work done in feature branches linked to issues. AI agents implement issues with human guidance, then open PRs with auto-rebase on completion.</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#rationale","title":"Rationale","text":"<p>GitHub Issues provide structured planning with visibility and tracking. AI Instructions field guides agents with context-specific hints (modules to focus on, constraints, known issues). Reduces back-and-forth by frontloading guidance. Feature branches isolate work-in-progress from main. Auto-rebase keeps history clean without manual intervention. Human verification before PR prevents premature merging. Auto-merge after checks pass reduces manual overhead while ensuring CI validates changes. Issue linking provides traceability from problem to solution. Standardized workflow enables consistent collaboration between humans and AI agents.</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#agent-instructions","title":"Agent Instructions","text":"<p>GitHub Issues are the single source of truth for planned work. Issue template at .github/ISSUE_TEMPLATE/issue.yml includes \"AI Instructions\" field for agent-specific guidance (line 43-52). Workflow: 1) Create issue with description and AI instructions, 2) Create feature branch linked to issue, 3) AI agent implements following instructions, asking user for missing input/decisions, 4) Human verifies work, 5) AI opens PR with auto-rebase (gh pr merge --auto --rebase), 6) PR auto-merges when checks pass. Branch naming: feature/issue-123-description or fix/issue-123-description. PR title references issue: \"feat: implement X (#123)\".</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#work-directly-on-main-branch","title":"Work directly on main branch","text":"<p>No isolation for WIP. Risky - broken code affects everyone. Can't review before merge.</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#manual-pr-merging","title":"Manual PR merging","text":"<p>Requires human to monitor CI and click merge. Wastes time. Auto-merge with checks is safer and faster.</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#no-ai-instructions-field-in-issues","title":"No AI Instructions field in issues","text":"<p>Agents lack context. More questions, slower implementation. AI Instructions provide upfront guidance.</p>"},{"location":"decisions/generated-markdown/061-github-issues-with-ai-instructions/#linear-or-jira-for-issue-tracking","title":"Linear or Jira for issue tracking","text":"<p>GitHub Issues integrates with PRs, code, CI. External tools add friction. GitHub native is simpler.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/","title":"ADR-062: One Keycloak instance per operator deployment","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#decision","title":"Decision","text":"<p>Each operator deployment manages exactly one Keycloak instance. Default Helm chart deploys managed Keycloak alongside operator in same namespace. External Keycloak instances supported as alternative.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#rationale","title":"Rationale","text":"<p>One-to-one mapping simplifies operator configuration and reduces complexity. Operator maintains single admin connection, single rate limiter, single health check target. Multi-Keycloak support would require connection pooling, per-instance rate limiting, complex failover logic. Users needing multiple Keycloak instances deploy multiple operators (horizontal scaling per decision 045). Managed Keycloak in same namespace enables quick start - single Helm install gets working system. External Keycloak supports production deployments where Keycloak managed separately. Clear 1:1 relationship simplifies troubleshooting and RBAC. Operator namespace contains everything for that Keycloak instance - clean isolation.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#agent-instructions","title":"Agent Instructions","text":"<p>Operator manages one Keycloak instance only. Chart default (keycloak.enabled=false in charts/keycloak-operator/values.yaml line 240) deploys operator without managed Keycloak - expects external instance. Set keycloak.enabled=true to deploy managed Keycloak in operator namespace. Realms and Clients reference their Keycloak instance via keycloak_instance field (src/keycloak_operator/models/realm.py line 718, client.py line 517). Multiple Keycloak instances require multiple operator deployments. Decision 037 covers external vs managed Keycloak. Decision 047 covers managed Keycloak for quick start.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#one-operator-manages-multiple-keycloak-instances","title":"One operator manages multiple Keycloak instances","text":"<p>Complex connection management. Rate limiter shared across instances or per-instance complexity. Health checks for N instances. Configuration explosion.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#global-operator-manages-all-keycloak-instances-cluster-wide","title":"Global operator manages all Keycloak instances cluster-wide","text":"<p>Single point of failure. No isolation between Keycloak instances. RBAC and security boundaries unclear. Scaling bottleneck.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#always-require-managed-keycloak-no-external-option","title":"Always require managed Keycloak (no external option)","text":"<p>Doesn't support existing Keycloak deployments. Forces specific deployment pattern. Reduces flexibility.</p>"},{"location":"decisions/generated-markdown/062-one-keycloak-per-operator/#never-deploy-managed-keycloak-external-only","title":"Never deploy managed Keycloak (external only)","text":"<p>No quick start path. Users must deploy Keycloak separately before using operator. Higher barrier to entry.</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/","title":"ADR-063: Namespace grant list authorization for clients","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#decision","title":"Decision","text":"<p>Replace dual-token authorization model with declarative namespace grant list approach. Realm creation is unrestricted (controlled only by Kubernetes RBAC). Client creation requires explicit namespace authorization via clientAuthorizationGrants list in realm spec. No user-facing tokens required - authorization is purely declarative and GitOps-native.</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#rationale","title":"Rationale","text":"<p>The dual-token authorization model created complexity and deviated from GitOps principles: Problems with token-based auth: - Complexity: Token generation, distribution, rotation lifecycle - Manual intervention: Platform team distributing secrets - Cross-namespace coordination: Secret syncing between namespaces - Not GitOps-native: Secrets don't belong in Git, rotation causes drift - Team churn: Long-lived credentials outlive team membership Benefits of grant list approach: - Simplicity: No token management at all for users - GitOps-native: Authorization as declarative list in realm manifest - PR workflow: Access control through standard code review - Clear ownership: Realm team explicitly controls client access - Audit trail: Git history shows all access changes - Self-service: Teams create realms without platform intervention - Kubernetes-native: Follows RBAC patterns, integrates with existing security model Capacity management addresses operational scaling: - Operators can set maxRealms limit to prevent resource exhaustion - allowNewRealms flag enables graceful capacity handling - Existing realms continue working when capacity reached - Clear messaging guides users to alternative operators Trade-offs: - Realm teams maintain grant lists (added overhead) - Requires cross-namespace read permissions for operator - Revocation only blocks new clients, existing continue (by design) This aligns with ADR 003 (least privilege), ADR 004 (GitOps-first), ADR 005 (no plaintext secrets), ADR 016 (multi-namespace), and ADR 017 (K8s RBAC over Keycloak security).</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#agent-instructions","title":"Agent Instructions","text":"<p>When implementing client reconciliation, always fetch the referenced realm CR and validate that the client's namespace is present in spec.clientAuthorizationGrants. Reject client creation/update if namespace not in grant list. For realm reconciliation, validate capacity limits before creating new realms. Never implement user-facing token generation, distribution, or validation - all authorization is through grant lists. Status fields must reflect current authorization state (authorizedClientNamespaces in realm, authorizationStatus in client).</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#keep-dual-token-model-with-improvements","title":"Keep dual-token model with improvements","text":"<p>Still requires secret distribution and management. Doesn't solve fundamental GitOps incompatibility. Complexity remains even with better tooling.</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#use-admission-webhooks-for-validation","title":"Use admission webhooks for validation","text":"<p>Adds infrastructure complexity. Grant list in CRD is simpler and equally effective. Webhooks better suited for more complex validation logic we don't need here.</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#per-namespace-operators-instead-of-grant-lists","title":"Per-namespace operators instead of grant lists","text":"<p>Doesn't enable cross-namespace client provisioning. Requires multiple operator deployments. Goes against ADR 016 (multi-namespace by default).</p>"},{"location":"decisions/generated-markdown/063-namespace-grant-list-authorization/#keycloaks-built-in-authorization","title":"Keycloak's built-in authorization","text":"<p>Conflicts with ADR 017 (K8s RBAC over Keycloak security). Creates dual authentication layer. Not GitOps compatible. Operator would need Keycloak admin credentials.</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/","title":"ADR-064: No force-delete annotation for finalizers","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#decision","title":"Decision","text":"<p>No force-delete annotation for stuck finalizers. Users manually remove finalizers with kubectl patch when Keycloak is permanently unavailable. Standard Kubernetes pattern documented in troubleshooting guide.</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#rationale","title":"Rationale","text":"<p>Industry standard approach (cert-manager, CloudNativePG, most operators rely on manual kubectl patch). Zero maintenance burden. Finalizers protect against data leaks - automatic removal contradicts their purpose. Manual removal forces user acknowledgment of consequences (orphaned realms/clients in Keycloak). Standard kubectl patch command is well-documented and universally available. Feature can be added later if proven necessary through usage patterns.</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#agent-instructions","title":"Agent Instructions","text":"<p>Do not implement force-delete annotations or timeout-based finalizer removal. When users report stuck resources, direct them to troubleshooting documentation for manual finalizer removal. Finalizers exist to prevent orphaned resources in Keycloak - removing them is user's explicit responsibility.</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#immediate-force-delete-annotation","title":"Immediate force-delete annotation","text":"<p>Too dangerous - no safety net, encourages careless usage, leaves orphaned resources in Keycloak without attempting cleanup.</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#timeout-based-automatic-cleanup-zalando-postgresql-pattern","title":"Timeout-based automatic cleanup (Zalando PostgreSQL pattern)","text":"<p>Added complexity for rare edge case. Users can manually patch immediately if needed rather than waiting for timeout. Maintenance burden not justified by infrequent use.</p>"},{"location":"decisions/generated-markdown/064-no-force-delete-annotation/#two-step-confirmation-annotation","title":"Two-step confirmation annotation","text":"<p>Overly complex UX. Manual kubectl patch is simpler and achieves same result with clear user responsibility.</p>"},{"location":"decisions/generated-markdown/065-webhook-certificate-management-with-cert-manager/","title":"ADR-065: Webhook certificate management with cert-manager","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/065-webhook-certificate-management-with-cert-manager/#decision","title":"Decision","text":"<p>Use cert-manager for admission webhook TLS certificate management instead of Kopf's built-in auto-management.</p>"},{"location":"decisions/generated-markdown/065-webhook-certificate-management-with-cert-manager/#rationale","title":"Rationale","text":"<p>Kopf's webhook auto-management depends on insights.ready_resources.wait() which never completes in our operator setup, causing the webhook server to wait indefinitely. cert-manager provides: (1) Reliable certificate rotation without manual intervention, (2) Standard Kubernetes pattern widely used in production, (3) Decoupling from Kopf's internal systems, (4) Better observability through Kubernetes resources, (5) Battle-tested in production environments. Trade-off: Requires cert-manager as an additional cluster dependency and more complex initial setup with additional Kubernetes resources.</p>"},{"location":"decisions/generated-markdown/065-webhook-certificate-management-with-cert-manager/#agent-instructions","title":"Agent Instructions","text":"<p>When configuring admission webhooks, always use cert-manager to generate and rotate TLS certificates. Do not use Kopf's auto-management features. Webhook configurations must be managed manually via Helm templates.</p>"},{"location":"decisions/generated-markdown/066-centralized-settings-with-pydantic/","title":"ADR-066: Centralized settings management with pydantic-settings","text":"<p>Category: architecture Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/066-centralized-settings-with-pydantic/#decision","title":"Decision","text":"<p>Use pydantic-settings for centralized operator configuration instead of scattered os.getenv calls throughout the codebase.</p>"},{"location":"decisions/generated-markdown/066-centralized-settings-with-pydantic/#rationale","title":"Rationale","text":"<p>Scattered os.getenv calls throughout the codebase lead to: (1) Inconsistent parsing and validation, (2) Difficult discovery of available configuration options, (3) Type safety issues, (4) Hard to test with mocked configurations, (5) No central documentation of settings. pydantic-settings provides: (1) Automatic type validation and coercion, (2) Single source of truth for all configuration, (3) Better IDE support with autocomplete, (4) Easy testing with model instances, (5) Built-in documentation through Field descriptions, (6) Support for .env files and multiple sources, (7) Validation errors with clear messages. Trade-off: Minimal - pydantic-settings was already a dependency, just not utilized properly.</p>"},{"location":"decisions/generated-markdown/066-centralized-settings-with-pydantic/#agent-instructions","title":"Agent Instructions","text":"<p>When adding new configuration options, add them to the Settings class in src/keycloak_operator/settings.py. Never use os.getenv directly in other modules. Import settings from the settings module instead. All environment variables must be documented in the Settings class with Field descriptions.</p>"},{"location":"decisions/generated-markdown/067-integration-test-coverage-via-sigusr1/","title":"ADR-067: Integration test coverage collection via SIGUSR1 signal","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/067-integration-test-coverage-via-sigusr1/#decision","title":"Decision","text":"<p>Coverage data from integration tests running in Kubernetes pods must be collected using SIGUSR1 signal handling rather than relying on process termination. The operator registers a signal handler that flushes coverage data on demand, allowing retrieval while the process continues running.</p>"},{"location":"decisions/generated-markdown/067-integration-test-coverage-via-sigusr1/#rationale","title":"Rationale","text":"<p>Kubernetes termination issues: When pods are deleted, atexit handlers often don't run or coverage data is lost before retrieval. Signal-based approach: SIGUSR1 allows explicit, controlled flushing while process continues running. Works with parallel tests: pytest-xdist's pytest_sessionfinish hook runs on controller node, ensuring single retrieval after all workers complete. Path differences: Host uses relative paths (src/keycloak_operator), container uses absolute paths (/app/src/keycloak_operator). Production safety: Signal handler only registers when COVERAGE_PROCESS_START env var is set, zero overhead in production. Combined coverage: Retrieval happens before cluster teardown, allowing combination of unit test and integration test coverage data. Current baseline: 54.5% combined coverage with integration tests contributing real operator execution paths.</p>"},{"location":"decisions/generated-markdown/067-integration-test-coverage-via-sigusr1/#agent-instructions","title":"Agent Instructions","text":"<p>When modifying integration test infrastructure, preserve the coverage collection mechanism. The operator listens for SIGUSR1 and calls coverage.save(). The pytest_sessionfinish hook in conftest.py triggers coverage retrieval by calling scripts/retrieve-coverage.sh, which sends SIGUSR1 to PID 1 in the operator pod, waits for flush, then retrieves files via kubectl cp. Never rely on atexit handlers for coverage in containerized tests - they're unreliable with Kubernetes pod termination. Coverage config differs between host (.coveragerc) and container (images/operator/coveragerc.container) due to different path structures.</p>"},{"location":"decisions/generated-markdown/068-always-recreate-test-cluster/","title":"ADR-068: Always recreate test cluster","text":"<p>Category: development Provenance: human</p>"},{"location":"decisions/generated-markdown/068-always-recreate-test-cluster/#decision","title":"Decision","text":"<p>Integration tests must always run on a freshly created Kind cluster. The \"cluster reuse\" workflow is abandoned in favor of reproducibility and reliability. The <code>make test</code> command will alias <code>make test-pre-commit</code> which performs a full teardown and setup.</p>"},{"location":"decisions/generated-markdown/068-always-recreate-test-cluster/#rationale","title":"Rationale","text":"<p>Cluster reuse and cleanup logic proved to be flaky and complex (\"messy cleanup\"). Recreating the cluster ensures a pristine environment for every test run, eliminating state leakage and \"works on my machine\" issues. While slower, it guarantees that test results are valid and reproducible. The build cache is enabled to mitigate some of the speed loss.</p>"},{"location":"decisions/generated-markdown/068-always-recreate-test-cluster/#agent-instructions","title":"Agent Instructions","text":"<p>Do not attempt to optimize testing by reusing existing clusters. Always expect and use the full teardown/setup cycle. The <code>make test</code> command is the single source of truth for running the full test suite.</p>"},{"location":"decisions/generated-markdown/069-documentation-schema-validation/","title":"ADR-069: Documentation schema validation in CI","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/069-documentation-schema-validation/#decision","title":"Decision","text":"<p>All documentation examples (Helm --set flags, values.yaml snippets, and CR instances) must be validated against their respective schemas in CI. The validation extracts references from markdown files and example YAML files, then validates them against values.schema.json for Helm charts and CRD openAPIV3Schema for custom resources.</p>"},{"location":"decisions/generated-markdown/069-documentation-schema-validation/#rationale","title":"Rationale","text":"<p>Documentation drift is a major source of user confusion. Users copy examples from docs that use incorrect field names (e.g., 'hostname' instead of 'host'), leading to runtime errors. By validating documentation against the actual schemas, we catch these mismatches before they reach users. The validation is automated and runs in CI to prevent regression.</p>"},{"location":"decisions/generated-markdown/069-documentation-schema-validation/#agent-instructions","title":"Agent Instructions","text":"<p>When adding documentation examples that include Helm values or CR snippets, ensure they use valid field names that exist in the corresponding schema. Run <code>uv run python scripts/lib/schema_validator.py</code> to check for validation errors before committing documentation changes. Fix any \"Unknown key\" or \"Unknown property\" errors by correcting the field names or updating the schema if the field is missing.</p>"},{"location":"decisions/generated-markdown/069-documentation-schema-validation/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/069-documentation-schema-validation/#manual-documentation-review","title":"Manual documentation review","text":"<p>Human review is error-prone and doesn't scale. Field names change over time and it's easy to miss a stale example buried in documentation.</p>"},{"location":"decisions/generated-markdown/069-documentation-schema-validation/#rendering-and-applying-examples-to-a-test-cluster","title":"Rendering and applying examples to a test cluster","text":"<p>Too slow for CI and requires a running cluster. Schema validation is faster and catches the same class of errors (invalid field names).</p>"},{"location":"decisions/generated-markdown/070-auto-discovery-for-schema-validation/","title":"ADR-070: Auto-discovery for schema validation","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/070-auto-discovery-for-schema-validation/#decision","title":"Decision","text":"<p>The schema validator auto-discovers validatable charts and CRD kinds from the filesystem rather than using hardcoded lists. Charts are discovered by scanning the charts/ directory for subdirectories containing values.schema.json. CRD kinds are discovered by parsing the CRD YAML files in charts/keycloak-operator/crds/.</p>"},{"location":"decisions/generated-markdown/070-auto-discovery-for-schema-validation/#rationale","title":"Rationale","text":"<p>Hardcoded lists of charts and CRD kinds require maintenance and can become stale. Auto-discovery ensures that new charts and CRDs are automatically validated without code changes. This follows the DRY principle - the source of truth is the filesystem structure, not duplicated constants in code.</p>"},{"location":"decisions/generated-markdown/070-auto-discovery-for-schema-validation/#agent-instructions","title":"Agent Instructions","text":"<p>When adding a new Helm chart, ensure it has a values.schema.json file to be automatically included in documentation validation. When adding a new CRD, place it in charts/keycloak-operator/crds/ with the standard CRD structure (spec.names.kind must be defined). No code changes are needed to the validator when adding new charts or CRDs - they are discovered automatically.</p>"},{"location":"decisions/generated-markdown/071-crd-pydantic-schema-sync/","title":"ADR-071: CRD-Pydantic schema synchronization validation","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/071-crd-pydantic-schema-sync/#decision","title":"Decision","text":"<p>CRD openAPIV3Schema definitions must be validated against Pydantic model JSON schemas in CI. The validator extracts property paths from both schemas, normalizes snake_case to camelCase for comparison, and reports any fields that exist in one but not the other. This ensures the Kubernetes API (CRD) stays synchronized with the Python models.</p>"},{"location":"decisions/generated-markdown/071-crd-pydantic-schema-sync/#rationale","title":"Rationale","text":"<p>The CRD defines the Kubernetes API contract while Pydantic models define the Python representation. If these drift apart, the operator may fail to parse valid CRs or may expose fields in Python that don't exist in the API. Automated validation catches this drift early. The validator uses Pydantic's model_json_schema() to extract the Python schema and compares it to the CRD's openAPIV3Schema.</p>"},{"location":"decisions/generated-markdown/071-crd-pydantic-schema-sync/#agent-instructions","title":"Agent Instructions","text":"<p>When modifying Pydantic models in src/keycloak_operator/models/, ensure the corresponding CRD in charts/keycloak-operator/crds/ is updated to match. Run <code>make validate-crd-pydantic</code> to check for mismatches. Field names in Pydantic use snake_case while CRDs use camelCase - the validator handles this conversion automatically. Add new fields to both places or the CI will fail.</p>"},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/","title":"ADR-072: Handling unrecognized documentation snippets","text":"<p>Category: development Provenance: guided-ai</p>"},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/#decision","title":"Decision","text":"<p>When adding new code snippets to documentation, ensure they can be validated programmatically. The validation script categorizes snippets and validates them against appropriate schemas. Unrecognized snippets are flagged as warnings. For snippets that cannot be validated automatically, manually verify correctness before committing.</p>"},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/#rationale","title":"Rationale","text":"<p>Documentation drift causes user confusion when examples use incorrect field names or outdated structures. Programmatic validation catches most issues, but some snippets (external tools, partial configs) cannot be validated automatically. For these, we accept the limitation and require manual verification. The key is distinguishing between \"intentionally skipped\" (external/known) and \"unrecognized\" (potentially a validation gap).</p>"},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/#agent-instructions","title":"Agent Instructions","text":"<p>When adding documentation examples: 1. Validatable snippets - Add sufficient context for auto-detection:    - K8s resources: Include <code>apiVersion</code> and <code>kind</code>    - Helm values: Include recognizable top-level keys (operator, keycloak, etc.)    - CR examples: Include <code>apiVersion: vriesdemichael.github.io/v1</code> and <code>kind</code></p> <ol> <li>Partial snippets - Add detection hints when possible:</li> <li>For env arrays: Keep the <code>env:</code> key as wrapper</li> <li>For spec sections: Include the <code>spec:</code> wrapper</li> <li> <p>For config fragments: Include parent key context</p> </li> <li> <p>External/third-party snippets - These are intentionally skipped:</p> </li> <li>CNPG partial configs (bootstrap, backup, certificates)</li> <li>FluxCD, Prometheus, cert-manager resources</li> <li>ingress-nginx Helm values</li> <li> <p>Spring/application config examples</p> </li> <li> <p>Manual validation required - For snippets that can't be auto-validated:</p> </li> <li>Verify against official documentation before committing</li> <li>Document the source/reference in a comment if helpful</li> <li>Consider if the snippet can be restructured for validation</li> </ol> <p>Run <code>make validate-docs</code> or <code>uv run --group dev python scripts/lib/schema_validator.py</code> to check validation status. The script will warn about new unrecognized snippets.</p>"},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/#validate-everything-or-reject-unvalidatable-snippets","title":"Validate everything or reject unvalidatable snippets","text":"<p>Some documentation necessarily shows external tool configs (CNPG, FluxCD) that we don't control schemas for. Removing these would make docs incomplete.</p>"},{"location":"decisions/generated-markdown/072-handling-unrecognized-doc-snippets/#skip-validation-for-all-partial-snippets","title":"Skip validation for all partial snippets","text":"<p>Many partial snippets (env arrays, K8s affinity/resources) can be validated with proper schema extraction. Blanket skipping would miss validation opportunities.</p>"},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/","title":"ADR-073: Security and Multi-Tenancy Model","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/#decision","title":"Decision","text":"<p>Adopt a \"Realm-as-Tenant\" security model where the Operator has no privileged access to namespaces by default. Access is strictly opt-in: The Operator gains permissions within a namespace only when a Helm chart (Realm or Client) instantiates a RoleBinding for the Operator's ServiceAccount. Key components: 1. Operator has minimal global privileges (ClusterRoleBinding only for CRD metadata watch). 2. Namespace access is granted dynamically via RoleBindings created by the Realm/Client Helm charts. 3. Cross-namespace Client creation is authorized purely via <code>clientAuthorizationGrants</code> allowlists in the Realm CR, not by sharing secrets or tokens.</p>"},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/#rationale","title":"Rationale","text":"<p>This model enforces the Principle of Least Privilege. The Operator cannot read Secrets in a namespace unless explicitly authorized by that namespace's owner (via installing the Chart). Benefits: - Security: Compromise of the Operator does not automatically grant access to all secrets in the cluster, only those in \"opt-in\" namespaces. - Scalability: Decouples the Operator's permission set from the cluster size; no massive ClusterRole updates needed. - Maintainability: Permissions are managed declaratively alongside the resources (Realms/Clients) in GitOps. - Multi-Tenancy: Clear boundary where a Namespace equates to a Tenant (or part of one), managing its own access grants.</p>"},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/#agent-instructions","title":"Agent Instructions","text":"<p>When explaining security, always emphasize that the Operator is not omnipotent. It relies on the \"Realm-as-Tenant\" pattern. Do not suggest manually creating ClusterRoleBindings for the operator. Always direct users to use the Helm charts which handle the RBAC wiring automatically. When debugging \"Permission Denied\" errors for the operator, check for the existence of the <code>keycloak-operator-access</code> RoleBinding in the target namespace.</p>"},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/#global-operator-omnipotence-clusteradmin","title":"Global Operator Omnipotence (ClusterAdmin)","text":"<p>Violates least privilege. Gives the operator access to all Secrets in the cluster, which is a security risk.</p>"},{"location":"decisions/generated-markdown/073-security-and-multi-tenancy-model/#token-based-authentication-for-clients","title":"Token-based Authentication for Clients","text":"<p>Requires secret exchange and management, which is complex and not GitOps-friendly.</p>"},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/","title":"ADR-074: Keycloak Scalability and High Availability Strategy","text":"<p>Category: architecture Provenance: human</p>"},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/#decision","title":"Decision","text":"<p>Horizontal scaling of the managed Keycloak instance MUST be handled by the Keycloak application itself via proper clustering (JGroups/Infinispan), NOT by the Operator simply creating more unclustered replicas. For the current version of the Operator: 1. Operator-managed Keycloak instances are optimized for vertical scaling or simple Active-Standby (if supported). 2. For high-throughput horizontal scaling, users should configure an external Keycloak (managed outside the operator or by a dedicated Helm chart) that is properly clustered. 3. \"Naive scaling\" (increasing <code>spec.replicas</code> &gt; 1 without clustering config) is explicitly unsupported for production as it leads to split-brain states (sessions not shared).</p>"},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/#rationale","title":"Rationale","text":"<p>Keycloak is a stateful application requiring distributed caching (Infinispan) to share sessions and user states across replicas. Simply launching multiple Pods (replicas) without this discovery mechanism results in isolated instances, breaking authentication flows (e.g., login on Pod A, code exchange on Pod B fails). While the Operator handles K8s resources, configuring robust JGroups discovery (DNS_PING, KUBE_PING) and cache tuning is a complex application-level concern that is currently best handled by dedicated Helm charts or external management for high-scale needs.</p>"},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/#agent-instructions","title":"Agent Instructions","text":"<p>If a user asks how to scale Keycloak for high load, advise them that simply increasing replicas in the Keycloak CR is not sufficient for proper HA without clustering configuration. Recommend using an external Keycloak instance for massive horizontal scale requirements until the Operator natively supports full JGroups discovery and configuration. Clarify that the Operator's own HA (Kopf peering) is distinct from the Keycloak application's HA.</p>"},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/#rejected-alternatives","title":"Rejected Alternatives","text":""},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/#auto-scaling-replicas-without-clustering","title":"Auto-scaling Replicas without Clustering","text":"<p>Leads to broken user experience (session loss) due to lack of state synchronization.</p>"},{"location":"decisions/generated-markdown/074-keycloak-scalability-and-ha/#operator-automatically-configuring-jgroups","title":"Operator automatically configuring JGroups","text":"<p>Adds significant complexity to the Operator logic. Better to delegate this to the underlying Helm chart or external configuration for now.</p>"},{"location":"development/test-cleanup-strategy/","title":"Test Cleanup &amp; Cluster Reuse Strategy","text":""},{"location":"development/test-cleanup-strategy/#context","title":"Context","text":"<p>Discussion on 2025-10-27 about improving integration test workflow to enable cluster reuse for faster iterations.</p>"},{"location":"development/test-cleanup-strategy/#key-insight-what-actually-needs-resetting","title":"Key Insight: What Actually Needs Resetting?","text":"<p>Between test runs, we identified what truly needs to be cleaned:</p>"},{"location":"development/test-cleanup-strategy/#must-reset","title":"Must Reset","text":"<ol> <li>Keycloak instance \u2192 Contains polluted state (realms/clients from tests)</li> <li>Keycloak database (CNPG) \u2192 Contains all Keycloak state, must be wiped</li> <li>Test namespaces \u2192 Where test resources live</li> </ol>"},{"location":"development/test-cleanup-strategy/#does-not-need-reset","title":"Does NOT Need Reset","text":"<ol> <li>Operator \u2192 Unchanged unless code updates</li> <li>CRDs \u2192 Static, don't change between runs</li> <li>RBAC \u2192 Static permissions</li> <li>Operator namespace \u2192 Only auth token secret needs refresh</li> </ol>"},{"location":"development/test-cleanup-strategy/#current-problem","title":"Current Problem","text":"<p>The existing <code>clean-test-resources</code> script only cleans test namespaces with <code>test-</code> prefix. It does NOT: - Reset Keycloak instance state - Delete the CNPG database cluster - Clean operator namespace state</p> <p>This means cluster reuse leaves polluted Keycloak state.</p>"},{"location":"development/test-cleanup-strategy/#proposed-solution","title":"Proposed Solution","text":""},{"location":"development/test-cleanup-strategy/#new-script-scriptsclean-integration-statesh","title":"New Script: <code>scripts/clean-integration-state.sh</code>","text":"<p>Resets state WITHOUT tearing down cluster.</p>"},{"location":"development/test-cleanup-strategy/#refactored-makefile-structure","title":"Refactored Makefile Structure","text":"<p>Organize targets into logical sections for clarity.</p>"},{"location":"development/test-cleanup-strategy/#usage-patterns","title":"Usage Patterns","text":""},{"location":"development/test-cleanup-strategy/#first-run-or-after-code-changes","title":"First Run (or after code changes)","text":"<pre><code>make test-integration-fresh\n</code></pre>"},{"location":"development/test-cleanup-strategy/#subsequent-runs-faster-reuses-cluster","title":"Subsequent Runs (faster - reuses cluster)","text":"<pre><code>make clean-integration-state &amp;&amp; make test-integration\n</code></pre>"},{"location":"development/test-cleanup-strategy/#just-clean-stuck-resources","title":"Just clean stuck resources","text":"<pre><code>make clean-test-resources\n</code></pre>"},{"location":"development/test-cleanup-strategy/#benefits","title":"Benefits","text":"<p>\u2705 Fast iterations - No cluster rebuild (saves 2-3 minutes) \u2705 Clean state - Database truly reset, not just Keycloak restart \u2705 Clear workflow - Explicit targets for fresh vs reuse \u2705 Better organized - Makefile sections by purpose</p>"},{"location":"development/testing/","title":"Testing Guide","text":"<p>This guide explains the testing philosophy, infrastructure, and best practices for the Keycloak Operator project.</p>"},{"location":"development/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>The project maintains high test coverage with two complementary approaches:</p> <ul> <li>Unit Tests: Fast, isolated tests that mock external dependencies</li> <li>Integration Tests: Real-world tests on actual Kubernetes clusters</li> </ul> <p>Both are critical for maintaining code quality and preventing regressions.</p>"},{"location":"development/testing/#quick-start","title":"Quick Start","text":"<pre><code># Run all tests (quality + unit + integration)\nmake test\n\n# Run only unit tests (fast)\nmake test-unit\n\n# Run only integration tests\nmake test-integration\n\n# Pre-commit: fresh cluster + all tests\nmake test-pre-commit\n</code></pre>"},{"location":"development/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"development/testing/#what-to-test","title":"What to Test","text":"<p>Unit tests focus on business logic without external dependencies:</p> <ul> <li>\u2705 Data transformations (CRD spec \u2192 Keycloak API format)</li> <li>\u2705 Validation logic</li> <li>\u2705 Error handling</li> <li>\u2705 Utility functions</li> <li>\u2705 Pydantic model validation</li> </ul>"},{"location":"development/testing/#example-testing-a-reconciler","title":"Example: Testing a Reconciler","text":"<pre><code># tests/unit/test_realm_reconciler.py\nimport pytest\nfrom keycloak_operator.models.realm import KeycloakRealmSpec, RealmSecurity\nfrom keycloak_operator.services.realm_reconciler import RealmReconciler\n\n\n@pytest.mark.asyncio\nasync def test_build_realm_config():\n    \"\"\"Test realm configuration generation from spec.\"\"\"\n    reconciler = RealmReconciler()\n\n    spec = KeycloakRealmSpec(\n        realm_name=\"my-realm\",\n        security=RealmSecurity(\n            registration_allowed=True,\n            reset_password_allowed=False,\n        ),\n    )\n\n    config = reconciler._build_realm_config(spec)\n\n    assert config.realm == \"my-realm\"\n    assert config.registration_allowed is True\n    assert config.reset_credentials_allowed is False\n</code></pre>"},{"location":"development/testing/#mocking-best-practices","title":"Mocking Best Practices","text":"<pre><code>from unittest.mock import AsyncMock, MagicMock\n\n\n@pytest.fixture\ndef mock_keycloak_admin():\n    \"\"\"Mock Keycloak admin client.\"\"\"\n    mock = AsyncMock()\n    mock.get_realm.return_value = {\n        \"realm\": \"test\",\n        \"enabled\": True,\n    }\n    return mock\n\n\n@pytest.mark.asyncio\nasync def test_with_mock(mock_keycloak_admin):\n    \"\"\"Test using mocked client.\"\"\"\n    realm = await mock_keycloak_admin.get_realm(\"test\")\n    assert realm[\"realm\"] == \"test\"\n</code></pre>"},{"location":"development/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"development/testing/#test-infrastructure","title":"Test Infrastructure","text":"<p>Integration tests run on real Kubernetes clusters:</p> <pre><code>%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#00b8d9','primaryTextColor':'#fff','primaryBorderColor':'#0097a7','lineColor':'#00acc1','secondaryColor':'#006064','tertiaryColor':'#fff'}}}%%\ngraph TB\n    subgraph cluster[\"Kind Cluster (Test Env)\"]\n        cnpg[\"CloudNativePG operator\"]\n        postgres[\"PostgreSQL cluster\"]\n        keycloak[\"Keycloak instance&lt;br/&gt;(shared or dedicated)\"]\n        operator[\"Keycloak operator&lt;br/&gt;(via Helm)\"]\n    end\n\n    subgraph runner[\"Test Runner (Your Machine/CI)\"]\n        pytest[\"pytest with xdist&lt;br/&gt;(8 workers)\"]\n        portfwd[\"Port-forwards to Keycloak\"]\n        k8s[\"Kubernetes API access\"]\n    end\n\n    runner &lt;--&gt;|Port-forward| cluster\n\n    style cluster fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style runner fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style cnpg fill:#00838f,stroke:#006064,color:#fff\n    style postgres fill:#00838f,stroke:#006064,color:#fff\n    style keycloak fill:#00838f,stroke:#006064,color:#fff\n    style operator fill:#00838f,stroke:#006064,color:#fff\n    style pytest fill:#00838f,stroke:#006064,color:#fff\n    style portfwd fill:#00838f,stroke:#006064,color:#fff\n    style k8s fill:#00838f,stroke:#006064,color:#fff</code></pre>"},{"location":"development/testing/#setup-flow","title":"Setup Flow","text":"<ol> <li>Cluster Creation: Kind cluster created (if not exists)</li> <li>Operator Deployment: Installed via Helm with production-like setup</li> <li>Test Keycloak: Shared instance deployed (~60s startup)</li> <li>Test Execution: Tests run in parallel (8 workers)</li> <li>Cleanup: Resources cleaned up, cluster kept for next run</li> </ol>"},{"location":"development/testing/#shared-vs-dedicated-instances","title":"Shared vs Dedicated Instances","text":""},{"location":"development/testing/#shared-instance-recommended","title":"Shared Instance (Recommended)","text":"<p>Use for simple tests that don't modify global state:</p> <pre><code>@pytest.mark.integration\n@pytest.mark.timeout(300)\nasync def test_simple_client(\n    shared_operator,\n    test_namespace,\n    k8s_custom_objects,\n):\n    \"\"\"Test using shared Keycloak instance.\"\"\"\n    keycloak_name = shared_operator[\"name\"]\n    keycloak_namespace = shared_operator[\"namespace\"]\n\n    # Your test logic here\n    # Uses pre-deployed Keycloak (~60s startup amortized)\n</code></pre> <p>Benefits: - \u26a1 Fast (no Keycloak startup wait) - \ud83d\udcb0 Resource efficient - \u2705 Suitable for 80% of tests</p>"},{"location":"development/testing/#dedicated-instance","title":"Dedicated Instance","text":"<p>Use for complex tests requiring isolation:</p> <pre><code>@pytest.mark.integration\n@pytest.mark.timeout(600)  # Longer timeout\nasync def test_complex_feature(\n    test_namespace,\n    k8s_custom_objects,\n    sample_keycloak_spec,\n):\n    \"\"\"Test requiring dedicated Keycloak instance.\"\"\"\n    import uuid\n    keycloak_name = f\"dedicated-{uuid.uuid4().hex[:8]}\"\n\n    try:\n        # Create dedicated instance\n        k8s_custom_objects.create_namespaced_custom_object(\n            group=\"vriesdemichael.github.io\",\n            version=\"v1\",\n            namespace=test_namespace,\n            plural=\"keycloaks\",\n            body={**sample_keycloak_spec, \"metadata\": {\"name\": keycloak_name}},\n        )\n\n        # Wait for ready (~60s)\n        await wait_for_keycloak_ready(keycloak_name, test_namespace)\n\n        # Your test logic here\n\n    finally:\n        # ALWAYS cleanup\n        with contextlib.suppress(ApiException):\n            k8s_custom_objects.delete_namespaced_custom_object(\n                group=\"vriesdemichael.github.io\",\n                version=\"v1\",\n                namespace=test_namespace,\n                plural=\"keycloaks\",\n                name=keycloak_name,\n            )\n</code></pre> <p>When to use: - \ud83d\udd12 Modifying global Keycloak state - \ud83e\uddea Testing cascading deletions - \ud83c\udfad Testing authentication flows - \ud83d\udd04 Testing complex multi-step operations</p>"},{"location":"development/testing/#critical-rule-port-forwarding","title":"Critical Rule: Port-Forwarding","text":"<p>ALWAYS use <code>keycloak_port_forward</code> fixture when accessing Keycloak from tests.</p> <p>Tests run on your machine (not in cluster) and cannot resolve cluster DNS.</p>"},{"location":"development/testing/#wrong-will-fail","title":"\u274c WRONG - Will Fail","text":"<pre><code>async def test_something(test_namespace):\n    # \u274c DNS resolution will fail!\n    admin_client = get_keycloak_admin_client(\"my-keycloak\", test_namespace)\n</code></pre>"},{"location":"development/testing/#correct-use-port-forward","title":"\u2705 CORRECT - Use Port-Forward","text":"<pre><code>async def test_something(test_namespace, keycloak_port_forward):\n    # \u2705 Port-forward to localhost\n    local_port = await keycloak_port_forward(\"my-keycloak\", test_namespace)\n\n    from keycloak_operator.utils.keycloak_admin import KeycloakAdminClient\n    from keycloak_operator.utils.kubernetes import get_admin_credentials\n\n    username, password = get_admin_credentials(\"my-keycloak\", test_namespace)\n    admin_client = KeycloakAdminClient(\n        server_url=f\"http://localhost:{local_port}\",\n        username=username,\n        password=password,\n    )\n    admin_client.authenticate()\n\n    # Now you can use admin_client\n</code></pre>"},{"location":"development/testing/#parallel-test-safety","title":"Parallel Test Safety","text":"<p>Tests run with 8 parallel workers by default. Follow these rules:</p>"},{"location":"development/testing/#safe-patterns","title":"\u2705 Safe Patterns","text":"<pre><code>import uuid\n\n# Always use unique names\nclient_name = f\"test-client-{uuid.uuid4().hex[:8]}\"\n\n# Use test_namespace fixture (unique per test)\nasync def test_something(test_namespace):\n    # Each test gets unique namespace\n    pass\n</code></pre>"},{"location":"development/testing/#unsafe-patterns","title":"\u274c Unsafe Patterns","text":"<pre><code># \u274c WRONG: Fixed names cause race conditions\nclient_name = \"test-client\"\n\n# \u274c WRONG: Shared namespace causes conflicts\nnamespace = \"test\"\n\n# \u274c WRONG: Modifying global state in shared instance\nadmin_client.update_realm(\"master\", {...})\n</code></pre>"},{"location":"development/testing/#wait-helpers-with-auto-debugging","title":"Wait Helpers with Auto-Debugging","text":"<p>Use consolidated wait helpers from <code>wait_helpers.py</code> - they automatically collect debugging info on timeout.</p> <pre><code>from tests.integration.wait_helpers import (\n    wait_for_resource_ready,\n    wait_for_resource_condition,\n    wait_for_resource_deleted,\n)\n\n\nasync def test_something(\n    k8s_custom_objects,\n    test_namespace,\n    operator_namespace,\n):\n    # Create resource\n    k8s_custom_objects.create_namespaced_custom_object(...)\n\n    # Wait with automatic debugging on timeout\n    await wait_for_resource_ready(\n        k8s_custom_objects=k8s_custom_objects,\n        group=\"vriesdemichael.github.io\",\n        version=\"v1\",\n        namespace=test_namespace,\n        plural=\"keycloakrealms\",\n        name=\"my-realm\",\n        timeout=120,\n        operator_namespace=operator_namespace,  # Enables log collection\n    )\n</code></pre> <p>On timeout, automatically shows: - Last resource status - Kubernetes events - Operator logs (last 100 lines) - Any exceptions</p>"},{"location":"development/testing/#complete-test-template","title":"Complete Test Template","text":"<pre><code>\"\"\"Integration test for [feature description].\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport uuid\n\nimport pytest\nfrom kubernetes.client.rest import ApiException\nfrom tests.integration.wait_helpers import wait_for_resource_ready\n\n\n@pytest.mark.integration\n@pytest.mark.timeout(300)\nasync def test_feature_name(\n    k8s_custom_objects,\n    test_namespace,\n    operator_namespace,\n    shared_operator,\n    keycloak_port_forward,\n) -&gt; None:\n    \"\"\"Test description explaining what this verifies.\"\"\"\n\n    # Use shared instance\n    keycloak_name = shared_operator[\"name\"]\n    keycloak_namespace = shared_operator[\"namespace\"]\n\n    # Generate unique names\n    realm_name = f\"test-realm-{uuid.uuid4().hex[:8]}\"\n\n    try:\n        # Create test resource\n        realm_manifest = {\n            \"apiVersion\": \"vriesdemichael.github.io/v1\",\n            \"kind\": \"KeycloakRealm\",\n            \"metadata\": {\n                \"name\": realm_name,\n                \"namespace\": test_namespace,\n            },\n            \"spec\": {\n                \"realmName\": realm_name,\n                \"operatorRef\": {\n                    \"namespace\": keycloak_namespace,\n                },\n            },\n        }\n\n        k8s_custom_objects.create_namespaced_custom_object(\n            group=\"vriesdemichael.github.io\",\n            version=\"v1\",\n            namespace=test_namespace,\n            plural=\"keycloakrealms\",\n            body=realm_manifest,\n        )\n\n        # Wait for ready with auto-debugging\n        await wait_for_resource_ready(\n            k8s_custom_objects=k8s_custom_objects,\n            group=\"vriesdemichael.github.io\",\n            version=\"v1\",\n            namespace=test_namespace,\n            plural=\"keycloakrealms\",\n            name=realm_name,\n            timeout=120,\n            operator_namespace=operator_namespace,\n        )\n\n        # Verify in Keycloak if needed\n        local_port = await keycloak_port_forward(keycloak_name, keycloak_namespace)\n\n        from keycloak_operator.utils.keycloak_admin import KeycloakAdminClient\n        from keycloak_operator.utils.kubernetes import get_admin_credentials\n\n        username, password = get_admin_credentials(keycloak_name, keycloak_namespace)\n        admin_client = KeycloakAdminClient(\n            server_url=f\"http://localhost:{local_port}\",\n            username=username,\n            password=password,\n        )\n        admin_client.authenticate()\n\n        # Assertions\n        realm = await admin_client.get_realm(realm_name)\n        assert realm is not None\n        assert realm.realm == realm_name\n\n    finally:\n        # Cleanup\n        with contextlib.suppress(ApiException):\n            k8s_custom_objects.delete_namespaced_custom_object(\n                group=\"vriesdemichael.github.io\",\n                version=\"v1\",\n                namespace=test_namespace,\n                plural=\"keycloakrealms\",\n                name=realm_name,\n            )\n</code></pre>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#basic-commands","title":"Basic Commands","text":"<pre><code># All tests (recommended)\nmake test\n\n# Only unit tests (fast)\nmake test-unit\n\n# Only integration tests (reuses cluster)\nmake test-integration\n\n# Fresh cluster + all tests (pre-commit)\nmake test-pre-commit\n</code></pre>"},{"location":"development/testing/#advanced-commands","title":"Advanced Commands","text":"<pre><code># Specific test file\nuv run pytest tests/integration/test_realm.py -v\n\n# Specific test function\nuv run pytest tests/integration/test_realm.py::test_realm_creation -v\n\n# Less parallelism (useful for debugging)\nuv run pytest tests/integration/ -n 2 -v\n\n# Sequential execution (no parallelism)\nuv run pytest tests/integration/ -n 0 -v\n\n# With verbose output\nuv run pytest tests/integration/ -v -s\n\n# With debugger on failure\nuv run pytest tests/integration/ --pdb\n</code></pre>"},{"location":"development/testing/#cluster-management","title":"Cluster Management","text":"<pre><code># Reset integration state (keeps cluster)\nmake clean-integration-state\n\n# Destroy cluster completely\nmake kind-teardown\n\n# Create fresh cluster\nmake kind-setup\n\n# Check cluster status\nkubectl cluster-info\nkind get clusters\n</code></pre>"},{"location":"development/testing/#debugging-failed-tests","title":"Debugging Failed Tests","text":""},{"location":"development/testing/#1-check-operator-logs","title":"1. Check Operator Logs","text":"<pre><code># Recent logs\nkubectl logs -n keycloak-test-system -l app.kubernetes.io/name=keycloak-operator --tail=200\n\n# Follow logs in real-time\nkubectl logs -n keycloak-test-system -l app.kubernetes.io/name=keycloak-operator -f\n</code></pre>"},{"location":"development/testing/#2-check-resource-status","title":"2. Check Resource Status","text":"<pre><code># List all resources\nkubectl get keycloaks,keycloakrealms,keycloakclients -A\n\n# Describe specific resource\nkubectl describe keycloakrealm my-realm -n test-abc123\n\n# Get resource YAML\nkubectl get keycloakrealm my-realm -n test-abc123 -o yaml\n</code></pre>"},{"location":"development/testing/#3-check-events","title":"3. Check Events","text":"<pre><code># Recent events in namespace\nkubectl get events -n test-abc123 --sort-by='.lastTimestamp'\n\n# Events for specific resource\nkubectl describe keycloakrealm my-realm -n test-abc123 | grep -A 10 Events:\n</code></pre>"},{"location":"development/testing/#4-clean-up-stuck-resources","title":"4. Clean Up Stuck Resources","text":"<pre><code># List test namespaces\nkubectl get namespaces | grep test-\n\n# Delete stuck namespace\nkubectl delete namespace test-abc123 --force --grace-period=0\n</code></pre>"},{"location":"development/testing/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"development/testing/#forgetting-port-forward","title":"\u274c Forgetting Port-Forward","text":"<p>Symptom: <code>NameResolutionError</code> or DNS failures</p> <p>Fix: Always use <code>keycloak_port_forward</code> fixture:</p> <pre><code>async def test_something(keycloak_port_forward):\n    local_port = await keycloak_port_forward(\"keycloak\", namespace)\n    # Use localhost:local_port\n</code></pre>"},{"location":"development/testing/#using-shared-instance-for-destructive-tests","title":"\u274c Using Shared Instance for Destructive Tests","text":"<p>Symptom: Random test failures in parallel runs</p> <p>Fix: Create dedicated instance for tests that modify global state</p>"},{"location":"development/testing/#hardcoded-resource-names","title":"\u274c Hardcoded Resource Names","text":"<p>Symptom: <code>AlreadyExists</code> errors in parallel runs</p> <p>Fix: Always use UUID for unique names:</p> <pre><code>import uuid\nrealm_name = f\"test-realm-{uuid.uuid4().hex[:8]}\"\n</code></pre>"},{"location":"development/testing/#missing-cleanup","title":"\u274c Missing Cleanup","text":"<p>Symptom: Namespace stuck in Terminating state</p> <p>Fix: Always use <code>finally</code> blocks:</p> <pre><code>try:\n    # Test logic\n    pass\nfinally:\n    with contextlib.suppress(ApiException):\n        k8s_custom_objects.delete_namespaced_custom_object(...)\n</code></pre>"},{"location":"development/testing/#insufficient-timeouts","title":"\u274c Insufficient Timeouts","text":"<p>Symptom: Tests timeout waiting for Ready</p> <p>Fix: Use appropriate timeouts:</p> <pre><code># Simple tests\n@pytest.mark.timeout(300)  # 5 minutes\n\n# With dedicated Keycloak\n@pytest.mark.timeout(600)  # 10 minutes\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":""},{"location":"development/testing/#1-write-idempotent-tests","title":"1. Write Idempotent Tests","text":"<p>Tests should be runnable multiple times:</p> <pre><code># \u2705 Good: Cleanup in finally\ntry:\n    create_resource()\n    test_something()\nfinally:\n    cleanup_resource()\n\n# \u274c Bad: Assumes clean state\ncreate_resource()  # Fails if resource exists\ntest_something()\n</code></pre>"},{"location":"development/testing/#2-test-one-thing-per-test","title":"2. Test One Thing Per Test","text":"<pre><code># \u2705 Good: Focused test\nasync def test_realm_creation():\n    \"\"\"Test realm can be created.\"\"\"\n    # ... create and verify realm ...\n\nasync def test_realm_update():\n    \"\"\"Test realm can be updated.\"\"\"\n    # ... update and verify realm ...\n\n# \u274c Bad: Testing multiple things\nasync def test_realm_crud():\n    \"\"\"Test realm CRUD operations.\"\"\"\n    # ... create, update, delete all in one test ...\n</code></pre>"},{"location":"development/testing/#3-use-descriptive-names","title":"3. Use Descriptive Names","text":"<pre><code># \u2705 Good: Clear what's being tested\nasync def test_realm_creation_with_smtp_configuration():\n    \"\"\"Test realm creation with SMTP server configured.\"\"\"\n\n# \u274c Bad: Vague name\nasync def test_realm_stuff():\n    \"\"\"Test realm things.\"\"\"\n</code></pre>"},{"location":"development/testing/#4-add-helpful-failure-messages","title":"4. Add Helpful Failure Messages","text":"<pre><code># \u2705 Good: Helpful assertion message\nassert realm.enabled is True, (\n    f\"Realm {realm_name} should be enabled but got: {realm.enabled}\"\n)\n\n# \u274c Bad: Generic failure\nassert realm.enabled is True\n</code></pre>"},{"location":"development/testing/#advanced-topics","title":"Advanced Topics","text":"<p>For advanced testing patterns and detailed guidelines, see the following in the repository:</p> <ul> <li>tests/integration/TESTING.md - Comprehensive rules and patterns</li> <li>tests/integration/wait_helpers.py - Auto-debugging wait utilities</li> <li>tests/integration/conftest.py - Fixture implementations</li> </ul>"},{"location":"development/testing/#contributing-tests","title":"Contributing Tests","text":"<p>When contributing, ensure:</p> <ol> <li>\u2705 All existing tests pass</li> <li>\u2705 New features have unit tests</li> <li>\u2705 New features have integration tests</li> <li>\u2705 Tests follow parallel-safe patterns</li> <li>\u2705 Tests use wait helpers for debugging</li> <li>\u2705 Tests clean up resources</li> <li>\u2705 Run <code>make test-pre-commit</code> before pushing</li> </ol> <p>Return to Development Guide.</p>"},{"location":"guides/drift-detection/","title":"Drift Detection","text":"<p>The Keycloak Operator includes drift detection to monitor the actual state of Keycloak resources and compare them with Kubernetes Custom Resources (CRs). This helps identify:</p> <ul> <li>Orphaned resources: Resources created by the operator but whose CR has been deleted</li> <li>Configuration drift: Resources whose actual state differs from the CR specification</li> <li>Unmanaged resources: Resources in Keycloak not managed by any operator instance</li> </ul>"},{"location":"guides/drift-detection/#features","title":"Features","text":""},{"location":"guides/drift-detection/#resource-ownership-tracking","title":"Resource Ownership Tracking","text":"<p>Every Keycloak resource (realm, client, etc.) created by the operator is tagged with ownership attributes:</p> <pre><code>{\n  \"attributes\": {\n    \"io.kubernetes.managed-by\": \"keycloak-operator\",\n    \"io.kubernetes.operator-instance\": \"keycloak-operator-production\",\n    \"io.kubernetes.cr-namespace\": \"team-a\",\n    \"io.kubernetes.cr-name\": \"my-realm\",\n    \"io.kubernetes.created-at\": \"2025-10-28T12:00:00Z\"\n  }\n}\n</code></pre> <p>These attributes enable: - Multi-operator deployments (each operator tracks its own resources) - Orphan detection (identify resources whose CR was deleted) - Drift detection (verify CR still matches actual state)</p>"},{"location":"guides/drift-detection/#periodic-drift-scanning","title":"Periodic Drift Scanning","text":"<p>The operator runs periodic background scans to check for drift:</p> <ol> <li>Fetch all resources from Keycloak</li> <li>Check ownership using attributes</li> <li>Verify CR existence for operator-managed resources</li> <li>Compare configuration (future: detect spec drift)</li> <li>Emit Prometheus metrics for monitoring</li> </ol>"},{"location":"guides/drift-detection/#auto-remediation-optional","title":"Auto-Remediation (Optional)","text":"<p>When enabled, the operator can automatically fix drift:</p> <ul> <li>Orphaned resources: Delete from Keycloak if older than minimum age (default: 24 hours)</li> <li>Configuration drift: Update Keycloak to match CR spec (future feature)</li> </ul> <p>Safety mechanisms: - Minimum age check (default: 24 hours) prevents accidental deletion of newly created resources - Re-check CR existence before deletion to avoid race conditions - Only touches resources with this operator's instance ID</p>"},{"location":"guides/drift-detection/#configuration","title":"Configuration","text":"<p>Configure drift detection via Helm values:</p> <pre><code>monitoring:\n  driftDetection:\n    # Enable drift detection\n    enabled: true\n\n    # Scan interval in seconds (default: 300 = 5 minutes)\n    intervalSeconds: 300\n\n    # Auto-remediate detected drift (default: false)\n    # WARNING: When enabled, orphaned resources will be automatically deleted\n    autoRemediate: false\n\n    # Minimum age in hours before deleting orphaned resources (default: 24)\n    # Safety mechanism to prevent accidental deletion\n    minimumAgeHours: 24\n\n    # Scope of drift detection\n    scope:\n      realms: true\n      clients: true\n      identityProviders: true  # Future feature\n      roles: true               # Future feature\n</code></pre>"},{"location":"guides/drift-detection/#environment-variables","title":"Environment Variables","text":"<p>If you're not using Helm, configure via environment variables:</p> <pre><code>DRIFT_DETECTION_ENABLED=true\nDRIFT_DETECTION_INTERVAL_SECONDS=300\nDRIFT_DETECTION_AUTO_REMEDIATE=false\nDRIFT_DETECTION_MINIMUM_AGE_HOURS=24\nDRIFT_DETECTION_SCOPE_REALMS=true\nDRIFT_DETECTION_SCOPE_CLIENTS=true\nDRIFT_DETECTION_SCOPE_IDENTITY_PROVIDERS=true\nDRIFT_DETECTION_SCOPE_ROLES=true\n</code></pre>"},{"location":"guides/drift-detection/#prometheus-metrics","title":"Prometheus Metrics","text":"<p>The operator exposes the following metrics for drift detection:</p>"},{"location":"guides/drift-detection/#drift-detection-metrics","title":"Drift Detection Metrics","text":"<pre><code># Number of orphaned resources (created by this operator, CR deleted)\nkeycloak_operator_orphaned_resources{resource_type, resource_name, operator_instance}\n\n# Number of resources with configuration drift\nkeycloak_operator_config_drift{resource_type, resource_name, cr_namespace, cr_name}\n\n# Number of unmanaged resources (not created by any operator)\nkeycloak_unmanaged_resources{resource_type, resource_name}\n</code></pre>"},{"location":"guides/drift-detection/#remediation-metrics","title":"Remediation Metrics","text":"<pre><code># Total remediation actions performed\nkeycloak_operator_remediation_total{resource_type, action, reason}\n\n# Total remediation errors\nkeycloak_operator_remediation_errors_total{resource_type, action}\n</code></pre>"},{"location":"guides/drift-detection/#health-metrics","title":"Health Metrics","text":"<pre><code># Duration of drift detection scans\nkeycloak_operator_drift_check_duration_seconds{resource_type}\n\n# Total drift check errors\nkeycloak_operator_drift_check_errors_total{resource_type}\n\n# Unix timestamp of last successful drift check\nkeycloak_operator_drift_check_last_success_timestamp\n</code></pre>"},{"location":"guides/drift-detection/#example-prometheus-alerts","title":"Example Prometheus Alerts","text":"<p>Create alerts to notify when drift is detected:</p> <pre><code>apiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: keycloak-operator-drift-alerts\nspec:\n  groups:\n    - name: keycloak-drift\n      interval: 30s\n      rules:\n        # Alert on orphaned resources\n        - alert: KeycloakOrphanedResources\n          expr: keycloak_operator_orphaned_resources &gt; 0\n          for: 30m\n          labels:\n            severity: warning\n            component: keycloak-operator\n          annotations:\n            summary: \"Orphaned Keycloak resources detected\"\n            description: |\n              {{ $value }} orphaned {{ $labels.resource_type }} resource(s) detected.\n              Resource: {{ $labels.resource_name }}\n              Operator: {{ $labels.operator_instance }}\n\n        # Alert on configuration drift\n        - alert: KeycloakConfigurationDrift\n          expr: keycloak_operator_config_drift &gt; 0\n          for: 15m\n          labels:\n            severity: info\n            component: keycloak-operator\n          annotations:\n            summary: \"Keycloak configuration drift detected\"\n            description: |\n              Configuration drift detected for {{ $labels.resource_type }}: {{ $labels.resource_name }}\n              CR: {{ $labels.cr_namespace }}/{{ $labels.cr_name }}\n\n        # Alert on drift check failures\n        - alert: KeycloakDriftCheckFailure\n          expr: increase(keycloak_operator_drift_check_errors_total[5m]) &gt; 3\n          for: 5m\n          labels:\n            severity: warning\n            component: keycloak-operator\n          annotations:\n            summary: \"Drift detection checks are failing\"\n            description: |\n              Drift detection for {{ $labels.resource_type }} has failed {{ $value }} times in the last 5 minutes.\n\n        # Alert if drift checks haven't run recently\n        - alert: KeycloakDriftCheckStale\n          expr: (time() - keycloak_operator_drift_check_last_success_timestamp) &gt; 900\n          for: 5m\n          labels:\n            severity: warning\n            component: keycloak-operator\n          annotations:\n            summary: \"Drift detection checks are not running\"\n            description: |\n              Drift detection has not run successfully in {{ $value | humanizeDuration }}.\n</code></pre>"},{"location":"guides/drift-detection/#usage-examples","title":"Usage Examples","text":""},{"location":"guides/drift-detection/#scenario-1-detect-orphaned-realms","title":"Scenario 1: Detect Orphaned Realms","text":"<ol> <li> <p>Create a realm:    <pre><code>kubectl apply -f my-realm.yaml\n</code></pre></p> </li> <li> <p>Delete the CR (simulating accidental deletion):    <pre><code>kubectl delete keycloakrealm my-realm\n</code></pre></p> </li> <li> <p>Check metrics (after next drift scan):    <pre><code>curl http://localhost:8081/metrics | grep orphaned_resources\n# keycloak_operator_orphaned_resources{resource_type=\"realm\",resource_name=\"my-realm\",...} 1\n</code></pre></p> </li> <li> <p>Manual cleanup (if auto-remediation is disabled):    <pre><code># The realm still exists in Keycloak\n# Delete it manually via Keycloak Admin UI or API\n</code></pre></p> </li> <li> <p>Auto-cleanup (if auto-remediation is enabled and age &gt; 24h):    <pre><code># Wait 24 hours, then the operator will automatically delete the orphaned realm\n# Check logs:\nkubectl logs -n keycloak-system deployment/keycloak-operator | grep \"Successfully deleted orphaned realm\"\n</code></pre></p> </li> </ol>"},{"location":"guides/drift-detection/#scenario-2-multi-operator-deployments","title":"Scenario 2: Multi-Operator Deployments","text":"<p>When running multiple operator instances:</p> <pre><code># Operator 1 in production namespace\noperator:\n  instanceId: \"keycloak-operator-production\"\n\n# Operator 2 in staging namespace\noperator:\n  instanceId: \"keycloak-operator-staging\"\n</code></pre> <p>Each operator only manages resources it created: - Production operator ignores resources created by staging operator - Prevents conflicts and accidental deletions - Clear ownership boundaries</p>"},{"location":"guides/drift-detection/#scenario-3-identify-unmanaged-resources","title":"Scenario 3: Identify Unmanaged Resources","text":"<p>Find Keycloak resources not managed by any operator:</p> <pre><code># Query metrics\ncurl http://localhost:8081/metrics | grep unmanaged_resources\n\n# Example output:\n# keycloak_unmanaged_resources{resource_type=\"realm\",resource_name=\"legacy-realm\"} 1\n# keycloak_unmanaged_resources{resource_type=\"client\",resource_name=\"manual-client\"} 1\n</code></pre> <p>These are resources that existed before the operator or were created manually.</p> <p>Options: - Leave them as-is (operator won't touch them) - Manually add ownership attributes to adopt them (not recommended) - Create matching CRs to bring them under operator management (recommended)</p>"},{"location":"guides/drift-detection/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/drift-detection/#drift-detection-is-not-running","title":"Drift detection is not running","text":"<p>Symptoms: <code>keycloak_operator_drift_check_last_success_timestamp</code> is stale</p> <p>Causes: 1. Drift detection is disabled in Helm values 2. Operator is not running or crashing</p> <p>Solutions: <pre><code># Check if enabled\nhelm get values keycloak-operator | grep driftDetection\n\n# Check operator logs\nkubectl logs -n keycloak-system deployment/keycloak-operator | grep drift\n\n# Ensure at least one realm CR exists\nkubectl get keycloakrealms -A\n</code></pre></p>"},{"location":"guides/drift-detection/#orphaned-resources-not-being-deleted","title":"Orphaned resources not being deleted","text":"<p>Symptoms: <code>keycloak_operator_orphaned_resources</code> &gt; 0 but resources not deleted</p> <p>Causes: 1. Auto-remediation is disabled (check <code>autoRemediate: false</code>) 2. Resource age &lt; minimum age (default 24h) 3. Remediation errors (check error metrics)</p> <p>Solutions: <pre><code># Check auto-remediation setting\nhelm get values keycloak-operator | grep autoRemediate\n\n# Check resource age (must be &gt; minimumAgeHours)\n# Resource created_at is in the attributes\n\n# Check for remediation errors\ncurl http://localhost:8081/metrics | grep remediation_errors_total\n\n# Check operator logs for errors\nkubectl logs -n keycloak-system deployment/keycloak-operator | grep remediation\n</code></pre></p>"},{"location":"guides/drift-detection/#false-orphan-detection","title":"False orphan detection","text":"<p>Symptoms: Resources marked as orphaned but CR exists</p> <p>Causes: 1. CR is in different namespace than expected 2. Ownership attributes don't match actual CR name/namespace 3. Permissions issue (operator can't read CR)</p> <p>Solutions: <pre><code># Verify CR exists and matches ownership attributes\nkubectl get keycloakrealm my-realm -n expected-namespace -o yaml\n\n# Check operator RBAC permissions\nkubectl auth can-i get keycloakrealms --as=system:serviceaccount:keycloak-system:keycloak-operator-keycloak-system\n\n# Check operator logs for permission errors\nkubectl logs -n keycloak-system deployment/keycloak-operator | grep -i \"permission\\|rbac\"\n</code></pre></p>"},{"location":"guides/drift-detection/#migration-from-existing-resources","title":"Migration from Existing Resources","text":""},{"location":"guides/drift-detection/#breaking-change-notice","title":"Breaking Change Notice","text":"<p>\u26a0\ufe0f Resources created before this version will NOT be managed for drift detection.</p> <p>Existing realms and clients lack ownership attributes and will be treated as \"unmanaged\" resources.</p>"},{"location":"guides/drift-detection/#migration-options","title":"Migration Options","text":""},{"location":"guides/drift-detection/#option-1-recreate-resources-recommended","title":"Option 1: Recreate Resources (Recommended)","text":"<ol> <li>Export existing resource configuration</li> <li>Delete the resource from Keycloak</li> <li>Recreate via CR (operator will add ownership attributes)</li> </ol> <pre><code># Backup realm config\nkubectl get keycloakrealm my-realm -o yaml &gt; my-realm-backup.yaml\n\n# Delete and recreate\nkubectl delete keycloakrealm my-realm\nkubectl apply -f my-realm-backup.yaml\n</code></pre>"},{"location":"guides/drift-detection/#option-2-manual-attribute-addition-advanced","title":"Option 2: Manual Attribute Addition (Advanced)","text":"<p>Manually add ownership attributes to existing Keycloak resources via Admin API:</p> <pre><code># Get current realm\nGET /admin/realms/{realm-name}\n\n# Add attributes\nPATCH /admin/realms/{realm-name}\n{\n  \"attributes\": {\n    \"io.kubernetes.managed-by\": \"keycloak-operator\",\n    \"io.kubernetes.operator-instance\": \"keycloak-operator-&lt;namespace&gt;\",\n    \"io.kubernetes.cr-namespace\": \"&lt;cr-namespace&gt;\",\n    \"io.kubernetes.cr-name\": \"&lt;cr-name&gt;\",\n    \"io.kubernetes.created-at\": \"2025-10-28T12:00:00Z\"\n  }\n}\n</code></pre> <p>\u26a0\ufe0f Risks: - Incorrect attributes can cause drift detection to malfunction - Easy to make mistakes with namespace/name mapping - Not recommended unless you know what you're doing</p>"},{"location":"guides/drift-detection/#option-3-leave-as-unmanaged-simplest","title":"Option 3: Leave As Unmanaged (Simplest)","text":"<p>Do nothing. Existing resources will show up as \"unmanaged\" in metrics but won't be affected by drift detection or auto-remediation.</p>"},{"location":"guides/drift-detection/#security-considerations","title":"Security Considerations","text":""},{"location":"guides/drift-detection/#ownership-attribute-tampering","title":"Ownership Attribute Tampering","text":"<p>Threat: Someone manually modifies ownership attributes in Keycloak to evade drift detection</p> <p>Mitigation: - Keycloak Admin API should be restricted (not publicly accessible) - Use Keycloak RBAC to limit who can modify realms/clients - Audit logs should track attribute changes</p>"},{"location":"guides/drift-detection/#unauthorized-resource-deletion","title":"Unauthorized Resource Deletion","text":"<p>Threat: Auto-remediation deletes resources that shouldn't be deleted</p> <p>Mitigation: - Auto-remediation is disabled by default - 24-hour minimum age prevents accidental deletions - Operator logs all deletions for audit trail - Monitor <code>remediation_total</code> metric for unexpected deletions</p>"},{"location":"guides/drift-detection/#information-disclosure","title":"Information Disclosure","text":"<p>Threat: Prometheus metrics expose sensitive information about tenants</p> <p>Mitigation: - Metrics only expose resource names (not secrets, passwords, etc.) - Unmanaged resources are visible (could reveal what exists) - Use Prometheus authentication/authorization to restrict metric access - Consider disabling unmanaged resource metrics if needed</p>"},{"location":"guides/drift-detection/#future-enhancements","title":"Future Enhancements","text":"<ul> <li> Config drift detection: Compare actual Keycloak state with CR spec</li> <li> Identity provider drift detection: Track IDP configuration changes</li> <li> Role drift detection: Monitor role assignments</li> <li> Drift remediation for config changes: Auto-update Keycloak when CR changes</li> <li> Grafana dashboard: Pre-built dashboard for drift visualization</li> <li> Webhook notifications: Send alerts to Slack/Teams when drift detected</li> <li> Dry-run mode: Log what would be remediated without actually doing it</li> <li> Per-resource remediation control: Annotation to disable auto-remediation for specific resources</li> </ul>"},{"location":"guides/identity-providers/","title":"Identity Providers (IDPs)","text":"<p>Identity Providers allow Keycloak to delegate authentication to external systems, enabling Single Sign-On (SSO) and user federation from providers like GitHub, Google, Azure AD, or custom OIDC/SAML providers.</p>"},{"location":"guides/identity-providers/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Supported Providers</li> <li>Configuration</li> <li>GitHub OAuth</li> <li>Google OAuth</li> <li>Azure AD (Microsoft Entra ID)</li> <li>Custom OIDC Provider</li> <li>SAML Provider</li> <li>IDP Mappers</li> <li>Complete Examples</li> </ul>"},{"location":"guides/identity-providers/#overview","title":"Overview","text":"<p>The operator supports configuring identity providers through the <code>KeycloakRealm</code> custom resource. Identity providers are configured in the <code>identityProviders</code> field of the realm spec.</p> <p>When a user tries to log in to your Keycloak realm, they'll see buttons for each enabled identity provider on the login page, allowing them to authenticate through external systems.</p>"},{"location":"guides/identity-providers/#supported-providers","title":"Supported Providers","text":"<p>The operator supports all Keycloak built-in identity providers:</p> <ul> <li>Social Providers: GitHub, Google, Facebook, LinkedIn, Stack Overflow, Microsoft, etc.</li> <li>Enterprise Providers: OIDC (OpenID Connect), SAML 2.0</li> <li>Keycloak-to-Keycloak: Federation between Keycloak instances</li> </ul>"},{"location":"guides/identity-providers/#configuration","title":"Configuration","text":""},{"location":"guides/identity-providers/#github-oauth","title":"GitHub OAuth","text":"<p>GitHub OAuth allows users to sign in with their GitHub accounts.</p> <p>Prerequisites: 1. Create a GitHub OAuth App:    - Go to Settings \u2192 Developer settings \u2192 OAuth Apps \u2192 New OAuth App    - Set Authorization callback URL to: <code>https://your-keycloak-domain/realms/your-realm/broker/github/endpoint</code>    - Note your Client ID and Client Secret</p> <p>Example:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-operator\n\n  identityProviders:\n    - alias: github\n      providerId: github\n      enabled: true\n      trustEmail: false\n      firstBrokerLoginFlowAlias: first broker login\n      config:\n        clientId: your-github-oauth-app-client-id\n        clientSecret: your-github-oauth-app-client-secret\n        defaultScope: \"user:email\"\n        syncMode: IMPORT\n</code></pre> <p>Important Configuration Options:</p> <ul> <li><code>alias</code>: Unique identifier for this IDP (will be part of the callback URL)</li> <li><code>trustEmail</code>: Whether to trust email addresses from GitHub (set to <code>false</code> for security)</li> <li><code>syncMode</code>: How to sync users (<code>IMPORT</code>, <code>FORCE</code>, or <code>LEGACY</code>)</li> <li><code>IMPORT</code>: Create new users, update on first login only</li> <li><code>FORCE</code>: Update user data on every login</li> <li><code>LEGACY</code>: Don't update existing users</li> </ul>"},{"location":"guides/identity-providers/#google-oauth","title":"Google OAuth","text":"<p>Google OAuth allows users to sign in with their Google accounts.</p> <p>Prerequisites: 1. Create a Google Cloud Project and OAuth 2.0 Client:    - Go to Google Cloud Console    - Create a project \u2192 APIs &amp; Services \u2192 Credentials \u2192 Create OAuth Client ID    - Application type: Web application    - Authorized redirect URIs: <code>https://your-keycloak-domain/realms/your-realm/broker/google/endpoint</code>    - Note your Client ID and Client Secret</p> <p>Example:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-operator\n\n  identityProviders:\n    - alias: google\n      providerId: google\n      enabled: true\n      trustEmail: true\n      firstBrokerLoginFlowAlias: first broker login\n      config:\n        clientId: your-google-oauth-client-id.apps.googleusercontent.com\n        clientSecret: your-google-oauth-client-secret\n        hostedDomain: \"\"  # Optional: restrict to specific domain (e.g., \"company.com\")\n        defaultScope: \"openid profile email\"\n        syncMode: IMPORT\n</code></pre> <p>Domain Restriction:</p> <p>To restrict logins to a specific Google Workspace domain:</p> <pre><code>config:\n  hostedDomain: \"company.com\"\n</code></pre>"},{"location":"guides/identity-providers/#azure-ad-microsoft-entra-id","title":"Azure AD (Microsoft Entra ID)","text":"<p>Azure AD integration allows users to sign in with their Microsoft work or school accounts.</p> <p>Prerequisites: 1. Register an application in Azure AD:    - Go to Azure Portal \u2192 Azure Active Directory \u2192 App registrations \u2192 New registration    - Set Redirect URI: <code>https://your-keycloak-domain/realms/your-realm/broker/azure-ad/endpoint</code>    - Create a client secret in Certificates &amp; secrets    - Note your Application (client) ID, Directory (tenant) ID, and client secret</p> <p>Example:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-operator\n\n  identityProviders:\n    - alias: azure-ad\n      providerId: oidc\n      enabled: true\n      trustEmail: true\n      firstBrokerLoginFlowAlias: first broker login\n      config:\n        clientId: your-azure-app-client-id\n        clientSecret: your-azure-app-client-secret\n        authorizationUrl: https://login.microsoftonline.com/YOUR_TENANT_ID/oauth2/v2.0/authorize\n        tokenUrl: https://login.microsoftonline.com/YOUR_TENANT_ID/oauth2/v2.0/token\n        userInfoUrl: https://graph.microsoft.com/oidc/userinfo\n        jwksUrl: https://login.microsoftonline.com/YOUR_TENANT_ID/discovery/v2.0/keys\n        issuer: https://login.microsoftonline.com/YOUR_TENANT_ID/v2.0\n        defaultScope: \"openid profile email\"\n        syncMode: IMPORT\n        validateSignature: \"true\"\n        useJwksUrl: \"true\"\n</code></pre> <p>Replace <code>YOUR_TENANT_ID</code> with your Azure AD tenant ID.</p>"},{"location":"guides/identity-providers/#custom-oidc-provider","title":"Custom OIDC Provider","text":"<p>For any OpenID Connect-compliant identity provider.</p> <p>Example:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-operator\n\n  identityProviders:\n    - alias: custom-oidc\n      providerId: oidc\n      enabled: true\n      trustEmail: false\n      firstBrokerLoginFlowAlias: first broker login\n      config:\n        clientId: your-client-id\n        clientSecret: your-client-secret\n        authorizationUrl: https://idp.example.com/oauth2/authorize\n        tokenUrl: https://idp.example.com/oauth2/token\n        userInfoUrl: https://idp.example.com/oauth2/userinfo\n        jwksUrl: https://idp.example.com/oauth2/keys\n        issuer: https://idp.example.com\n        defaultScope: \"openid profile email\"\n        syncMode: IMPORT\n        validateSignature: \"true\"\n        useJwksUrl: \"true\"\n</code></pre> <p>Discovery Endpoint:</p> <p>Most OIDC providers support auto-discovery. You can find URLs at: <pre><code>https://idp.example.com/.well-known/openid-configuration\n</code></pre></p>"},{"location":"guides/identity-providers/#saml-provider","title":"SAML Provider","text":"<p>For SAML 2.0 identity providers.</p> <p>Example:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-operator\n\n  identityProviders:\n    - alias: saml-idp\n      providerId: saml\n      enabled: true\n      trustEmail: false\n      firstBrokerLoginFlowAlias: first broker login\n      config:\n        singleSignOnServiceUrl: https://idp.example.com/saml/sso\n        singleLogoutServiceUrl: https://idp.example.com/saml/logout\n        backchannelSupported: \"true\"\n        nameIDPolicyFormat: urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\n        principalType: SUBJECT\n        signatureAlgorithm: RSA_SHA256\n        xmlSigKeyInfoKeyNameTransformer: NONE\n        syncMode: IMPORT\n</code></pre>"},{"location":"guides/identity-providers/#idp-mappers","title":"IDP Mappers","text":"<p>Note: Currently, protocol mappers are supported for client scopes, but IDP-specific mappers (attribute importers) will be added in a future release.</p> <p>Protocol mappers allow you to customize the claims/attributes in tokens. Here's an example of protocol mappers on a client scope:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-operator\n\n  clientScopes:\n    - name: custom-claims\n      protocol: openid-connect\n      protocolMappers:\n        - name: groups-mapper\n          protocol: openid-connect\n          protocolMapper: oidc-group-membership-mapper\n          config:\n            claim.name: groups\n            full.path: \"false\"\n            id.token.claim: \"true\"\n            access.token.claim: \"true\"\n            userinfo.token.claim: \"true\"\n</code></pre> <p>For IDP attribute mappers (to import user attributes from the IDP), this functionality is planned for a future release.</p>"},{"location":"guides/identity-providers/#complete-examples","title":"Complete Examples","text":""},{"location":"guides/identity-providers/#multi-idp-setup","title":"Multi-IDP Setup","text":"<p>A realm with multiple identity providers:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: multi-idp-realm\n  namespace: my-app\nspec:\n  realmName: multi-idp\n  operatorRef:\n    namespace: keycloak-operator\n\n  identityProviders:\n    # GitHub for developers\n    - alias: github\n      providerId: github\n      enabled: true\n      trustEmail: false\n      config:\n        clientId: github-client-id\n        clientSecret: github-client-secret\n        defaultScope: \"user:email\"\n        syncMode: IMPORT\n\n    # Google Workspace for employees\n    - alias: google\n      providerId: google\n      enabled: true\n      trustEmail: true\n      config:\n        clientId: google-client-id.apps.googleusercontent.com\n        clientSecret: google-client-secret\n        hostedDomain: \"company.com\"\n        defaultScope: \"openid profile email\"\n        syncMode: FORCE\n\n    # Azure AD for enterprise SSO\n    - alias: azure-ad\n      providerId: oidc\n      enabled: true\n      trustEmail: true\n      config:\n        clientId: azure-client-id\n        clientSecret: azure-client-secret\n        authorizationUrl: https://login.microsoftonline.com/TENANT_ID/oauth2/v2.0/authorize\n        tokenUrl: https://login.microsoftonline.com/TENANT_ID/oauth2/v2.0/token\n        userInfoUrl: https://graph.microsoft.com/oidc/userinfo\n        jwksUrl: https://login.microsoftonline.com/TENANT_ID/discovery/v2.0/keys\n        issuer: https://login.microsoftonline.com/TENANT_ID/v2.0\n        defaultScope: \"openid profile email\"\n        syncMode: FORCE\n        validateSignature: \"true\"\n        useJwksUrl: \"true\"\n</code></pre>"},{"location":"guides/identity-providers/#using-secrets-for-credentials","title":"Using Secrets for Credentials","text":"<p>Best Practice: Store IDP client secrets in Kubernetes Secrets instead of hardcoding them in the CR.</p> <p>Note: This feature is planned for a future release. Currently, secrets must be included in the <code>config</code> directly.</p> <p>Planned syntax (coming soon):</p> <pre><code>identityProviders:\n  - alias: github\n    providerId: github\n    enabled: true\n    trustEmail: false\n    config:\n      clientId: my-github-client-id\n      clientSecretRef:  # Reference to Kubernetes Secret\n        name: github-oauth-secret\n        key: client-secret\n      defaultScope: \"user:email\"\n      syncMode: IMPORT\n</code></pre>"},{"location":"guides/identity-providers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/identity-providers/#common-issues","title":"Common Issues","text":"<p>1. \"Invalid redirect URI\" error: - Verify your redirect URI in the IDP matches exactly: <code>https://your-keycloak-domain/realms/your-realm/broker/{alias}/endpoint</code> - Check for trailing slashes and protocol (http vs https)</p> <p>2. Users can't log in: - Check that <code>enabled: true</code> is set - Verify client ID and secret are correct - Check IDP logs for authentication failures</p> <p>3. User attributes not syncing: - Set <code>syncMode: FORCE</code> to update on every login - Verify the requested scopes include the attributes you need - Check IDP mapper configuration</p> <p>4. Email not trusted: - Set <code>trustEmail: true</code> only for trusted providers - If false, users must verify their email after first login</p>"},{"location":"guides/identity-providers/#checking-idp-status","title":"Checking IDP Status","text":"<p>Verify IDP configuration through the CRD status:</p> <pre><code># Check realm status includes IDP configuration\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o yaml\n\n# Check operator logs for IDP reconciliation\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"identity.*provider\"\n</code></pre>"},{"location":"guides/identity-providers/#see-also","title":"See Also","text":"<ul> <li>KeycloakRealm CRD Reference</li> <li>Quick Start Guide</li> </ul>"},{"location":"guides/observability/","title":"Observability","text":"<p>This document describes the observability features available in the Keycloak operator, including status conditions, metrics, and monitoring capabilities.</p>"},{"location":"guides/observability/#status-conditions","title":"Status Conditions","text":"<p>All custom resources (Keycloak, KeycloakRealm, KeycloakClient) expose Kubernetes-standard status conditions that can be used by GitOps tools like Argo CD and Flux CD to determine resource health.</p>"},{"location":"guides/observability/#standard-conditions","title":"Standard Conditions","text":"<p>Each resource implements the following condition types:</p>"},{"location":"guides/observability/#ready","title":"Ready","text":"<p>Indicates whether the resource is fully reconciled and operational.</p> <ul> <li>Status: <code>True</code>, <code>False</code>, or <code>Unknown</code></li> <li>Reason: <code>ReconciliationSucceeded</code>, <code>ReconciliationFailed</code>, <code>ReconciliationInProgress</code></li> <li>Usage: Primary health indicator for GitOps tools</li> </ul>"},{"location":"guides/observability/#available","title":"Available","text":"<p>Indicates whether the resource is available for use (Kubernetes standard).</p> <ul> <li>Status: <code>True</code> or <code>False</code></li> <li>Reason: <code>ReconciliationSucceeded</code>, <code>ReconciliationFailed</code></li> <li>Usage: Determines if the resource can serve its purpose</li> </ul>"},{"location":"guides/observability/#progressing","title":"Progressing","text":"<p>Indicates an ongoing reconciliation operation (Kubernetes standard).</p> <ul> <li>Status: <code>True</code> or <code>False</code></li> <li>Reason: <code>ReconciliationInProgress</code></li> <li>Usage: Shows active reconciliation work</li> </ul>"},{"location":"guides/observability/#degraded","title":"Degraded","text":"<p>Indicates the resource is operational but not in optimal state.</p> <ul> <li>Status: <code>True</code> or <code>False</code></li> <li>Reason: <code>PartialFunctionality</code>, <code>ReconciliationFailed</code></li> <li>Usage: Alerts about suboptimal conditions</li> </ul>"},{"location":"guides/observability/#checking-resource-status","title":"Checking Resource Status","text":"<p>View the status of a resource:</p> <pre><code># Get resource with status\nkubectl get keycloak my-keycloak -o yaml\n\n# Check conditions specifically\nkubectl get keycloak my-keycloak -o jsonpath='{.status.conditions}' | jq\n\n# Check if a resource is ready\nkubectl get keycloak my-keycloak -o jsonpath='{.status.conditions[?(@.type==\"Ready\")].status}'\n</code></pre>"},{"location":"guides/observability/#example-status-output","title":"Example Status Output","text":"<pre><code>status:\n  phase: Ready\n  message: Keycloak instance is ready\n  lastUpdated: \"2025-10-15T20:00:00Z\"\n  observedGeneration: 5\n  conditions:\n    - type: Ready\n      status: \"True\"\n      reason: ReconciliationSucceeded\n      message: Reconciliation completed successfully\n      lastTransitionTime: \"2025-10-15T20:00:00Z\"\n      observedGeneration: 5\n    - type: Available\n      status: \"True\"\n      reason: ReconciliationSucceeded\n      message: Resource is available\n      lastTransitionTime: \"2025-10-15T20:00:00Z\"\n      observedGeneration: 5\n  deployment: my-keycloak-keycloak\n  service: my-keycloak-keycloak\n  endpoints:\n    admin: http://my-keycloak-keycloak.default.svc.cluster.local:8080\n    public: http://my-keycloak-keycloak.default.svc.cluster.local:8080\n    management: http://my-keycloak-keycloak.default.svc.cluster.local:9000\n</code></pre>"},{"location":"guides/observability/#observedgeneration","title":"ObservedGeneration","text":"<p>All resources track <code>observedGeneration</code> which indicates the generation of the spec that was last reconciled. This is crucial for GitOps workflows:</p> <ul> <li>Match: When <code>status.observedGeneration</code> equals <code>metadata.generation</code>, the resource is fully reconciled</li> <li>Mismatch: When they differ, reconciliation is pending or in progress</li> <li>Usage: GitOps tools use this to detect drift and sync status</li> </ul> <p>Example check:</p> <pre><code># Check if resource is fully synced\nkubectl get keycloak my-keycloak -o json | \\\n  jq 'if .status.observedGeneration == .metadata.generation then \"Synced\" else \"OutOfSync\" end'\n</code></pre>"},{"location":"guides/observability/#resource-specific-status-fields","title":"Resource-Specific Status Fields","text":""},{"location":"guides/observability/#keycloak-status","title":"Keycloak Status","text":"<pre><code>status:\n  deployment: my-keycloak-keycloak  # Name of the deployment\n  service: my-keycloak-keycloak      # Name of the service\n  adminSecret: my-keycloak-admin-credentials  # Admin credentials secret\n  endpoints:\n    admin: http://...    # Admin API endpoint\n    public: http://...   # Public endpoint\n    management: http://... # Management endpoint (health checks)\n</code></pre>"},{"location":"guides/observability/#keycloakrealm-status","title":"KeycloakRealm Status","text":"<pre><code>status:\n  realmName: my-realm  # Actual realm name in Keycloak\n  keycloakInstance: default/keycloak  # Referenced Keycloak instance\n  features:\n    userRegistration: true\n    passwordReset: true\n    identityProviders: 2\n    userFederationProviders: 1\n    customThemes: true\n</code></pre>"},{"location":"guides/observability/#keycloakclient-status","title":"KeycloakClient Status","text":"<pre><code>status:\n  client_id: my-client  # Client ID\n  client_uuid: abc-123  # UUID in Keycloak\n  realm: my-realm  # Realm name\n  keycloak_instance: default/keycloak  # Keycloak instance reference\n  credentials_secret: my-client-credentials  # Client credentials secret\n  public_client: false  # Whether this is a public client\n  endpoints:\n    auth: https://keycloak.example.com/realms/my-realm\n    token: https://keycloak.example.com/realms/my-realm/protocol/openid-connect/token\n    userinfo: https://keycloak.example.com/realms/my-realm/protocol/openid-connect/userinfo\n</code></pre>"},{"location":"guides/observability/#prometheus-metrics","title":"Prometheus Metrics","text":"<p>The operator exposes Prometheus metrics on port 8080 at <code>/metrics</code>.</p>"},{"location":"guides/observability/#available-metrics","title":"Available Metrics","text":""},{"location":"guides/observability/#reconciliation-metrics","title":"Reconciliation Metrics","text":"<pre><code># Reconciliation operations counter\nkopf_reconciliation_total{resource_type=\"keycloak|realm|client\", namespace=\"...\", name=\"...\", operation=\"reconcile|update|delete\"}\n\n# Reconciliation duration histogram\nkopf_reconciliation_duration_seconds{resource_type=\"...\", namespace=\"...\", name=\"...\", operation=\"...\"}\n\n# Active reconciliations gauge\nkopf_reconciliation_active{resource_type=\"...\", namespace=\"...\", operation=\"...\"}\n</code></pre>"},{"location":"guides/observability/#resource-status-metrics","title":"Resource Status Metrics","text":"<pre><code># Resource status by phase\nkeycloak_operator_resource_status{resource_type=\"keycloak|realm|client\", namespace=\"...\", phase=\"Ready|Failed|Pending\"}\n</code></pre>"},{"location":"guides/observability/#error-metrics","title":"Error Metrics","text":"<pre><code># Error counter by type\nkeycloak_operator_errors_total{error_type=\"...\", resource_type=\"...\", namespace=\"...\"}\n</code></pre>"},{"location":"guides/observability/#scraping-metrics","title":"Scraping Metrics","text":"<p>Configure Prometheus to scrape the operator:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: keycloak-operator-metrics\n  labels:\n    app: keycloak-operator\nspec:\n  ports:\n    - name: metrics\n      port: 8080\n      targetPort: 8080\n  selector:\n    app: keycloak-operator\n---\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: keycloak-operator\nspec:\n  selector:\n    matchLabels:\n      app: keycloak-operator\n  endpoints:\n    - port: metrics\n      interval: 30s\n</code></pre>"},{"location":"guides/observability/#logging","title":"Logging","text":"<p>The operator uses structured logging with correlation IDs for request tracing.</p>"},{"location":"guides/observability/#log-levels","title":"Log Levels","text":"<ul> <li>DEBUG: Detailed operational information</li> <li>INFO: General operational messages</li> <li>WARNING: Warning conditions (degraded but functioning)</li> <li>ERROR: Error conditions requiring attention</li> </ul>"},{"location":"guides/observability/#viewing-logs","title":"Viewing Logs","text":"<pre><code># Follow operator logs\nkubectl logs -f -l app=keycloak-operator -n keycloak-operator-system\n\n# View logs with correlation ID\nkubectl logs -l app=keycloak-operator -n keycloak-operator-system | grep \"correlation_id=abc-123\"\n\n# Check reconciliation logs for specific resource\nkubectl logs -l app=keycloak-operator -n keycloak-operator-system | \\\n  grep \"resource_name=my-keycloak\"\n</code></pre>"},{"location":"guides/observability/#log-format","title":"Log Format","text":"<p>Logs include structured fields:</p> <pre><code>{\n  \"timestamp\": \"2025-10-15T20:00:00Z\",\n  \"level\": \"INFO\",\n  \"logger\": \"KeycloakReconciler\",\n  \"message\": \"Reconciliation completed successfully\",\n  \"resource_type\": \"keycloak\",\n  \"resource_name\": \"my-keycloak\",\n  \"namespace\": \"default\",\n  \"correlation_id\": \"abc-123\",\n  \"duration\": 2.5\n}\n</code></pre>"},{"location":"guides/observability/#health-checks","title":"Health Checks","text":"<p>The operator pod exposes health endpoints:</p> <ul> <li>Liveness: HTTP GET on <code>/healthz</code> (port 8080)</li> <li>Readiness: HTTP GET on <code>/ready</code> (port 8080)</li> </ul>"},{"location":"guides/observability/#gitops-integration","title":"GitOps Integration","text":""},{"location":"guides/observability/#argo-cd-health-assessment","title":"Argo CD Health Assessment","text":"<p>Argo CD automatically uses the <code>Ready</code> condition to determine resource health:</p> <pre><code># Argo CD will show:\n# - Healthy: Ready=True\n# - Progressing: Progressing=True or observedGeneration mismatch\n# - Degraded: Ready=False or Degraded=True\n</code></pre>"},{"location":"guides/observability/#flux-cd-health-assessment","title":"Flux CD Health Assessment","text":"<p>Flux CD checks the <code>Ready</code> condition and <code>observedGeneration</code>:</p> <pre><code>apiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: keycloak-resources\nspec:\n  healthChecks:\n    - apiVersion: vriesdemichael.github.io/v1\n      kind: Keycloak\n      name: my-keycloak\n      namespace: default\n</code></pre>"},{"location":"guides/observability/#circuit-breaker-status","title":"Circuit Breaker Status","text":"<p>The operator uses a circuit breaker to protect the Keycloak API from overload. When the circuit breaker opens:</p> <ol> <li>The operator logs: <code>Circuit breaker open for Keycloak at http://...</code></li> <li>API calls return HTTP 503 (Service Unavailable)</li> <li>Reconciliation is retried with exponential backoff</li> <li>The circuit resets after 60 seconds of no failures</li> </ol> <p>Check circuit breaker state in logs:</p> <pre><code>kubectl logs -l app=keycloak-operator | grep \"circuit breaker\"\n</code></pre>"},{"location":"guides/observability/#troubleshooting-with-status","title":"Troubleshooting with Status","text":""},{"location":"guides/observability/#resource-stuck-in-pending","title":"Resource Stuck in Pending","text":"<pre><code># Check status conditions\nkubectl describe keycloak my-keycloak\n\n# Look for the message in status\nkubectl get keycloak my-keycloak -o jsonpath='{.status.message}'\n\n# Check if generation matches (sync status)\nkubectl get keycloak my-keycloak -o json | \\\n  jq '{generation: .metadata.generation, observedGeneration: .status.observedGeneration}'\n</code></pre>"},{"location":"guides/observability/#reconciliation-failures","title":"Reconciliation Failures","text":"<pre><code># Check Ready condition for reason\nkubectl get keycloak my-keycloak -o json | \\\n  jq '.status.conditions[] | select(.type==\"Ready\")'\n\n# View recent events\nkubectl get events --field-selector involvedObject.name=my-keycloak\n\n# Check operator logs for this resource\nkubectl logs -l app=keycloak-operator | grep \"resource_name=my-keycloak\"\n</code></pre>"},{"location":"guides/observability/#performance-issues","title":"Performance Issues","text":"<pre><code># Query Prometheus for slow reconciliations\nhistogram_quantile(0.95,\n  rate(kopf_reconciliation_duration_seconds_bucket[5m])\n) by (resource_type)\n\n# Check active reconciliation count\nkopf_reconciliation_active\n</code></pre>"},{"location":"guides/user-federation/","title":"User Federation Guide","text":"<p>This guide explains how to configure LDAP, Active Directory, and Kerberos user federation with the Keycloak Operator.</p>"},{"location":"guides/user-federation/#overview","title":"Overview","text":"<p>User federation allows Keycloak to authenticate users against external identity stores like LDAP directories or Active Directory. The operator supports:</p> <ul> <li>LDAP - Standard LDAP directories (OpenLDAP, FreeIPA, etc.)</li> <li>Active Directory - Microsoft Active Directory with sAMAccountName/UPN support</li> <li>Kerberos - SPNEGO/Kerberos authentication integrated with LDAP</li> </ul>"},{"location":"guides/user-federation/#prerequisites","title":"Prerequisites","text":"<ol> <li>A running Keycloak instance managed by the operator</li> <li>Network connectivity between Keycloak pods and your LDAP/AD server</li> <li>A bind account with read access to your directory</li> </ol>"},{"location":"guides/user-federation/#configuration","title":"Configuration","text":""},{"location":"guides/user-federation/#basic-ldap-federation","title":"Basic LDAP Federation","text":"<pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-namespace\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-system\n\n  userFederation:\n    - name: corporate-ldap\n      providerId: ldap\n      connectionUrl: \"ldap://ldap.example.com:389\"\n      bindDn: \"cn=readonly,dc=example,dc=com\"\n      bindCredentialSecret:\n        name: ldap-credentials\n        key: password\n      usersDn: \"ou=People,dc=example,dc=com\"\n      vendor: other\n      usernameLdapAttribute: uid\n      uuidLdapAttribute: entryUUID\n      userObjectClasses:\n        - inetOrgPerson\n        - organizationalPerson\n      editMode: READ_ONLY\n      syncSettings:\n        importEnabled: true\n        fullSyncPeriod: 86400  # Full sync daily\n        changedUsersSyncPeriod: 3600  # Changed users sync hourly\n</code></pre>"},{"location":"guides/user-federation/#active-directory-configuration","title":"Active Directory Configuration","text":"<pre><code>userFederation:\n  - name: corporate-ad\n    providerId: ldap\n    connectionUrl: \"ldaps://dc.corp.example.com:636\"\n    bindDn: \"CN=Keycloak Service,OU=ServiceAccounts,DC=corp,DC=example,DC=com\"\n    bindCredentialSecret:\n      name: ad-credentials\n      key: password\n    usersDn: \"OU=Users,DC=corp,DC=example,DC=com\"\n    vendor: ad  # Important: Set to 'ad' for Active Directory\n    usernameLdapAttribute: sAMAccountName\n    uuidLdapAttribute: objectGUID\n    rdnLdapAttribute: cn\n    userObjectClasses:\n      - user\n      - organizationalPerson\n    trustEmail: true\n    startTls: false  # Using LDAPS on port 636\n    mappers:\n      - name: upn-mapper\n        mapperType: user-attribute-ldap-mapper\n        config:\n          ldap.attribute: userPrincipalName\n          user.model.attribute: username\n          read.only: \"true\"\n</code></pre>"},{"location":"guides/user-federation/#kerberosspnego-authentication","title":"Kerberos/SPNEGO Authentication","text":"<p>For environments using Kerberos authentication:</p> <pre><code>userFederation:\n  - name: kerberos-ldap\n    providerId: ldap\n    connectionUrl: \"ldap://ldap.example.com:389\"\n    bindDn: \"cn=readonly,dc=example,dc=com\"\n    bindCredentialSecret:\n      name: ldap-credentials\n      key: password\n    usersDn: \"ou=People,dc=example,dc=com\"\n    vendor: other\n\n    # Kerberos settings\n    allowKerberosAuthentication: true\n    kerberosRealm: EXAMPLE.COM\n    serverPrincipal: HTTP/keycloak.example.com@EXAMPLE.COM\n    keytabSecret:\n      name: kerberos-keytab\n      key: keytab\n    useKerberosForPasswordAuthentication: true\n    debug: false\n</code></pre>"},{"location":"guides/user-federation/#creating-secrets","title":"Creating Secrets","text":"<p>Secrets must be labeled to allow operator access:</p> <pre><code># Create the bind credential secret\nkubectl create secret generic ldap-credentials \\\n  --from-literal=password='your-ldap-password' \\\n  -n your-namespace\n\n# Label it for operator access\nkubectl label secret ldap-credentials \\\n  vriesdemichael.github.io/keycloak-allow-operator-read=true \\\n  -n your-namespace\n</code></pre> <p>For Kerberos keytab:</p> <pre><code># Create keytab secret from file\nkubectl create secret generic kerberos-keytab \\\n  --from-file=keytab=/path/to/keycloak.keytab \\\n  -n your-namespace\n\nkubectl label secret kerberos-keytab \\\n  vriesdemichael.github.io/keycloak-allow-operator-read=true \\\n  -n your-namespace\n</code></pre>"},{"location":"guides/user-federation/#federation-mappers","title":"Federation Mappers","text":"<p>Mappers transform LDAP attributes to Keycloak user properties:</p> <pre><code>mappers:\n  # Map email attribute\n  - name: email-mapper\n    mapperType: user-attribute-ldap-mapper\n    config:\n      ldap.attribute: mail\n      user.model.attribute: email\n      read.only: \"true\"\n      always.read.value.from.ldap: \"true\"\n      is.mandatory.in.ldap: \"false\"\n\n  # Map first name\n  - name: first-name-mapper\n    mapperType: user-attribute-ldap-mapper\n    config:\n      ldap.attribute: givenName\n      user.model.attribute: firstName\n      read.only: \"true\"\n\n  # Map groups from LDAP\n  - name: group-mapper\n    mapperType: group-ldap-mapper\n    config:\n      groups.dn: \"ou=Groups,dc=example,dc=com\"\n      group.name.ldap.attribute: cn\n      group.object.classes: groupOfNames\n      membership.ldap.attribute: member\n      membership.user.ldap.attribute: dn\n      mode: READ_ONLY\n</code></pre>"},{"location":"guides/user-federation/#edit-modes","title":"Edit Modes","text":"Mode Description <code>READ_ONLY</code> Users are imported from LDAP but cannot be modified in Keycloak <code>WRITABLE</code> Changes in Keycloak are synced back to LDAP <code>UNSYNCED</code> Users are imported but changes are stored only in Keycloak"},{"location":"guides/user-federation/#sync-settings","title":"Sync Settings","text":"Setting Description <code>importEnabled</code> Whether to import users from LDAP <code>fullSyncPeriod</code> Interval (seconds) for full sync, -1 to disable <code>changedUsersSyncPeriod</code> Interval for syncing changed users, -1 to disable <code>syncRegistrations</code> Sync newly registered users to LDAP (if WRITABLE)"},{"location":"guides/user-federation/#monitoring","title":"Monitoring","text":"<p>The operator exposes Prometheus metrics for federation monitoring:</p> <ul> <li><code>keycloak_operator_user_federation_status</code> - Connection status (1=connected)</li> <li><code>keycloak_operator_user_federation_synced_users</code> - Imported user count</li> <li><code>keycloak_operator_user_federation_sync_errors_total</code> - Sync error count</li> <li><code>keycloak_operator_user_federation_sync_duration_seconds</code> - Sync duration</li> </ul>"},{"location":"guides/user-federation/#status","title":"Status","text":"<p>Federation status is reported in the realm's status field:</p> <pre><code>kubectl get keycloakrealm my-realm -o jsonpath='{.status.userFederationStatus}'\n</code></pre> <p>Each provider reports: - <code>connected</code> - Whether the connection is healthy - <code>lastSyncResult</code> - Result of last sync (Success/Failed/Never) - <code>usersImported</code> - Number of imported users - <code>syncErrors</code> - Count of sync errors</p>"},{"location":"guides/user-federation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/user-federation/#connection-issues","title":"Connection Issues","text":"<ol> <li> <p>Verify network connectivity from Keycloak pods:    <pre><code>kubectl exec -it deploy/keycloak -- /bin/bash -c \"nc -zv ldap.example.com 389\"\n</code></pre></p> </li> <li> <p>Check that the bind credentials are correct</p> </li> <li> <p>For LDAPS, ensure certificates are trusted</p> </li> </ol>"},{"location":"guides/user-federation/#sync-issues","title":"Sync Issues","text":"<ol> <li> <p>Check operator logs for federation errors:    <pre><code>kubectl logs -l app.kubernetes.io/name=keycloak-operator -f | grep federation\n</code></pre></p> </li> <li> <p>Verify the <code>usersDn</code> path exists and contains users</p> </li> <li> <p>Check that <code>userObjectClasses</code> matches your LDAP schema</p> </li> </ol>"},{"location":"guides/user-federation/#kerberos-issues","title":"Kerberos Issues","text":"<ol> <li> <p>Verify the keytab contains the correct service principal:    <pre><code>klist -k /path/to/keycloak.keytab\n</code></pre></p> </li> <li> <p>Ensure DNS is properly configured for Kerberos realm</p> </li> <li> <p>Check that Keycloak pods can reach the KDC on port 88</p> </li> </ol>"},{"location":"how-to/backup-restore/","title":"Backup &amp; Restore Guide","text":"<p>Backup and restore procedures for Keycloak and PostgreSQL database using CloudNativePG.</p>"},{"location":"how-to/backup-restore/#what-gets-backed-up","title":"What Gets Backed Up","text":"Component Content Backup Method Database Users, realms, clients, sessions CloudNativePG barman Kubernetes Resources CRDs, manifests kubectl export Token Metadata Token rotation state ConfigMap backup Secrets Credentials (\u26a0\ufe0f encrypt) kubectl export <p>Not Backed Up: Operator code, container images (use image registry).</p>"},{"location":"how-to/backup-restore/#quick-backup","title":"Quick Backup","text":""},{"location":"how-to/backup-restore/#one-command-backup","title":"One-Command Backup","text":"<pre><code>#!/bin/bash\nBACKUP_DIR=\"keycloak-backup-$(date +%Y%m%d-%H%M%S)\"\nmkdir -p ${BACKUP_DIR}\n\n# Backup Kubernetes resources\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces -o yaml \\\n  &gt; ${BACKUP_DIR}/resources.yaml\n\n# Backup token metadata\nkubectl get configmap keycloak-operator-token-metadata \\\n  -n keycloak-operator-system -o yaml \\\n  &gt; ${BACKUP_DIR}/token-metadata.yaml\n\n# Trigger database backup\nkubectl cnpg backup keycloak-db -n keycloak-db\n\necho \"Backup complete: ${BACKUP_DIR}\"\n</code></pre>"},{"location":"how-to/backup-restore/#database-backup","title":"Database Backup","text":""},{"location":"how-to/backup-restore/#configure-automatic-backups","title":"Configure Automatic Backups","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3\n\n  backup:\n    barmanObjectStore:\n      destinationPath: s3://my-backup-bucket/keycloak-db\n      s3Credentials:\n        accessKeyId:\n          name: backup-s3-credentials\n          key: ACCESS_KEY_ID\n        secretAccessKey:\n          name: backup-s3-credentials\n          key: ACCESS_SECRET_KEY\n      wal:\n        compression: gzip\n      data:\n        compression: gzip\n    retentionPolicy: \"30d\"\n</code></pre>"},{"location":"how-to/backup-restore/#scheduled-backups","title":"Scheduled Backups","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: ScheduledBackup\nmetadata:\n  name: keycloak-db-daily\n  namespace: keycloak-db\nspec:\n  schedule: \"0 2 * * *\"  # Daily at 2 AM\n  backupOwnerReference: self\n  cluster:\n    name: keycloak-db\n</code></pre>"},{"location":"how-to/backup-restore/#manual-backup","title":"Manual Backup","text":"<pre><code># Trigger backup\nkubectl cnpg backup keycloak-db -n keycloak-db\n\n# List backups\nkubectl get backup -n keycloak-db\n\n# Check backup status\nkubectl describe backup &lt;backup-name&gt; -n keycloak-db\n</code></pre>"},{"location":"how-to/backup-restore/#kubernetes-resources-backup","title":"Kubernetes Resources Backup","text":""},{"location":"how-to/backup-restore/#backup-script","title":"Backup Script","text":"<pre><code>#!/bin/bash\nBACKUP_DIR=\"k8s-backup-$(date +%Y%m%d)\"\nmkdir -p ${BACKUP_DIR}\n\n# Backup all Keycloak resources\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces -o yaml \\\n  &gt; ${BACKUP_DIR}/keycloak-resources.yaml\n\n# Backup operator configuration\nhelm get values keycloak-operator -n keycloak-operator-system \\\n  &gt; ${BACKUP_DIR}/operator-values.yaml\n\n# Backup token metadata\nkubectl get configmap keycloak-operator-token-metadata \\\n  -n keycloak-operator-system -o yaml \\\n  &gt; ${BACKUP_DIR}/token-metadata.yaml\n\n# Backup CRDs\nkubectl get crd -o yaml | grep -A1000 \"vriesdemichael.github.io\" \\\n  &gt; ${BACKUP_DIR}/crds.yaml\n\n# Backup secrets (\u26a0\ufe0f ENCRYPT THIS FILE)\nkubectl get secret --all-namespaces -l vriesdemichael.github.io/managed-by=keycloak-operator \\\n  -o yaml &gt; ${BACKUP_DIR}/secrets.yaml\n\necho \"Backup saved to: ${BACKUP_DIR}\"\necho \"\u26a0\ufe0f IMPORTANT: Encrypt secrets.yaml before storing!\"\n</code></pre>"},{"location":"how-to/backup-restore/#encrypt-secrets","title":"Encrypt Secrets","text":"<pre><code># Using GPG\ngpg --symmetric --cipher-algo AES256 ${BACKUP_DIR}/secrets.yaml\n\n# Using age\nage -p ${BACKUP_DIR}/secrets.yaml &gt; ${BACKUP_DIR}/secrets.yaml.age\n\n# Remove plaintext\nrm ${BACKUP_DIR}/secrets.yaml\n</code></pre>"},{"location":"how-to/backup-restore/#database-restore","title":"Database Restore","text":""},{"location":"how-to/backup-restore/#full-cluster-restore","title":"Full Cluster Restore","text":"<pre><code># 1. Delete existing cluster (\u26a0\ufe0f DOWNTIME)\nkubectl delete cluster keycloak-db -n keycloak-db\n\n# 2. Wait for PVCs to be deleted\nkubectl get pvc -n keycloak-db\n\n# 3. Create restore manifest\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3\n\n  bootstrap:\n    recovery:\n      source: keycloak-db-backup\n\n  externalClusters:\n    - name: keycloak-db-backup\n      barmanObjectStore:\n        destinationPath: s3://my-backup-bucket/keycloak-db\n        s3Credentials:\n          accessKeyId:\n            name: backup-s3-credentials\n            key: ACCESS_KEY_ID\n          secretAccessKey:\n            name: backup-s3-credentials\n            key: ACCESS_SECRET_KEY\nEOF\n\n# 4. Wait for restore\nkubectl wait --for=condition=Ready cluster/keycloak-db \\\n  -n keycloak-db --timeout=10m\n\n# 5. Verify data\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"SELECT COUNT(*) FROM public.realm;\"\n</code></pre>"},{"location":"how-to/backup-restore/#point-in-time-restore","title":"Point-in-Time Restore","text":"<pre><code>bootstrap:\n  recovery:\n    source: keycloak-db-backup\n    recoveryTarget:\n      targetTime: \"2025-01-15 10:00:00+00\"  # UTC timestamp\n</code></pre>"},{"location":"how-to/backup-restore/#restore-to-new-cluster","title":"Restore to New Cluster","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db-restored  # Different name\n  namespace: keycloak-db\nspec:\n  instances: 3\n  bootstrap:\n    recovery:\n      source: keycloak-db-backup\n\n  externalClusters:\n    - name: keycloak-db-backup\n      barmanObjectStore:\n        destinationPath: s3://my-backup-bucket/keycloak-db\n        s3Credentials:\n          accessKeyId:\n            name: backup-s3-credentials\n            key: ACCESS_KEY_ID\n          secretAccessKey:\n            name: backup-s3-credentials\n            key: ACCESS_SECRET_KEY\n</code></pre>"},{"location":"how-to/backup-restore/#kubernetes-resources-restore","title":"Kubernetes Resources Restore","text":""},{"location":"how-to/backup-restore/#restore-all-resources","title":"Restore All Resources","text":"<pre><code># 1. Restore CRDs first\nkubectl apply -f k8s-backup-20250115/crds.yaml\n\n# 2. Restore secrets (decrypt first)\ngpg --decrypt k8s-backup-20250115/secrets.yaml.gpg | kubectl apply -f -\n\n# 3. Restore token metadata\nkubectl apply -f k8s-backup-20250115/token-metadata.yaml\n\n# 4. Restore Keycloak resources\nkubectl apply -f k8s-backup-20250115/keycloak-resources.yaml\n\n# 5. Verify\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces\n</code></pre>"},{"location":"how-to/backup-restore/#selective-restore","title":"Selective Restore","text":"<pre><code># Restore single realm\nkubectl get -f k8s-backup-20250115/keycloak-resources.yaml \\\n  keycloakrealm/my-realm -n my-app -o yaml | kubectl apply -f -\n\n# Restore single namespace\nkubectl get -f k8s-backup-20250115/keycloak-resources.yaml \\\n  --namespace=my-app -o yaml | kubectl apply -f -\n</code></pre>"},{"location":"how-to/backup-restore/#disaster-recovery-procedures","title":"Disaster Recovery Procedures","text":""},{"location":"how-to/backup-restore/#scenario-1-database-corruption","title":"Scenario 1: Database Corruption","text":"<p>Symptoms: Data integrity errors, query failures.</p> <p>Recovery: <pre><code># 1. Scale down Keycloak (prevent new writes)\nkubectl scale keycloak keycloak -n keycloak-system --replicas=0\n\n# 2. Restore database from backup (see above)\n\n# 3. Verify database integrity\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"\n    SELECT tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename))\n    FROM pg_tables WHERE schemaname = 'public' LIMIT 5;\n  \"\n\n# 4. Scale up Keycloak\nkubectl scale keycloak keycloak -n keycloak-system --replicas=3\n\n# 5. Test authentication\n</code></pre></p> <p>RTO: 15-30 minutes RPO: Time since last backup</p>"},{"location":"how-to/backup-restore/#scenario-2-accidental-resource-deletion","title":"Scenario 2: Accidental Resource Deletion","text":"<p>Symptoms: Realm/client deleted from Kubernetes and Keycloak.</p> <p>Recovery: <pre><code># 1. Find resource in backup\ngrep -A50 \"name: my-realm\" k8s-backup-20250115/keycloak-resources.yaml\n\n# 2. Restore resource\nkubectl apply -f - &lt;&lt;EOF\n# (paste resource YAML)\nEOF\n\n# 3. Verify reconciliation\nkubectl describe keycloakrealm my-realm -n my-app\n</code></pre></p> <p>RTO: 5-10 minutes RPO: Last backup time</p>"},{"location":"how-to/backup-restore/#scenario-3-complete-cluster-loss","title":"Scenario 3: Complete Cluster Loss","text":"<p>Symptoms: Entire Kubernetes cluster destroyed.</p> <p>Recovery: <pre><code># 1. Deploy new Kubernetes cluster\n\n# 2. Install operators\nhelm install cnpg cnpg/cloudnative-pg -n cnpg-system --create-namespace\nhelm install keycloak-operator ./charts/keycloak-operator -n keycloak-operator-system --create-namespace\n\n# 3. Restore database\n# (Use Full Cluster Restore procedure above)\n\n# 4. Restore Kubernetes resources\n# (Use Kubernetes Resources Restore procedure above)\n\n# 5. Verify end-to-end\n</code></pre></p> <p>RTO: 2-4 hours RPO: Last backup time</p>"},{"location":"how-to/backup-restore/#backup-verification","title":"Backup Verification","text":""},{"location":"how-to/backup-restore/#test-restore-monthly","title":"Test Restore Monthly","text":"<pre><code>#!/bin/bash\n# Monthly backup test script\n\n# 1. Create test namespace\nkubectl create namespace backup-test\n\n# 2. Restore database to test cluster\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db-test\n  namespace: backup-test\nspec:\n  instances: 1\n  bootstrap:\n    recovery:\n      source: keycloak-db-backup\n  externalClusters:\n    - name: keycloak-db-backup\n      barmanObjectStore:\n        destinationPath: s3://my-backup-bucket/keycloak-db\n        s3Credentials:\n          accessKeyId:\n            name: backup-s3-credentials\n            key: ACCESS_KEY_ID\n          secretAccessKey:\n            name: backup-s3-credentials\n            key: ACCESS_SECRET_KEY\nEOF\n\n# 3. Wait for restore\nkubectl wait --for=condition=Ready cluster/keycloak-db-test -n backup-test --timeout=10m\n\n# 4. Verify data\nkubectl exec -it -n backup-test keycloak-db-test-1 -- \\\n  psql -U keycloak -d keycloak -c \"\n    SELECT COUNT(*) FROM public.realm;\n    SELECT COUNT(*) FROM public.user_entity;\n    SELECT COUNT(*) FROM public.client;\n  \"\n\n# 5. Cleanup\nkubectl delete namespace backup-test\n\necho \"Backup test complete \u2713\"\n</code></pre>"},{"location":"how-to/backup-restore/#backup-monitoring","title":"Backup Monitoring","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: backup-alerts\n  namespace: keycloak-db\nspec:\n  groups:\n    - name: backups\n      rules:\n        - alert: BackupFailed\n          expr: increase(cnpg_backup_failures_total[1h]) &gt; 0\n          labels:\n            severity: critical\n          annotations:\n            summary: \"Backup failed for {{ $labels.cluster }}\"\n\n        - alert: BackupOld\n          expr: time() - cnpg_backup_last_success_timestamp &gt; 86400\n          labels:\n            severity: warning\n          annotations:\n            summary: \"No successful backup in 24h for {{ $labels.cluster }}\"\n</code></pre>"},{"location":"how-to/backup-restore/#best-practices","title":"Best Practices","text":""},{"location":"how-to/backup-restore/#1-backup-frequency","title":"1. Backup Frequency","text":"Environment Database Kubernetes Resources Retention Production Hourly Daily 30 days Staging Daily Weekly 14 days Development Daily Weekly 7 days"},{"location":"how-to/backup-restore/#2-storage-strategy","title":"2. Storage Strategy","text":"<ul> <li>Primary: S3/GCS/Azure Blob (encrypted)</li> <li>Secondary: Different region/provider</li> <li>Tertiary: Offline/tape (compliance)</li> </ul>"},{"location":"how-to/backup-restore/#3-encryption","title":"3. Encryption","text":"<p>Always encrypt backups containing: - Kubernetes secrets - Database dumps - Token metadata</p>"},{"location":"how-to/backup-restore/#4-testing","title":"4. Testing","text":"<ul> <li>Monthly restore tests (automated)</li> <li>Quarterly disaster recovery drills</li> <li>Document restore procedures</li> <li>Train team on restore process</li> </ul>"},{"location":"how-to/backup-restore/#5-retention","title":"5. Retention","text":"<pre><code>retentionPolicy: \"30d\"  # Base backups\n  # WAL archives retained for PITR within retention window\n</code></pre>"},{"location":"how-to/backup-restore/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/backup-restore/#backup-fails-with-s3-error","title":"Backup Fails with S3 Error","text":"<pre><code># Test S3 access\nkubectl run aws-cli --rm -it --image=amazon/aws-cli -- \\\n  s3 ls s3://my-backup-bucket/ --region us-east-1\n\n# Verify credentials\nkubectl get secret backup-s3-credentials -n keycloak-db -o yaml\n</code></pre>"},{"location":"how-to/backup-restore/#restore-hangs","title":"Restore Hangs","text":"<pre><code># Check cluster events\nkubectl describe cluster keycloak-db -n keycloak-db\n\n# Check pod logs\nkubectl logs -n keycloak-db keycloak-db-1\n\n# Verify backup exists\nkubectl run aws-cli --rm -it --image=amazon/aws-cli -- \\\n  s3 ls s3://my-backup-bucket/keycloak-db/base/\n</code></pre>"},{"location":"how-to/backup-restore/#data-mismatch-after-restore","title":"Data Mismatch After Restore","text":"<pre><code># Check backup timestamp\nkubectl describe backup &lt;backup-name&gt; -n keycloak-db\n\n# Verify you restored correct backup\n# Consider point-in-time recovery if needed\n</code></pre>"},{"location":"how-to/backup-restore/#related-documentation","title":"Related Documentation","text":"<ul> <li>Database Setup Guide</li> <li>HA Deployment Guide</li> <li>Troubleshooting Guide</li> <li>CloudNativePG Backup Documentation</li> </ul>"},{"location":"how-to/database-setup/","title":"Database Setup Guide","text":"<p>This guide covers PostgreSQL database setup for Keycloak using CloudNativePG (CNPG), including configuration, backup, restore, and high availability.</p>"},{"location":"how-to/database-setup/#overview","title":"Overview","text":"<p>Keycloak requires a PostgreSQL database for storing: - Realm configurations - User data - Sessions - Client configurations - Events and audit logs</p> <p>Recommended Approach: CloudNativePG (CNPG) operator for Kubernetes-native PostgreSQL management.</p>"},{"location":"how-to/database-setup/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to/database-setup/#required","title":"Required","text":"<ul> <li>Kubernetes cluster 1.26+</li> <li>CloudNativePG operator installed</li> <li>Storage class available</li> <li>Sufficient storage (50GB+ recommended)</li> </ul>"},{"location":"how-to/database-setup/#install-cloudnativepg-operator","title":"Install CloudNativePG Operator","text":"<pre><code># Add Helm repository\nhelm repo add cnpg https://cloudnative-pg.io/charts\nhelm repo update\n\n# Install CNPG operator\nhelm install cnpg cnpg/cloudnative-pg \\\n  --namespace cnpg-system \\\n  --create-namespace \\\n  --set monitoring.podMonitorEnabled=true\n\n# Verify installation\nkubectl get pods -n cnpg-system\n# Expected: cnpg-cloudnative-pg-xxx Running\n</code></pre>"},{"location":"how-to/database-setup/#quick-start-basic-postgresql-cluster","title":"Quick Start: Basic PostgreSQL Cluster","text":""},{"location":"how-to/database-setup/#1-create-namespace","title":"1. Create Namespace","text":"<pre><code>kubectl create namespace keycloak-db\n</code></pre>"},{"location":"how-to/database-setup/#2-create-database-credentials","title":"2. Create Database Credentials","text":"<pre><code># Generate secure password\nDB_PASSWORD=$(python3 -c 'import secrets; print(secrets.token_urlsafe(32))')\n\n# Create secret\nkubectl create secret generic keycloak-db-credentials \\\n  --from-literal=username=keycloak \\\n  --from-literal=password=\"$DB_PASSWORD\" \\\n  --namespace=keycloak-db\n\n# Store password securely (for admin access)\necho \"Database password: $DB_PASSWORD\" &gt; keycloak-db-password.txt\nchmod 600 keycloak-db-password.txt\n</code></pre>"},{"location":"how-to/database-setup/#3-deploy-postgresql-cluster","title":"3. Deploy PostgreSQL Cluster","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3  # 1 primary + 2 replicas\n\n  postgresql:\n    parameters:\n      max_connections: \"200\"\n      shared_buffers: \"256MB\"\n\n  bootstrap:\n    initdb:\n      database: keycloak\n      owner: keycloak\n      secret:\n        name: keycloak-db-credentials\n\n  storage:\n    size: 50Gi\nEOF\n</code></pre>"},{"location":"how-to/database-setup/#4-verify-cluster","title":"4. Verify Cluster","text":"<pre><code># Check cluster status\nkubectl get cluster -n keycloak-db\n# Expected: keycloak-db   Cluster in healthy state   3   3m\n\n# Check pods\nkubectl get pods -n keycloak-db\n# Expected: 3 pods running\n\n# Identify primary\nkubectl get cluster keycloak-db -n keycloak-db \\\n  -o jsonpath='{.status.currentPrimary}'\n\n# Test connection\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"SELECT version();\"\n</code></pre>"},{"location":"how-to/database-setup/#production-configuration","title":"Production Configuration","text":""},{"location":"how-to/database-setup/#storage-configuration","title":"Storage Configuration","text":""},{"location":"how-to/database-setup/#cloud-provider-storage-classes","title":"Cloud Provider Storage Classes","text":"<p>AWS EBS (gp3): <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast-ssd\nprovisioner: ebs.csi.aws.com\nparameters:\n  type: gp3\n  iops: \"3000\"\n  throughput: \"125\"\nallowVolumeExpansion: true\n</code></pre></p> <p>GCP Persistent Disk (SSD): <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast-ssd\nprovisioner: pd.csi.storage.gke.io\nparameters:\n  type: pd-ssd\nallowVolumeExpansion: true\n</code></pre></p> <p>Azure Disk (Premium SSD): <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: fast-ssd\nprovisioner: disk.csi.azure.com\nparameters:\n  skuName: Premium_LRS\nallowVolumeExpansion: true\n</code></pre></p>"},{"location":"how-to/database-setup/#use-custom-storage-class","title":"Use Custom Storage Class","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3\n  storage:\n    storageClass: fast-ssd  # \u2190 Custom storage class\n    size: 100Gi\n</code></pre>"},{"location":"how-to/database-setup/#postgresql-performance-tuning","title":"PostgreSQL Performance Tuning","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3\n\n  postgresql:\n    parameters:\n      # Connection settings\n      max_connections: \"200\"              # Adjust based on Keycloak replicas\n\n      # Memory settings\n      shared_buffers: \"512MB\"             # 25% of instance memory\n      effective_cache_size: \"2GB\"         # 50-75% of instance memory\n      work_mem: \"16MB\"                    # shared_buffers / max_connections\n      maintenance_work_mem: \"128MB\"       # For VACUUM, CREATE INDEX\n\n      # WAL settings\n      wal_buffers: \"16MB\"\n      min_wal_size: \"1GB\"\n      max_wal_size: \"4GB\"\n\n      # Query planner\n      random_page_cost: \"1.1\"             # For SSD storage\n      effective_io_concurrency: \"200\"     # For SSD storage\n\n      # Checkpoints\n      checkpoint_completion_target: \"0.9\"\n\n      # Logging\n      log_line_prefix: \"%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h \"\n      log_checkpoints: \"on\"\n      log_connections: \"on\"\n      log_disconnections: \"on\"\n      log_lock_waits: \"on\"\n      log_min_duration_statement: \"1000\"  # Log slow queries (&gt;1s)\n\n  resources:\n    requests:\n      cpu: 1000m\n      memory: 2Gi\n    limits:\n      cpu: 2000m\n      memory: 4Gi\n\n  storage:\n    storageClass: fast-ssd\n    size: 100Gi\n</code></pre>"},{"location":"how-to/database-setup/#high-availability-configuration","title":"High Availability Configuration","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3  # 1 primary + 2 replicas\n\n  # Automatic failover\n  primaryUpdateStrategy: unsupervised\n\n  # Replica configuration\n  minSyncReplicas: 1\n  maxSyncReplicas: 2\n\n  # Anti-affinity: spread across nodes/zones\n  affinity:\n    podAntiAffinityType: required\n    topologyKey: kubernetes.io/hostname\n\n  # Switchover delay\n  failoverDelay: 30s\n\n  postgresql:\n    parameters:\n      # Replication settings\n      max_replication_slots: \"10\"\n      max_wal_senders: \"10\"\n      hot_standby: \"on\"\n      wal_level: \"replica\"\n\n  storage:\n    size: 100Gi\n</code></pre>"},{"location":"how-to/database-setup/#backup-configuration","title":"Backup Configuration","text":""},{"location":"how-to/database-setup/#s3-backup-recommended","title":"S3 Backup (Recommended)","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3\n\n  backup:\n    barmanObjectStore:\n      # S3 configuration\n      destinationPath: s3://my-backup-bucket/keycloak-db\n      endpointURL: https://s3.us-east-1.amazonaws.com  # Optional\n\n      # S3 credentials\n      s3Credentials:\n        accessKeyId:\n          name: backup-s3-credentials\n          key: ACCESS_KEY_ID\n        secretAccessKey:\n          name: backup-s3-credentials\n          key: ACCESS_SECRET_KEY\n\n      # Compression\n      wal:\n        compression: gzip\n        maxParallel: 2\n      data:\n        compression: gzip\n        jobs: 2\n\n    # Retention policy\n    retentionPolicy: \"30d\"  # Keep backups for 30 days\n</code></pre>"},{"location":"how-to/database-setup/#create-s3-credentials-secret","title":"Create S3 Credentials Secret","text":"<pre><code>kubectl create secret generic backup-s3-credentials \\\n  --from-literal=ACCESS_KEY_ID=\"your-access-key\" \\\n  --from-literal=ACCESS_SECRET_KEY=\"your-secret-key\" \\\n  --namespace=keycloak-db\n</code></pre>"},{"location":"how-to/database-setup/#minio-backup-on-premises","title":"MinIO Backup (On-Premises)","text":"<pre><code>backup:\n  barmanObjectStore:\n    destinationPath: s3://keycloak-backups/db\n    endpointURL: http://minio.minio-system.svc:9000\n    s3Credentials:\n      accessKeyId:\n        name: backup-minio-credentials\n        key: ACCESS_KEY_ID\n      secretAccessKey:\n        name: backup-minio-credentials\n        key: ACCESS_SECRET_KEY\n    wal:\n      compression: gzip\n    data:\n      compression: gzip\n  retentionPolicy: \"30d\"\n</code></pre>"},{"location":"how-to/database-setup/#scheduled-backups","title":"Scheduled Backups","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: ScheduledBackup\nmetadata:\n  name: keycloak-db-daily\n  namespace: keycloak-db\nspec:\n  schedule: \"0 2 * * *\"  # Daily at 2 AM\n  backupOwnerReference: self\n  cluster:\n    name: keycloak-db\n</code></pre>"},{"location":"how-to/database-setup/#manual-backup","title":"Manual Backup","text":"<pre><code># Trigger backup\nkubectl cnpg backup keycloak-db -n keycloak-db\n\n# List backups\nkubectl get backup -n keycloak-db\n\n# Describe backup\nkubectl describe backup &lt;backup-name&gt; -n keycloak-db\n</code></pre>"},{"location":"how-to/database-setup/#restore-recovery","title":"Restore &amp; Recovery","text":""},{"location":"how-to/database-setup/#restore-from-backup","title":"Restore from Backup","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db-restored\n  namespace: keycloak-db\nspec:\n  instances: 3\n\n  bootstrap:\n    recovery:\n      source: keycloak-db-backup\n      recoveryTarget:\n        targetTime: \"2025-01-15 10:00:00.00000+00\"  # Optional: point-in-time\n\n  externalClusters:\n    - name: keycloak-db-backup\n      barmanObjectStore:\n        destinationPath: s3://my-backup-bucket/keycloak-db\n        s3Credentials:\n          accessKeyId:\n            name: backup-s3-credentials\n            key: ACCESS_KEY_ID\n          secretAccessKey:\n            name: backup-s3-credentials\n            key: ACCESS_SECRET_KEY\n</code></pre>"},{"location":"how-to/database-setup/#point-in-time-recovery-pitr","title":"Point-in-Time Recovery (PITR)","text":"<pre><code>bootstrap:\n  recovery:\n    source: keycloak-db-backup\n    recoveryTarget:\n      targetTime: \"2025-01-15 10:00:00.00000+00\"  # Restore to specific time\n      # OR\n      targetXID: \"12345\"  # Restore to specific transaction ID\n      # OR\n      targetName: \"before-migration\"  # Restore to named recovery point\n</code></pre>"},{"location":"how-to/database-setup/#disaster-recovery-procedure","title":"Disaster Recovery Procedure","text":"<pre><code># 1. Delete corrupted cluster\nkubectl delete cluster keycloak-db -n keycloak-db\n\n# 2. Wait for PVCs to be deleted\nkubectl get pvc -n keycloak-db\n\n# 3. Apply restore manifest\nkubectl apply -f keycloak-db-restore.yaml\n\n# 4. Wait for cluster to become ready\nkubectl wait --for=condition=Ready cluster/keycloak-db-restored \\\n  -n keycloak-db --timeout=10m\n\n# 5. Verify data integrity\nkubectl exec -it -n keycloak-db keycloak-db-restored-1 -- \\\n  psql -U keycloak -d keycloak -c \"SELECT COUNT(*) FROM users;\"\n\n# 6. Restart Keycloak to reconnect\nkubectl rollout restart statefulset/&lt;keycloak-name&gt; -n &lt;keycloak-namespace&gt;\n</code></pre>"},{"location":"how-to/database-setup/#monitoring-maintenance","title":"Monitoring &amp; Maintenance","text":""},{"location":"how-to/database-setup/#enable-monitoring","title":"Enable Monitoring","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3\n\n  monitoring:\n    enabled: true\n    podMonitorEnabled: true\n    customQueries:\n      - name: keycloak_tables_size\n        query: |\n          SELECT\n            schemaname,\n            tablename,\n            pg_total_relation_size(schemaname||'.'||tablename) AS size_bytes\n          FROM pg_tables\n          WHERE schemaname = 'public'\n        metrics:\n          - size_bytes:\n              usage: GAUGE\n              description: \"Table size in bytes\"\n</code></pre>"},{"location":"how-to/database-setup/#prometheus-alerts","title":"Prometheus Alerts","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: keycloak-db-alerts\n  namespace: keycloak-db\nspec:\n  groups:\n    - name: keycloak-database\n      rules:\n        - alert: PostgreSQLDown\n          expr: cnpg_pg_up == 0\n          for: 5m\n          labels:\n            severity: critical\n          annotations:\n            summary: \"PostgreSQL instance down\"\n            description: \"PostgreSQL instance {{ $labels.pod }} is down\"\n\n        - alert: PostgreSQLHighConnections\n          expr: |\n            (cnpg_pg_stat_database_numbackends / cnpg_pg_settings_max_connections) &gt; 0.8\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High database connections\"\n            description: \"{{ $labels.pod }} has {{ $value | humanizePercentage }} connections\"\n\n        - alert: PostgreSQLReplicationLag\n          expr: cnpg_pg_replication_lag_seconds &gt; 60\n          for: 5m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High replication lag\"\n            description: \"Replica {{ $labels.pod }} has {{ $value }}s replication lag\"\n\n        - alert: PostgreSQLBackupFailed\n          expr: increase(cnpg_backup_failures_total[1h]) &gt; 0\n          labels:\n            severity: critical\n          annotations:\n            summary: \"Backup failed\"\n            description: \"Backup for {{ $labels.cluster }} failed\"\n</code></pre>"},{"location":"how-to/database-setup/#maintenance-operations","title":"Maintenance Operations","text":"<p>VACUUM (Automatic): <pre><code>postgresql:\n  parameters:\n    autovacuum: \"on\"\n    autovacuum_max_workers: \"3\"\n    autovacuum_naptime: \"60s\"\n    autovacuum_vacuum_scale_factor: \"0.1\"\n    autovacuum_analyze_scale_factor: \"0.05\"\n</code></pre></p> <p>Manual VACUUM: <pre><code>kubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"VACUUM FULL VERBOSE;\"\n</code></pre></p> <p>Check Database Size: <pre><code>kubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"\n    SELECT\n      pg_size_pretty(pg_database_size('keycloak')) AS db_size,\n      pg_size_pretty(pg_total_relation_size('public.users')) AS users_table_size;\n  \"\n</code></pre></p>"},{"location":"how-to/database-setup/#connecting-keycloak-to-database","title":"Connecting Keycloak to Database","text":""},{"location":"how-to/database-setup/#keycloak-crd-configuration","title":"Keycloak CRD Configuration","text":"<pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak\n  namespace: keycloak-system\nspec:\n  replicas: 3\n\n  database:\n    type: cnpg\n    cluster: keycloak-db             # \u2190 CNPG cluster name\n    namespace: keycloak-db            # \u2190 Database namespace\n    credentialsSecret: keycloak-db-credentials  # \u2190 Credentials secret\n\n  # Rest of Keycloak configuration...\n</code></pre>"},{"location":"how-to/database-setup/#connection-details","title":"Connection Details","text":"<p>CNPG provides two service endpoints:</p> <ul> <li>Read-Write (Primary): <code>&lt;cluster-name&gt;-rw.&lt;namespace&gt;.svc</code></li> <li>Read-Only (Replicas): <code>&lt;cluster-name&gt;-ro.&lt;namespace&gt;.svc</code></li> </ul> <p>Keycloak automatically uses the read-write endpoint for all operations.</p>"},{"location":"how-to/database-setup/#test-connection-from-keycloak","title":"Test Connection from Keycloak","text":"<pre><code># Get Keycloak pod\nKEYCLOAK_POD=$(kubectl get pods -n keycloak-system -l app=keycloak -o name | head -1)\n\n# Test connection\nkubectl exec -it -n keycloak-system ${KEYCLOAK_POD} -- \\\n  psql -h keycloak-db-rw.keycloak-db.svc -U keycloak -d keycloak -c \"SELECT 1;\"\n</code></pre>"},{"location":"how-to/database-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/database-setup/#cluster-not-starting","title":"Cluster Not Starting","text":"<pre><code># Check cluster events\nkubectl describe cluster keycloak-db -n keycloak-db\n\n# Check pod logs\nkubectl logs -n keycloak-db keycloak-db-1\n\n# Check storage\nkubectl get pvc -n keycloak-db\nkubectl describe pvc -n keycloak-db\n</code></pre>"},{"location":"how-to/database-setup/#replication-issues","title":"Replication Issues","text":"<pre><code># Check replication status\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U postgres -c \"SELECT * FROM pg_stat_replication;\"\n\n# Check replication lag\nkubectl get cluster keycloak-db -n keycloak-db \\\n  -o jsonpath='{.status.instancesStatus}'\n</code></pre>"},{"location":"how-to/database-setup/#backup-failures","title":"Backup Failures","text":"<pre><code># Check backup status\nkubectl describe backup &lt;backup-name&gt; -n keycloak-db\n\n# Check S3 credentials\nkubectl get secret backup-s3-credentials -n keycloak-db -o yaml\n\n# Test S3 access\nkubectl run aws-cli --rm -it --image=amazon/aws-cli -- \\\n  s3 ls s3://my-backup-bucket/keycloak-db/ \\\n  --region us-east-1\n</code></pre>"},{"location":"how-to/database-setup/#high-disk-usage","title":"High Disk Usage","text":"<pre><code># Check database size\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"\n    SELECT\n      schemaname,\n      tablename,\n      pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS size\n    FROM pg_tables\n    WHERE schemaname = 'public'\n    ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC\n    LIMIT 10;\n  \"\n\n# Run VACUUM to reclaim space\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U keycloak -d keycloak -c \"VACUUM FULL;\"\n</code></pre>"},{"location":"how-to/database-setup/#security-best-practices","title":"Security Best Practices","text":""},{"location":"how-to/database-setup/#1-network-policies","title":"1. Network Policies","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: keycloak-db-access\n  namespace: keycloak-db\nspec:\n  podSelector:\n    matchLabels:\n      cnpg.io/cluster: keycloak-db\n  ingress:\n    # Allow from Keycloak namespace\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: keycloak-system\n      ports:\n        - protocol: TCP\n          port: 5432\n\n    # Allow from within database namespace (replication)\n    - from:\n        - podSelector:\n            matchLabels:\n              cnpg.io/cluster: keycloak-db\n      ports:\n        - protocol: TCP\n          port: 5432\n</code></pre>"},{"location":"how-to/database-setup/#2-encrypt-credentials","title":"2. Encrypt Credentials","text":"<p>Use SealedSecrets or external secret managers:</p> <pre><code># Using SealedSecrets\nkubeseal -o yaml &lt; keycloak-db-credentials.yaml &gt; keycloak-db-credentials-sealed.yaml\nkubectl apply -f keycloak-db-credentials-sealed.yaml\n</code></pre>"},{"location":"how-to/database-setup/#3-enable-tls-optional","title":"3. Enable TLS (Optional)","text":"<pre><code>spec:\n  certificates:\n    serverTLSSecret: keycloak-db-tls\n    serverCASecret: keycloak-db-ca\n</code></pre>"},{"location":"how-to/database-setup/#4-regular-backups","title":"4. Regular Backups","text":"<ul> <li>Enable automated backups (daily minimum)</li> <li>Test restore procedures quarterly</li> <li>Monitor backup success/failure</li> <li>Store backups off-cluster (S3, GCS)</li> </ul>"},{"location":"how-to/database-setup/#related-documentation","title":"Related Documentation","text":"<ul> <li>End-to-End Setup Guide</li> <li>Backup &amp; Restore Guide</li> <li>High Availability Guide</li> <li>Troubleshooting Guide</li> <li>CloudNativePG Documentation</li> </ul>"},{"location":"how-to/end-to-end-setup/","title":"End-to-End Setup Guide","text":"<p>This guide walks you through deploying a production-ready Keycloak setup from scratch, including database configuration, high availability, TLS, and monitoring.</p> <p>For a simpler quick start, see the Quick Start Guide.</p>"},{"location":"how-to/end-to-end-setup/#overview","title":"Overview","text":"<p>This guide covers:</p> <ol> <li>Infrastructure Setup - Kubernetes cluster, ingress, cert-manager, CloudNativePG</li> <li>Operator + Keycloak Installation - Deploy using Helm with database and monitoring</li> <li>Multi-Tenant Setup - Platform team configures namespaces and authorization</li> <li>Realm Creation - Application teams create and manage realms via Helm</li> <li>Client Configuration - OAuth2/OIDC client setup with credential management</li> <li>Verification &amp; Testing - End-to-end OAuth2 flow validation</li> <li>Production Checklist - Security, monitoring, backup verification</li> </ol> <p>Estimated Time: 30-45 minutes</p>"},{"location":"how-to/end-to-end-setup/#prerequisites","title":"Prerequisites","text":""},{"location":"how-to/end-to-end-setup/#required","title":"Required","text":"Component Version Purpose Installation Kubernetes 1.26+ Container orchestration kubernetes.io kubectl 1.26+ Kubernetes CLI Install Guide Helm 3.8+ Package manager (OCI support required) helm.sh"},{"location":"how-to/end-to-end-setup/#recommended-for-production","title":"Recommended for Production","text":"Component Purpose Installation CloudNativePG PostgreSQL operator CNPG Docs Ingress Controller External access (nginx, traefik) Ingress NGINX cert-manager Automatic TLS certificates cert-manager Docs Prometheus Metrics collection Prometheus Operator"},{"location":"how-to/end-to-end-setup/#cluster-requirements","title":"Cluster Requirements","text":"<ul> <li>Nodes: 3+ nodes for high availability</li> <li>CPU: 4+ cores per node recommended</li> <li>Memory: 8+ GB per node recommended</li> <li>Storage: StorageClass available for database persistence</li> <li>RBAC: Cluster admin permissions required for installation</li> </ul>"},{"location":"how-to/end-to-end-setup/#part-1-infrastructure-setup","title":"Part 1: Infrastructure Setup","text":""},{"location":"how-to/end-to-end-setup/#11-install-cloudnativepg-operator","title":"1.1 Install CloudNativePG Operator","text":"<pre><code>helm repo add cnpg https://cloudnative-pg.io/charts\nhelm repo update\n\nhelm install cnpg cnpg/cloudnative-pg \\\n  --namespace cnpg-system \\\n  --create-namespace \\\n  --wait\n\n# Verify installation\nkubectl get pods -n cnpg-system\n</code></pre>"},{"location":"how-to/end-to-end-setup/#12-install-ingress-controller-nginx","title":"1.2 Install Ingress Controller (nginx)","text":"<pre><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo update\n\nhelm install ingress-nginx ingress-nginx/ingress-nginx \\\n  --namespace ingress-nginx \\\n  --create-namespace \\\n  --set controller.metrics.enabled=true \\\n  --wait\n\n# Get external IP (may take a few minutes)\nkubectl get svc -n ingress-nginx ingress-nginx-controller -w\n</code></pre>"},{"location":"how-to/end-to-end-setup/#13-install-cert-manager","title":"1.3 Install cert-manager","text":"<pre><code>helm repo add jetstack https://charts.jetstack.io\nhelm repo update\n\nhelm install cert-manager jetstack/cert-manager \\\n  --namespace cert-manager \\\n  --create-namespace \\\n  --set crds.enabled=true \\\n  --wait\n\n# Verify installation\nkubectl get pods -n cert-manager\n</code></pre>"},{"location":"how-to/end-to-end-setup/#14-configure-dns","title":"1.4 Configure DNS","text":"<p>Point your domain to the ingress controller's external IP:</p> <pre><code>INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller \\\n  -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\n\necho \"Configure DNS A record:\"\necho \"  keycloak.example.com  \u2192  $INGRESS_IP\"\n</code></pre>"},{"location":"how-to/end-to-end-setup/#15-create-clusterissuer-for-tls","title":"1.5 Create ClusterIssuer for TLS","text":"<pre><code># Create Let's Encrypt ClusterIssuer\ncat &lt;&lt;EOF | kubectl apply -f -\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: letsencrypt-prod\nspec:\n  acme:\n    server: https://acme-v02.api.letsencrypt.org/directory\n    email: admin@example.com  # Update this\n    privateKeySecretRef:\n      name: letsencrypt-prod-account-key\n    solvers:\n      - http01:\n          ingress:\n            class: nginx\nEOF\n\n# Verify issuer is ready\nkubectl get clusterissuer letsencrypt-prod\n</code></pre>"},{"location":"how-to/end-to-end-setup/#part-2-operator-keycloak-installation","title":"Part 2: Operator + Keycloak Installation","text":""},{"location":"how-to/end-to-end-setup/#21-check-available-storageclasses","title":"2.1 Check Available StorageClasses","text":"<pre><code>kubectl get storageclass\n\n# Note your storageClass name for the next step\n# Common values: standard, gp2, gp3, premium-rwo\n</code></pre>"},{"location":"how-to/end-to-end-setup/#22-install-keycloak-operator-with-keycloak-instance","title":"2.2 Install Keycloak Operator with Keycloak Instance","text":"<p>Deploy the operator with a production-ready Keycloak instance and CloudNativePG database:</p> <pre><code>helm install keycloak-operator oci://ghcr.io/vriesdemichael/charts/keycloak-operator \\\n  --namespace keycloak-system \\\n  --set keycloak.enabled=true \\\n  --set keycloak.replicas=3 \\\n  --set keycloak.version=\"26.0.0\" \\\n  --set keycloak.database.cnpg.enabled=true \\\n  --set keycloak.database.cnpg.clusterName=keycloak-postgres \\\n  --set keycloak.database.cnpg.instances=3 \\\n  --set keycloak.database.cnpg.storage.size=50Gi \\\n  --set keycloak.database.cnpg.storage.storageClass=standard \\\n  --set keycloak.ingress.enabled=true \\\n  --set keycloak.ingress.className=nginx \\\n  --set keycloak.ingress.hosts[0].host=keycloak.example.com \\\n  --set keycloak.ingress.hosts[0].paths[0].path=/ \\\n  --set keycloak.ingress.hosts[0].paths[0].pathType=Prefix \\\n  --set keycloak.ingress.tls[0].secretName=keycloak-tls \\\n  --set keycloak.ingress.tls[0].hosts[0]=keycloak.example.com \\\n  --set keycloak.ingress.annotations.\"cert-manager\\.io/cluster-issuer\"=letsencrypt-prod \\\n  --set monitoring.enabled=true \\\n  --set operator.replicaCount=2\n</code></pre> <p>Note: Update <code>keycloak.example.com</code> to your actual domain and <code>storageClass</code> to match your cluster.</p>"},{"location":"how-to/end-to-end-setup/#23-verify-installation","title":"2.3 Verify Installation","text":"<pre><code># Wait for operator pods\nkubectl wait --for=condition=ready pod \\\n  -l app.kubernetes.io/name=keycloak-operator \\\n  -n keycloak-system \\\n  --timeout=120s\n\n# Check Keycloak instance status\nkubectl get keycloak -n keycloak-system\n\n# Check PostgreSQL cluster\nkubectl get cluster -n keycloak-system\n\n# Check all pods\nkubectl get pods -n keycloak-system\n</code></pre> <p>Expected output: - Operator: 2 pods running - Keycloak: 3 pods running - PostgreSQL: 3 pods (1 primary, 2 replicas)</p>"},{"location":"how-to/end-to-end-setup/#24-retrieve-admin-credentials","title":"2.4 Retrieve Admin Credentials","text":"<pre><code># Get admin password\nkubectl get secret keycloak-admin-password \\\n  -n keycloak-system \\\n  -o jsonpath='{.data.password}' | base64 -d &amp;&amp; echo\n</code></pre> <p>Note: Admin access is typically not needed - manage everything through Helm charts and CRDs.</p>"},{"location":"how-to/end-to-end-setup/#part-3-multi-tenant-setup-platform-team","title":"Part 3: Multi-Tenant Setup (Platform Team)","text":""},{"location":"how-to/end-to-end-setup/#31-understanding-the-authorization-model","title":"3.1 Understanding the Authorization Model","text":"<p>The operator uses namespace-based authorization:</p> <ul> <li>Realm Creation: Controlled by Kubernetes RBAC (who can install the keycloak-realm chart)</li> <li>Client Creation: Controlled by realm's <code>clientAuthorizationGrants</code> (which namespaces can install keycloak-client chart)</li> <li>No Tokens/Secrets: Authorization is purely declarative</li> <li>GitOps-Friendly: All authorization changes via Helm values</li> </ul>"},{"location":"how-to/end-to-end-setup/#32-create-application-team-namespace","title":"3.2 Create Application Team Namespace","text":"<pre><code>kubectl create namespace team-alpha\nkubectl label namespace team-alpha team=alpha environment=production\n</code></pre>"},{"location":"how-to/end-to-end-setup/#33-create-realm-for-application-team","title":"3.3 Create Realm for Application Team","text":"<p>Use the keycloak-realm Helm chart to create a realm:</p> <pre><code>helm install team-alpha-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-alpha \\\n  --set realmName=team-alpha \\\n  --set displayName=\"Team Alpha Identity\" \\\n  --set operatorRef.namespace=keycloak-system \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set security.registrationAllowed=false \\\n  --set security.resetPasswordAllowed=true \\\n  --set security.rememberMe=true \\\n  --set security.verifyEmail=true\n</code></pre>"},{"location":"how-to/end-to-end-setup/#34-verify-realm-creation","title":"3.4 Verify Realm Creation","text":"<pre><code># Wait for realm to be ready\nkubectl wait --for=condition=Ready keycloakrealm/team-alpha-realm \\\n  -n team-alpha \\\n  --timeout=120s\n\n# Check realm status\nkubectl get keycloakrealm -n team-alpha\n\n# View OIDC endpoints\nkubectl get keycloakrealm team-alpha-realm -n team-alpha \\\n  -o jsonpath='{.status.endpoints}' | jq .\n</code></pre>"},{"location":"how-to/end-to-end-setup/#35-grant-additional-namespaces-optional","title":"3.5 Grant Additional Namespaces (Optional)","text":"<p>To allow another namespace to create clients in this realm:</p> <pre><code>helm upgrade team-alpha-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-alpha \\\n  --reuse-values \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set clientAuthorizationGrants[1]=team-alpha-staging\n</code></pre>"},{"location":"how-to/end-to-end-setup/#part-4-realm-creation-application-team","title":"Part 4: Realm Creation (Application Team)","text":"<p>Application teams create their own realms using the Helm chart.</p>"},{"location":"how-to/end-to-end-setup/#41-create-production-realm","title":"4.1 Create Production Realm","text":"<pre><code>helm install my-app-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-alpha \\\n  --set realmName=my-app-prod \\\n  --set displayName=\"My Application (Production)\" \\\n  --set operatorRef.namespace=keycloak-system \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set security.registrationAllowed=false \\\n  --set security.resetPasswordAllowed=true \\\n  --set security.verifyEmail=true \\\n  --set tokenSettings.accessTokenLifespan=300 \\\n  --set tokenSettings.ssoSessionIdleTimeout=1800 \\\n  --set tokenSettings.ssoSessionMaxLifespan=36000\n</code></pre>"},{"location":"how-to/end-to-end-setup/#42-create-staging-realm","title":"4.2 Create Staging Realm","text":"<pre><code>helm install my-app-staging-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-alpha \\\n  --set realmName=my-app-staging \\\n  --set displayName=\"My Application (Staging)\" \\\n  --set operatorRef.namespace=keycloak-system \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set security.registrationAllowed=true\n</code></pre>"},{"location":"how-to/end-to-end-setup/#43-verify-realms","title":"4.3 Verify Realms","text":"<pre><code>kubectl get keycloakrealm -n team-alpha\n</code></pre>"},{"location":"how-to/end-to-end-setup/#part-5-client-configuration","title":"Part 5: Client Configuration","text":""},{"location":"how-to/end-to-end-setup/#51-create-web-application-client","title":"5.1 Create Web Application Client","text":"<pre><code>helm install my-webapp-client oci://ghcr.io/vriesdemichael/charts/keycloak-client \\\n  --namespace team-alpha \\\n  --set clientId=my-webapp \\\n  --set clientName=\"My Web Application\" \\\n  --set realmRef.name=my-app-realm \\\n  --set realmRef.namespace=team-alpha \\\n  --set publicClient=false \\\n  --set standardFlowEnabled=true \\\n  --set directAccessGrantsEnabled=false \\\n  --set redirectUris[0]=\"https://myapp.example.com/callback\" \\\n  --set redirectUris[1]=\"https://myapp.example.com/silent-refresh\" \\\n  --set webOrigins[0]=\"https://myapp.example.com\"\n</code></pre>"},{"location":"how-to/end-to-end-setup/#52-create-api-client-service-account","title":"5.2 Create API Client (Service Account)","text":"<pre><code>helm install my-api-client oci://ghcr.io/vriesdemichael/charts/keycloak-client \\\n  --namespace team-alpha \\\n  --set clientId=my-api \\\n  --set clientName=\"My API Service\" \\\n  --set realmRef.name=my-app-realm \\\n  --set realmRef.namespace=team-alpha \\\n  --set publicClient=false \\\n  --set standardFlowEnabled=false \\\n  --set serviceAccountsEnabled=true\n</code></pre>"},{"location":"how-to/end-to-end-setup/#53-verify-client-creation","title":"5.3 Verify Client Creation","text":"<pre><code># Wait for clients to be ready\nkubectl wait --for=condition=Ready keycloakclient/my-webapp-client \\\n  -n team-alpha \\\n  --timeout=120s\n\n# List all clients\nkubectl get keycloakclient -n team-alpha\n</code></pre>"},{"location":"how-to/end-to-end-setup/#54-retrieve-client-credentials","title":"5.4 Retrieve Client Credentials","text":"<p>The operator automatically creates a secret with all OAuth2 credentials:</p> <pre><code># View secret contents\nkubectl get secret my-webapp-client-credentials -n team-alpha -o yaml\n\n# Extract individual values\nCLIENT_ID=$(kubectl get secret my-webapp-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.client_id}' | base64 -d)\nCLIENT_SECRET=$(kubectl get secret my-webapp-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.client_secret}' | base64 -d)\nISSUER_URL=$(kubectl get secret my-webapp-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.issuer_url}' | base64 -d)\n\necho \"Client ID: $CLIENT_ID\"\necho \"Client Secret: $CLIENT_SECRET\"\necho \"Issuer URL: $ISSUER_URL\"\n</code></pre>"},{"location":"how-to/end-to-end-setup/#55-generate-environment-file","title":"5.5 Generate Environment File","text":"<pre><code>kubectl get secret my-webapp-client-credentials -n team-alpha -o json | \\\n  jq -r '.data | to_entries[] | \"\\(.key | ascii_upcase)=\\(.value | @base64d)\"' &gt; oauth2.env\n\ncat oauth2.env\n</code></pre>"},{"location":"how-to/end-to-end-setup/#part-6-verification-testing","title":"Part 6: Verification &amp; Testing","text":""},{"location":"how-to/end-to-end-setup/#61-verify-all-resources","title":"6.1 Verify All Resources","text":"<pre><code># Operator\nkubectl get pods -n keycloak-system -l app.kubernetes.io/name=keycloak-operator\n\n# Keycloak instance\nkubectl get keycloak -n keycloak-system\n\n# Database\nkubectl get cluster -n keycloak-system\n\n# Realms\nkubectl get keycloakrealm -A\n\n# Clients\nkubectl get keycloakclient -A\n</code></pre> <p>All resources should show <code>PHASE=Ready</code>.</p>"},{"location":"how-to/end-to-end-setup/#62-test-oidc-discovery","title":"6.2 Test OIDC Discovery","text":"<pre><code>ISSUER_URL=$(kubectl get secret my-webapp-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.issuer_url}' | base64 -d)\n\ncurl -s \"$ISSUER_URL/.well-known/openid-configuration\" | jq .\n</code></pre>"},{"location":"how-to/end-to-end-setup/#63-test-client-credentials-flow","title":"6.3 Test Client Credentials Flow","text":"<pre><code>CLIENT_ID=$(kubectl get secret my-api-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.client_id}' | base64 -d)\nCLIENT_SECRET=$(kubectl get secret my-api-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.client_secret}' | base64 -d)\nTOKEN_URL=$(kubectl get secret my-api-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.token_url}' | base64 -d)\n\ncurl -s -X POST \"$TOKEN_URL\" \\\n  -d \"grant_type=client_credentials\" \\\n  -d \"client_id=$CLIENT_ID\" \\\n  -d \"client_secret=$CLIENT_SECRET\" | jq .\n</code></pre>"},{"location":"how-to/end-to-end-setup/#64-test-authorization-code-flow","title":"6.4 Test Authorization Code Flow","text":"<pre><code>CLIENT_ID=$(kubectl get secret my-webapp-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.client_id}' | base64 -d)\nAUTH_URL=$(kubectl get secret my-webapp-client-credentials -n team-alpha \\\n  -o jsonpath='{.data.auth_url}' | base64 -d)\n\necho \"Open in browser:\"\necho \"${AUTH_URL}?client_id=${CLIENT_ID}&amp;redirect_uri=https://myapp.example.com/callback&amp;response_type=code&amp;scope=openid%20profile%20email\"\n</code></pre>"},{"location":"how-to/end-to-end-setup/#part-7-production-checklist","title":"Part 7: Production Checklist","text":""},{"location":"how-to/end-to-end-setup/#security","title":"Security","text":"<ul> <li> TLS enabled on ingress</li> <li> cert-manager issuing valid certificates</li> <li> Network policies configured (optional)</li> <li> RBAC configured for application teams</li> <li> Secrets stored securely (consider External Secrets Operator)</li> </ul>"},{"location":"how-to/end-to-end-setup/#high-availability","title":"High Availability","text":"<ul> <li> Operator: 2+ replicas</li> <li> Keycloak: 3+ replicas</li> <li> PostgreSQL: 3+ instances (CloudNativePG)</li> <li> Pod anti-affinity configured</li> <li> PodDisruptionBudgets configured</li> </ul>"},{"location":"how-to/end-to-end-setup/#backup-recovery","title":"Backup &amp; Recovery","text":"<ul> <li> CloudNativePG backups configured (S3/GCS)</li> <li> Backup retention policy set</li> <li> Restore procedure tested</li> <li> Helm values stored in Git</li> </ul>"},{"location":"how-to/end-to-end-setup/#monitoring","title":"Monitoring","text":"<ul> <li> ServiceMonitor created for Prometheus</li> <li> Grafana dashboards imported</li> <li> Alerts configured for critical issues</li> <li> Log aggregation configured</li> </ul>"},{"location":"how-to/end-to-end-setup/#gitops","title":"GitOps","text":"<ul> <li> All Helm values stored in Git</li> <li> ArgoCD/Flux applications configured</li> <li> PR workflow for changes</li> <li> Drift detection enabled</li> </ul>"},{"location":"how-to/end-to-end-setup/#gitops-with-argocd","title":"GitOps with ArgoCD","text":""},{"location":"how-to/end-to-end-setup/#repository-structure","title":"Repository Structure","text":"<pre><code>gitops-repo/\n\u251c\u2500\u2500 infrastructure/\n\u2502   \u251c\u2500\u2500 cnpg/\n\u2502   \u2502   \u2514\u2500\u2500 application.yaml          # wave: 0\n\u2502   \u251c\u2500\u2500 cert-manager/\n\u2502   \u2502   \u2514\u2500\u2500 application.yaml          # wave: 0\n\u2502   \u2514\u2500\u2500 ingress-nginx/\n\u2502       \u2514\u2500\u2500 application.yaml          # wave: 0\n\u251c\u2500\u2500 keycloak/\n\u2502   \u251c\u2500\u2500 operator/\n\u2502   \u2502   \u2514\u2500\u2500 application.yaml          # wave: 1\n\u2502   \u2514\u2500\u2500 realms/\n\u2502       \u251c\u2500\u2500 team-alpha/\n\u2502       \u2502   \u251c\u2500\u2500 realm.yaml            # wave: 2\n\u2502       \u2502   \u2514\u2500\u2500 clients.yaml          # wave: 3\n\u2502       \u2514\u2500\u2500 team-beta/\n\u2502           \u251c\u2500\u2500 realm.yaml            # wave: 2\n\u2502           \u2514\u2500\u2500 clients.yaml          # wave: 3\n</code></pre>"},{"location":"how-to/end-to-end-setup/#argocd-application-for-operator","title":"ArgoCD Application for Operator","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: keycloak-operator\n  namespace: argocd\n  annotations:\n    argocd.argoproj.io/sync-wave: \"1\"\nspec:\n  project: default\n  source:\n    repoURL: ghcr.io/vriesdemichael/charts\n    chart: keycloak-operator\n    targetRevision: 0.3.x\n    helm:\n      valuesObject:\n        keycloak:\n          enabled: true\n          replicas: 3\n          database:\n            cnpg:\n              enabled: true\n              instances: 3\n        monitoring:\n          enabled: true\n        operator:\n          replicaCount: 2\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: keycloak-system\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre>"},{"location":"how-to/end-to-end-setup/#argocd-application-for-realm","title":"ArgoCD Application for Realm","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: team-alpha-realm\n  namespace: argocd\n  annotations:\n    argocd.argoproj.io/sync-wave: \"2\"\nspec:\n  project: default\n  source:\n    repoURL: ghcr.io/vriesdemichael/charts\n    chart: keycloak-realm\n    targetRevision: 0.3.x\n    helm:\n      valuesObject:\n        realmName: team-alpha\n        displayName: \"Team Alpha Identity\"\n        operatorRef:\n          namespace: keycloak-system\n        clientAuthorizationGrants:\n          - team-alpha\n        security:\n          resetPasswordAllowed: true\n          verifyEmail: true\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: team-alpha\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n</code></pre>"},{"location":"how-to/end-to-end-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/end-to-end-setup/#operator-not-starting","title":"Operator Not Starting","text":"<pre><code>kubectl logs -n keycloak-system -l app.kubernetes.io/name=keycloak-operator\nkubectl describe pod -n keycloak-system -l app.kubernetes.io/name=keycloak-operator\n</code></pre>"},{"location":"how-to/end-to-end-setup/#keycloak-stuck-in-pending","title":"Keycloak Stuck in Pending","text":"<pre><code>kubectl describe keycloak keycloak -n keycloak-system\nkubectl get events -n keycloak-system --sort-by='.lastTimestamp'\nkubectl get cluster -n keycloak-system  # Check database\n</code></pre>"},{"location":"how-to/end-to-end-setup/#realm-creation-fails","title":"Realm Creation Fails","text":"<pre><code>kubectl describe keycloakrealm &lt;realm-name&gt; -n &lt;namespace&gt;\nkubectl logs -n keycloak-system -l app.kubernetes.io/name=keycloak-operator | grep &lt;realm-name&gt;\n</code></pre>"},{"location":"how-to/end-to-end-setup/#client-authorization-error","title":"Client Authorization Error","text":"<pre><code># Check realm's authorization grants\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants}'\n\n# Ensure client namespace is in the list\nhelm upgrade &lt;realm-release&gt; oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace &lt;namespace&gt; \\\n  --reuse-values \\\n  --set clientAuthorizationGrants[0]=existing-ns \\\n  --set clientAuthorizationGrants[1]=new-ns\n</code></pre>"},{"location":"how-to/end-to-end-setup/#database-connection-issues","title":"Database Connection Issues","text":"<pre><code>kubectl get cluster -n keycloak-system\nkubectl logs -n keycloak-system -l cnpg.io/cluster=keycloak-postgres\n</code></pre>"},{"location":"how-to/end-to-end-setup/#next-steps","title":"Next Steps","text":"<p>After completing this guide:</p> <ol> <li>Configure Identity Providers - Add Google, GitHub, Azure AD SSO (Guide)</li> <li>Set Up Monitoring - Import Grafana dashboards (Observability)</li> <li>Configure Backups - Set up CloudNativePG backups to S3 (Backup Guide)</li> <li>Add More Teams - Repeat Part 3-5 for additional teams</li> <li>Review Security - Implement network policies, audit logging</li> </ol> <p>Further Reading:</p> <ul> <li>Troubleshooting Guide</li> <li>Multi-Tenant Configuration</li> <li>Database Setup Guide</li> <li>High Availability</li> </ul>"},{"location":"how-to/ha-deployment/","title":"High Availability Deployment","text":"<p>Configure Keycloak and PostgreSQL for high availability with automatic failover.</p>"},{"location":"how-to/ha-deployment/#architecture-overview","title":"Architecture Overview","text":"<pre><code>%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#00b8d9','primaryTextColor':'#fff','primaryBorderColor':'#0097a7','lineColor':'#00acc1','secondaryColor':'#006064','tertiaryColor':'#fff'}}}%%\ngraph TD\n    ingress[\"\u26a1 Ingress\"]\n\n    kc1[\"\ud83d\udd10 Keycloak&lt;br/&gt;Pod 1\"]\n    kc2[\"\ud83d\udd10 Keycloak&lt;br/&gt;Pod 2\"]\n    kc3[\"\ud83d\udd10 Keycloak&lt;br/&gt;Pod 3\"]\n\n    pg_primary[\"\ud83d\uddc4\ufe0f PostgreSQL&lt;br/&gt;Primary\"]\n    pg_replica1[\"\ud83d\uddc4\ufe0f PostgreSQL&lt;br/&gt;Replica 1\"]\n    pg_replica2[\"\ud83d\uddc4\ufe0f PostgreSQL&lt;br/&gt;Replica 2\"]\n\n    ingress --&gt; kc1\n    ingress --&gt; kc2\n    ingress --&gt; kc3\n\n    kc1 --&gt; pg_primary\n    kc2 --&gt; pg_primary\n    kc3 --&gt; pg_primary\n\n    pg_primary --&gt; pg_replica1\n    pg_primary --&gt; pg_replica2\n\n    style ingress fill:#00838f,stroke:#006064,color:#fff\n    style kc1 fill:#00838f,stroke:#006064,color:#fff\n    style kc2 fill:#00838f,stroke:#006064,color:#fff\n    style kc3 fill:#00838f,stroke:#006064,color:#fff\n    style pg_primary fill:#1565c0,stroke:#0d47a1,color:#fff\n    style pg_replica1 fill:#1565c0,stroke:#0d47a1,color:#fff\n    style pg_replica2 fill:#1565c0,stroke:#0d47a1,color:#fff</code></pre>"},{"location":"how-to/ha-deployment/#quick-start-ha-configuration","title":"Quick Start: HA Configuration","text":""},{"location":"how-to/ha-deployment/#keycloak-ha","title":"Keycloak HA","text":"<pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak\n  namespace: keycloak-system\nspec:\n  replicas: 3  # HA: minimum 3 replicas\n\n  resources:\n    requests:\n      cpu: 500m\n      memory: 1Gi\n    limits:\n      cpu: 2000m\n      memory: 2Gi\n\n  # Pod anti-affinity: spread across nodes\n  affinity:\n    podAntiAffinity:\n      requiredDuringSchedulingIgnoredDuringExecution:\n        - labelSelector:\n            matchLabels:\n              app: keycloak\n          topologyKey: kubernetes.io/hostname\n\n  database:\n    type: cnpg\n    cluster: keycloak-db\n    namespace: keycloak-db\n\n  ingress:\n    enabled: true\n    className: nginx\n    host: keycloak.example.com\n</code></pre>"},{"location":"how-to/ha-deployment/#postgresql-ha","title":"PostgreSQL HA","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: Cluster\nmetadata:\n  name: keycloak-db\n  namespace: keycloak-db\nspec:\n  instances: 3  # 1 primary + 2 replicas\n\n  primaryUpdateStrategy: unsupervised  # Automatic failover\n  minSyncReplicas: 1\n  maxSyncReplicas: 2\n\n  # Spread across zones\n  affinity:\n    podAntiAffinityType: required\n    topologyKey: topology.kubernetes.io/zone\n\n  storage:\n    size: 100Gi\n    storageClass: fast-ssd\n\n  backup:\n    barmanObjectStore:\n      destinationPath: s3://backups/keycloak-db\n      s3Credentials:\n        accessKeyId:\n          name: backup-s3-credentials\n          key: ACCESS_KEY_ID\n        secretAccessKey:\n          name: backup-s3-credentials\n          key: ACCESS_SECRET_KEY\n      wal:\n        compression: gzip\n      data:\n        compression: gzip\n    retentionPolicy: \"30d\"\n</code></pre>"},{"location":"how-to/ha-deployment/#component-configuration","title":"Component Configuration","text":""},{"location":"how-to/ha-deployment/#1-operator-ha","title":"1. Operator HA","text":"<pre><code>helm install keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --create-namespace \\\n  --set replicas=2 \\\n  --set resources.requests.cpu=200m \\\n  --set resources.requests.memory=512Mi\n</code></pre>"},{"location":"how-to/ha-deployment/#2-load-balancer-configuration","title":"2. Load Balancer Configuration","text":"<p>Ingress (Recommended): <pre><code>keycloak:\n  ingress:\n    enabled: true\n    className: nginx\n    annotations:\n      nginx.ingress.kubernetes.io/affinity: cookie\n      nginx.ingress.kubernetes.io/session-cookie-name: keycloak-affinity\n      nginx.ingress.kubernetes.io/session-cookie-hash: sha1\n    host: keycloak.example.com\n</code></pre></p> <p>Service LoadBalancer (Cloud): <pre><code>service:\n  type: LoadBalancer\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: nlb\n    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: \"true\"\n</code></pre></p>"},{"location":"how-to/ha-deployment/#3-pod-disruption-budget","title":"3. Pod Disruption Budget","text":"<pre><code>apiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: keycloak-pdb\n  namespace: keycloak-system\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: keycloak\n</code></pre>"},{"location":"how-to/ha-deployment/#4-resource-limits","title":"4. Resource Limits","text":"<p>Keycloak: <pre><code>keycloak:\n  resources:\n    requests:\n      cpu: 500m\n      memory: 1Gi\n    limits:\n      cpu: 2000m\n      memory: 2Gi\n  jvm:\n    heapSize: \"1536m\"\n</code></pre></p> <p>PostgreSQL: <pre><code>resources:\n  requests:\n    cpu: 1000m\n    memory: 2Gi\n  limits:\n    cpu: 2000m\n    memory: 4Gi\n\npostgresql:\n  parameters:\n    max_connections: \"200\"\n    shared_buffers: \"512MB\"\n    effective_cache_size: \"2GB\"\n</code></pre></p>"},{"location":"how-to/ha-deployment/#failover-testing","title":"Failover Testing","text":""},{"location":"how-to/ha-deployment/#simulate-keycloak-pod-failure","title":"Simulate Keycloak Pod Failure","text":"<pre><code># Kill a Keycloak pod\nkubectl delete pod keycloak-0 -n keycloak-system\n\n# Watch rollout\nkubectl get pods -n keycloak-system -w\n\n# Verify traffic continues (2/3 pods handling requests)\n# New pod starts automatically\n</code></pre>"},{"location":"how-to/ha-deployment/#simulate-database-primary-failure","title":"Simulate Database Primary Failure","text":"<pre><code># Identify primary\nkubectl get cluster keycloak-db -n keycloak-db \\\n  -o jsonpath='{.status.currentPrimary}'\n\n# Delete primary pod\nkubectl delete pod keycloak-db-1 -n keycloak-db\n\n# Watch failover (30-60 seconds)\nkubectl get cluster keycloak-db -n keycloak-db -w\n\n# Verify new primary elected\nkubectl get cluster keycloak-db -n keycloak-db \\\n  -o jsonpath='{.status.currentPrimary}'\n</code></pre>"},{"location":"how-to/ha-deployment/#simulate-node-failure","title":"Simulate Node Failure","text":"<pre><code># Cordon node (simulates failure)\nkubectl cordon &lt;node-name&gt;\n\n# Watch pods reschedule\nkubectl get pods -n keycloak-system -o wide -w\n\n# Uncordon when done\nkubectl uncordon &lt;node-name&gt;\n</code></pre>"},{"location":"how-to/ha-deployment/#monitoring-ha-health","title":"Monitoring HA Health","text":""},{"location":"how-to/ha-deployment/#check-keycloak-replicas","title":"Check Keycloak Replicas","text":"<pre><code>kubectl get pods -n keycloak-system -l app=keycloak\n# All pods should be Running\n\n# Check endpoints\nkubectl get endpoints keycloak-keycloak -n keycloak-system\n# Should show all pod IPs\n</code></pre>"},{"location":"how-to/ha-deployment/#check-database-replication","title":"Check Database Replication","text":"<pre><code># Check cluster status\nkubectl get cluster keycloak-db -n keycloak-db\n\n# Check replication lag\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U postgres -c \"SELECT * FROM pg_stat_replication;\"\n</code></pre>"},{"location":"how-to/ha-deployment/#prometheus-queries","title":"Prometheus Queries","text":"<pre><code># Keycloak availability (should be 1.0 = 100%)\nsum(up{job=\"keycloak\"}) / count(up{job=\"keycloak\"})\n\n# Database replication lag (should be &lt; 1s)\nmax(cnpg_pg_replication_lag_seconds) by (pod)\n\n# Pod restart rate (should be near 0)\nrate(kube_pod_container_status_restarts_total{namespace=\"keycloak-system\"}[1h])\n</code></pre>"},{"location":"how-to/ha-deployment/#zone-distribution","title":"Zone Distribution","text":""},{"location":"how-to/ha-deployment/#multi-zone-keycloak","title":"Multi-Zone Keycloak","text":"<pre><code>affinity:\n  podAntiAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n      - labelSelector:\n          matchLabels:\n            app: keycloak\n        topologyKey: topology.kubernetes.io/zone  # Spread across zones\n\n  nodeAffinity:\n    preferredDuringSchedulingIgnoredDuringExecution:\n      - weight: 100\n        preference:\n          matchExpressions:\n            - key: topology.kubernetes.io/zone\n              operator: In\n              values: [\"us-east-1a\", \"us-east-1b\", \"us-east-1c\"]\n</code></pre>"},{"location":"how-to/ha-deployment/#multi-zone-database","title":"Multi-Zone Database","text":"<pre><code>affinity:\n  podAntiAffinityType: required\n  topologyKey: topology.kubernetes.io/zone\n  nodeSelector:\n    node.kubernetes.io/instance-type: m5.2xlarge\n</code></pre>"},{"location":"how-to/ha-deployment/#performance-tuning","title":"Performance Tuning","text":""},{"location":"how-to/ha-deployment/#connection-pooling","title":"Connection Pooling","text":"<p>Keycloak Database Pool: <pre><code>env:\n  - name: KC_DB_POOL_INITIAL_SIZE\n    value: \"10\"\n  - name: KC_DB_POOL_MIN_SIZE\n    value: \"10\"\n  - name: KC_DB_POOL_MAX_SIZE\n    value: \"50\"\n</code></pre></p> <p>PostgreSQL Connections: <pre><code>postgresql:\n  parameters:\n    max_connections: \"200\"  # Keycloak pods * connections per pod + buffer\n</code></pre></p>"},{"location":"how-to/ha-deployment/#caching","title":"Caching","text":"<pre><code>env:\n  - name: KC_CACHE\n    value: \"ispn\"  # Infinispan (default, supports clustering)\n  - name: KC_CACHE_STACK\n    value: \"kubernetes\"  # Auto-discovery in K8s\n</code></pre>"},{"location":"how-to/ha-deployment/#disaster-recovery","title":"Disaster Recovery","text":""},{"location":"how-to/ha-deployment/#backup-strategy","title":"Backup Strategy","text":"<pre><code>apiVersion: postgresql.cnpg.io/v1\nkind: ScheduledBackup\nmetadata:\n  name: keycloak-db-backup\n  namespace: keycloak-db\nspec:\n  schedule: \"0 2 * * *\"  # Daily at 2 AM\n  backupOwnerReference: self\n  cluster:\n    name: keycloak-db\n</code></pre>"},{"location":"how-to/ha-deployment/#multi-region-backup","title":"Multi-Region Backup","text":"<pre><code>backup:\n  barmanObjectStore:\n    destinationPath: s3://backups-us-east/keycloak-db\n    # Replicate to secondary region\n\n# Then replicate S3 bucket to other region via AWS S3 replication\n</code></pre>"},{"location":"how-to/ha-deployment/#recovery-time-objective-rto","title":"Recovery Time Objective (RTO)","text":"Component Failure RTO Procedure Keycloak Pod Single pod failure &lt; 1 min Automatic (K8s recreates) Keycloak Node Node failure 2-5 min Automatic (pods reschedule) Database Primary Primary failure 30-60s Automatic (CNPG failover) Database Corruption Data corruption 10-30 min Manual restore from backup Full Cluster Loss Region outage 1-4 hours Manual restore in new region"},{"location":"how-to/ha-deployment/#troubleshooting-ha","title":"Troubleshooting HA","text":""},{"location":"how-to/ha-deployment/#split-brain-detection","title":"Split Brain Detection","text":"<pre><code># Check if multiple primaries exist (should never happen)\nkubectl get pods -n keycloak-db -l role=primary\n# Should show exactly 1 pod\n\n# Check cluster status\nkubectl describe cluster keycloak-db -n keycloak-db\n</code></pre>"},{"location":"how-to/ha-deployment/#replication-lag-too-high","title":"Replication Lag Too High","text":"<pre><code># Check lag\nkubectl exec -it -n keycloak-db keycloak-db-1 -- \\\n  psql -U postgres -c \"\n    SELECT\n      client_addr,\n      state,\n      sent_lsn,\n      write_lsn,\n      flush_lsn,\n      replay_lsn,\n      sync_state,\n      EXTRACT(EPOCH FROM (now() - replay_timestamp)) AS lag_seconds\n    FROM pg_stat_replication;\n  \"\n\n# Solutions:\n# - Increase wal_sender_timeout\n# - Check network latency between pods\n# - Verify replica has sufficient resources\n</code></pre>"},{"location":"how-to/ha-deployment/#session-affinity-issues","title":"Session Affinity Issues","text":"<pre><code># Verify ingress session affinity\nkubectl get ingress keycloak-ingress -n keycloak-system -o yaml | grep affinity\n\n# Test with curl\ncurl -v -c cookies.txt https://keycloak.example.com/realms/master\ncurl -v -b cookies.txt https://keycloak.example.com/realms/master\n# Should hit same pod (check response headers/logs)\n</code></pre>"},{"location":"how-to/ha-deployment/#related-documentation","title":"Related Documentation","text":"<ul> <li>Database Setup Guide</li> <li>Backup &amp; Restore Guide</li> <li>End-to-End Setup Guide</li> <li>Troubleshooting Guide</li> </ul>"},{"location":"how-to/multi-tenant/","title":"Multi-Tenant Configuration Guide","text":"<p>Configure the operator for multi-tenant environments where multiple teams manage their own realms and clients independently.</p>"},{"location":"how-to/multi-tenant/#team-responsibilities-onboarding","title":"Team Responsibilities &amp; Onboarding","text":"<p>When introducing the Keycloak Operator to your organization, clear role definitions are essential for a smooth \"Realm-as-Tenant\" adoption.</p>"},{"location":"how-to/multi-tenant/#roles-responsibilities-matrix","title":"Roles &amp; Responsibilities Matrix","text":"Responsibility Platform Team \ud83d\udee0\ufe0f Realm Owner (App Team A) \ud83d\udc51 Client Owner (App Team B) \ud83d\udc64 Scope Cluster Infrastructure &amp; Operator Specific Realm (Tenant) Specific Application (Client) Infrastructure Deploys Operator &amp; CRDs.Ensures Keycloak availability.Manages global limits/quotas. N/A N/A Security Boundary Manages ClusterRoles.No access to Realm secrets by default. Owns the Realm boundary.Controls <code>clientAuthorizationGrants</code>.Manages Realm Users/Groups. Manages Client Secrets.Configures Redirect URIs. Onboarding Creates Namespaces.Grants Realm Creation rights. Creates Realm CR.Approves Client access via PRs. Creates Client CR in own Namespace.Requests access to Realm. Troubleshooting Operator logs, Pod health, Network policies. Realm configuration errors.Auth flows, Theme issues. Client connection errors.Invalid Redirect URIs."},{"location":"how-to/multi-tenant/#onboarding-new-teams","title":"Onboarding New Teams","text":"<p>1. For Platform Engineers: *   Explain: \"We provide the Keycloak service and the operator. You own your configuration.\" *   Configure: Set up namespaces and RBAC so teams can create <code>KeycloakRealm</code> resources. *   Security: You don't need to see their secrets. The Operator only accesses namespaces where it is explicitly invited via the Realm Helm chart.</p> <p>2. For Realm Owners (Tenant Managers): *   Explain: \"You own a 'Virtual Keycloak'. You control who can connect to it.\" *   Action: Deploy your Realm using the <code>keycloak-realm</code> Helm chart. *   Gatekeeping: Use the <code>clientAuthorizationGrants</code> list in your Realm YAML to whitelist other team's namespaces. You are the gatekeeper.</p> <p>3. For Application Developers (Client Owners): *   Explain: \"You define your app's auth client as code, right next to your deployment.\" *   Action: Deploy a <code>KeycloakClient</code> CR in your namespace. *   Access: If you need to connect to a shared Realm, ask the Realm Owner to add your namespace to their allowlist.</p>"},{"location":"how-to/multi-tenant/#architecture","title":"Architecture","text":"<pre><code>%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#00b8d9','primaryTextColor':'#fff','primaryBorderColor':'#0097a7','lineColor':'#00acc1','secondaryColor':'#006064','tertiaryColor':'#fff'}}}%%\ngraph LR\n    subgraph platform[\"\ud83d\udc65 Platform Team\"]\n        deploy[\"Deploy Operator\"]\n        instance[\"Create Keycloak Instance\"]\n        rbac[\"Grant RBAC Permissions\"]\n    end\n\n    subgraph app[\"\ud83d\udc65 Application Teams\"]\n        realms[\"Create Realms&lt;br/&gt;&lt;small&gt;(RBAC-controlled)&lt;/small&gt;\"]\n        grants[\"Set clientAuthorizationGrants\"]\n        clients[\"Manage Clients&lt;br/&gt;&lt;small&gt;(grant list-controlled)&lt;/small&gt;\"]\n    end\n\n    deploy --&gt; instance\n    instance --&gt; rbac\n    rbac -.-&gt;|authorize| realms\n    realms --&gt; grants\n    grants --&gt; clients\n\n    style platform fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style app fill:#263238,stroke:#00acc1,stroke-width:2px,color:#fff\n    style deploy fill:#00838f,stroke:#006064,color:#fff\n    style instance fill:#00838f,stroke:#006064,color:#fff\n    style rbac fill:#00838f,stroke:#006064,color:#fff\n    style realms fill:#00838f,stroke:#006064,color:#fff\n    style grants fill:#00838f,stroke:#006064,color:#fff\n    style clients fill:#00838f,stroke:#006064,color:#fff</code></pre> <p>Key Concepts:</p> <ul> <li>Realm Creation: Controlled by Kubernetes RBAC (RoleBinding)</li> <li>Client Creation: Controlled by realm's <code>clientAuthorizationGrants</code> list</li> <li>Declarative: All authorization via manifest fields, no secrets/tokens</li> <li>GitOps-Friendly: Everything in version control</li> </ul>"},{"location":"how-to/multi-tenant/#platform-team-setup","title":"Platform Team Setup","text":""},{"location":"how-to/multi-tenant/#1-deploy-shared-keycloak","title":"1. Deploy Shared Keycloak","text":"<p>Install the operator with Keycloak instance using Helm:</p> <pre><code>helm install keycloak-operator oci://ghcr.io/vriesdemichael/charts/keycloak-operator \\\n  --namespace platform \\\n  --set keycloak.enabled=true \\\n  --set keycloak.replicas=3 \\\n  --set keycloak.database.cnpg.enabled=true \\\n  --set keycloak.ingress.enabled=true \\\n  --set keycloak.ingress.hosts[0].host=keycloak.company.com \\\n  --set keycloak.ingress.hosts[0].paths[0].path=/ \\\n  --set keycloak.ingress.hosts[0].paths[0].pathType=Prefix\n</code></pre>"},{"location":"how-to/multi-tenant/#2-create-namespaces-for-teams","title":"2. Create Namespaces for Teams","text":"<pre><code># Create namespaces\nkubectl create namespace team-alpha\nkubectl create namespace team-beta\nkubectl create namespace team-gamma\n\n# Label for organization\nkubectl label namespace team-alpha team=alpha env=prod\nkubectl label namespace team-beta team=beta env=prod\nkubectl label namespace team-gamma team=gamma env=prod\n</code></pre>"},{"location":"how-to/multi-tenant/#3-grant-realm-creation-permissions","title":"3. Grant Realm Creation Permissions","text":"<p>Create ClusterRole for realm management:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: keycloak-realm-manager\nrules:\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakrealms\"]\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"]\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakclients\"]\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"]\n</code></pre> <p>Grant to each team:</p> <pre><code># Team Alpha\nkubectl create rolebinding realm-manager-alpha \\\n  --clusterrole=keycloak-realm-manager \\\n  --serviceaccount=team-alpha:default \\\n  --namespace=team-alpha\n\n# Team Beta\nkubectl create rolebinding realm-manager-beta \\\n  --clusterrole=keycloak-realm-manager \\\n  --serviceaccount=team-beta:default \\\n  --namespace=team-beta\n\n# Team Gamma\nkubectl create rolebinding realm-manager-gamma \\\n  --clusterrole=keycloak-realm-manager \\\n  --serviceaccount=team-gamma:default \\\n  --namespace=team-gamma\n</code></pre>"},{"location":"how-to/multi-tenant/#4-grant-operator-namespace-access","title":"4. Grant Operator Namespace Access","text":"<p>The operator needs to read secrets in each team namespace:</p> <pre><code># Create RoleBinding for each team namespace\nfor TEAM in team-alpha team-beta team-gamma; do\n  kubectl create rolebinding keycloak-operator-access \\\n    --clusterrole=keycloak-operator-namespace-access \\\n    --serviceaccount=platform:keycloak-operator \\\n    --namespace=$TEAM\ndone\n</code></pre>"},{"location":"how-to/multi-tenant/#application-team-usage","title":"Application Team Usage","text":""},{"location":"how-to/multi-tenant/#create-a-realm","title":"Create a Realm","text":"<p>Each team creates realms in their own namespace using the Helm chart:</p> <pre><code>helm install alpha-production oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-alpha \\\n  --set realmName=alpha-production \\\n  --set operatorRef.namespace=platform \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set clientAuthorizationGrants[1]=team-alpha-dev \\\n  --set security.registrationAllowed=false \\\n  --set security.resetPasswordAllowed=true \\\n  --set security.verifyEmail=true\n</code></pre>"},{"location":"how-to/multi-tenant/#create-clients-in-authorized-namespaces","title":"Create Clients in Authorized Namespaces","text":"<p>Team Alpha can create clients in their namespace using the Helm chart:</p> <pre><code>helm install alpha-app oci://ghcr.io/vriesdemichael/charts/keycloak-client \\\n  --namespace team-alpha \\\n  --set clientId=alpha-app \\\n  --set realmRef.name=alpha-production \\\n  --set realmRef.namespace=team-alpha \\\n  --set publicClient=false \\\n  --set redirectUris[0]=https://app.team-alpha.com/callback\n</code></pre>"},{"location":"how-to/multi-tenant/#cross-namespace-client-creation","title":"Cross-Namespace Client Creation","text":"<p>If a realm grants access, other namespaces can create clients:</p> <pre><code># In team-alpha-dev namespace\nhelm install dev-app oci://ghcr.io/vriesdemichael/charts/keycloak-client \\\n  --namespace team-alpha-dev \\\n  --set clientId=dev-app \\\n  --set realmRef.name=alpha-production \\\n  --set realmRef.namespace=team-alpha \\\n  --set redirectUris[0]=https://dev.team-alpha.com/callback\n</code></pre>"},{"location":"how-to/multi-tenant/#multi-realm-scenarios","title":"Multi-Realm Scenarios","text":""},{"location":"how-to/multi-tenant/#shared-platform-realm","title":"Shared Platform Realm","text":"<p>Platform team creates a central realm that all teams can use:</p> <pre><code>helm install company-sso oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace platform \\\n  --set realmName=company-sso \\\n  --set operatorRef.namespace=platform \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set clientAuthorizationGrants[1]=team-beta \\\n  --set clientAuthorizationGrants[2]=team-gamma \\\n  --set security.registrationAllowed=false \\\n  --set security.resetPasswordAllowed=true\n</code></pre> <p>All teams can now create clients in this realm.</p>"},{"location":"how-to/multi-tenant/#team-specific-realms-with-selective-sharing","title":"Team-Specific Realms with Selective Sharing","text":"<p>Team creates realm and selectively grants access:</p> <pre><code>helm install beta-services oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-beta \\\n  --set realmName=beta-services \\\n  --set operatorRef.namespace=platform \\\n  --set clientAuthorizationGrants[0]=team-beta \\\n  --set clientAuthorizationGrants[1]=team-beta-staging \\\n  --set clientAuthorizationGrants[2]=partner-integration-team\n</code></pre>"},{"location":"how-to/multi-tenant/#security-model","title":"Security Model","text":""},{"location":"how-to/multi-tenant/#realm-creation-authorization","title":"Realm Creation Authorization","text":"<p>Who can create realms? - Users/ServiceAccounts with RoleBinding granting <code>create</code> permission on <code>KeycloakRealm</code> - Platform team controls via RBAC policies</p> <p>Verification: <pre><code># Check if team can create realms\nkubectl auth can-i create keycloakrealms.vriesdemichael.github.io \\\n  --as=system:serviceaccount:team-alpha:default \\\n  --namespace=team-alpha\n</code></pre></p>"},{"location":"how-to/multi-tenant/#client-creation-authorization","title":"Client Creation Authorization","text":"<p>Who can create clients? - Namespaces listed in realm's <code>clientAuthorizationGrants</code> - Defined by realm owner (application team) - Fully declarative (no secret distribution)</p> <p>Verification: <pre><code># Check realm's grants\nkubectl get keycloakrealm alpha-production -n team-alpha \\\n  -o jsonpath='{.spec.clientAuthorizationGrants}' | jq\n</code></pre></p>"},{"location":"how-to/multi-tenant/#namespace-isolation","title":"Namespace Isolation","text":"<ul> <li>Teams cannot access other teams' namespaces (Kubernetes RBAC)</li> <li>Teams cannot modify other teams' realms (resource ownership)</li> <li>Clients can only reference realms that grant their namespace access</li> <li>Operator enforces authorization at reconciliation time</li> </ul>"},{"location":"how-to/multi-tenant/#gitops-workflow","title":"GitOps Workflow","text":""},{"location":"how-to/multi-tenant/#argocd-application-structure","title":"ArgoCD Application Structure","text":"<pre><code>gitops-repo/\n\u251c\u2500\u2500 platform/\n\u2502   \u251c\u2500\u2500 keycloak-operator.yaml\n\u2502   \u2514\u2500\u2500 shared-realms/\n\u2502       \u2514\u2500\u2500 company-sso.yaml\n\u251c\u2500\u2500 team-alpha/\n\u2502   \u251c\u2500\u2500 realms/\n\u2502   \u2502   \u2514\u2500\u2500 alpha-production.yaml\n\u2502   \u2514\u2500\u2500 clients/\n\u2502       \u251c\u2500\u2500 web-app.yaml\n\u2502       \u2514\u2500\u2500 mobile-app.yaml\n\u2514\u2500\u2500 team-beta/\n    \u251c\u2500\u2500 realms/\n    \u2502   \u2514\u2500\u2500 beta-services.yaml\n    \u2514\u2500\u2500 clients/\n        \u2514\u2500\u2500 api-gateway.yaml\n</code></pre>"},{"location":"how-to/multi-tenant/#updating-authorization-grants","title":"Updating Authorization Grants","text":"<p>To grant a new namespace access:</p> <pre><code># Update realm via helm upgrade\nhelm upgrade alpha-production oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-alpha \\\n  --reuse-values \\\n  --set clientAuthorizationGrants[0]=team-alpha \\\n  --set clientAuthorizationGrants[1]=team-alpha-dev \\\n  --set clientAuthorizationGrants[2]=new-namespace\n</code></pre> <p>Changes apply immediately - new namespace can create clients.</p>"},{"location":"how-to/multi-tenant/#common-patterns","title":"Common Patterns","text":""},{"location":"how-to/multi-tenant/#developmentstagingproduction-separation","title":"Development/Staging/Production Separation","text":"<pre><code># Production realm - strict grants\nhelm install prod-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-prod \\\n  --set realmName=prod-realm \\\n  --set operatorRef.namespace=platform \\\n  --set clientAuthorizationGrants[0]=team-prod\n\n# Staging realm - more permissive\nhelm install staging-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace team-staging \\\n  --set realmName=staging-realm \\\n  --set operatorRef.namespace=platform \\\n  --set clientAuthorizationGrants[0]=team-staging \\\n  --set clientAuthorizationGrants[1]=team-dev \\\n  --set clientAuthorizationGrants[2]=qa-team\n</code></pre>"},{"location":"how-to/multi-tenant/#partner-integration","title":"Partner Integration","text":"<pre><code>helm install partner-api oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace platform \\\n  --set realmName=partner-api \\\n  --set operatorRef.namespace=platform \\\n  --set clientAuthorizationGrants[0]=partner-a \\\n  --set clientAuthorizationGrants[1]=partner-b \\\n  --set clientAuthorizationGrants[2]=internal-gateway \\\n  --set security.registrationAllowed=false \\\n  --set security.bruteForceProtected=true\n</code></pre>"},{"location":"how-to/multi-tenant/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/multi-tenant/#permission-denied-creating-realm","title":"Permission Denied Creating Realm","text":"<pre><code># Check RBAC permissions\nkubectl auth can-i create keycloakrealms.vriesdemichael.github.io \\\n  --namespace=team-alpha\n\n# Check RoleBindings\nkubectl get rolebinding -n team-alpha \\\n  -o json | jq '.items[] | select(.subjects[]?.kind==\"ServiceAccount\")'\n</code></pre> <p>Solution: Create RoleBinding granting realm creation permission.</p>"},{"location":"how-to/multi-tenant/#client-creation-fails-not-authorized","title":"Client Creation Fails - Not Authorized","text":"<pre><code># Check realm's grants\nkubectl get keycloakrealm &lt;realm&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants[*]}'\n\n# Check operator logs\nkubectl logs -n platform -l app=keycloak-operator \\\n  | grep -i \"authorization\\|grant\"\n</code></pre> <p>Solution: Add client's namespace to realm's <code>clientAuthorizationGrants</code>.</p>"},{"location":"how-to/multi-tenant/#operator-cant-read-secrets","title":"Operator Can't Read Secrets","text":"<pre><code># Check operator has access to namespace\nkubectl auth can-i get secrets \\\n  --as=system:serviceaccount:platform:keycloak-operator \\\n  --namespace=team-alpha\n</code></pre> <p>Solution: Create RoleBinding for operator in the namespace.</p>"},{"location":"how-to/multi-tenant/#best-practices","title":"Best Practices","text":"<p>\u2705 Use least-privilege grants - Only grant namespaces that need access \u2705 Document grants - Comment why each namespace is granted \u2705 Review regularly - Audit <code>clientAuthorizationGrants</code> periodically \u2705 Separate environments - Different realms for dev/staging/prod \u2705 Use GitOps - All changes via PR workflow \u2705 Monitor authorization - Alert on denied client creation attempts</p>"},{"location":"how-to/multi-tenant/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Model</li> <li>RBAC Implementation</li> <li>End-to-End Setup Guide</li> <li>KeycloakRealm CRD Reference</li> </ul>"},{"location":"how-to/smtp-configuration/","title":"SMTP Configuration Guide","text":"<p>Configure SMTP for Keycloak email features (verification, password reset, notifications).</p>"},{"location":"how-to/smtp-configuration/#quick-setup","title":"Quick Setup","text":""},{"location":"how-to/smtp-configuration/#1-create-smtp-credentials-secret","title":"1. Create SMTP Credentials Secret","text":"<pre><code>kubectl create secret generic my-realm-smtp \\\n  --from-literal=username=smtp-user \\\n  --from-literal=password=smtp-password \\\n  --namespace=my-app\n</code></pre>"},{"location":"how-to/smtp-configuration/#2-configure-realm-with-smtp","title":"2. Configure Realm with SMTP","text":"<pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-system\n\n  smtp:\n    host: smtp.sendgrid.net\n    port: 587\n    from: noreply@example.com\n    fromDisplayName: My Application\n    auth: true\n    starttls: true\n    credentialsSecret: my-realm-smtp\n</code></pre>"},{"location":"how-to/smtp-configuration/#provider-examples","title":"Provider Examples","text":""},{"location":"how-to/smtp-configuration/#sendgrid","title":"SendGrid","text":"<pre><code># Create secret\nkubectl create secret generic smtp-sendgrid \\\n  --from-literal=username=apikey \\\n  --from-literal=password=SG.your-api-key \\\n  --namespace=my-app\n</code></pre> <pre><code>smtp:\n  host: smtp.sendgrid.net\n  port: 587\n  from: noreply@example.com\n  fromDisplayName: My App\n  auth: true\n  starttls: true\n  credentialsSecret: smtp-sendgrid\n</code></pre>"},{"location":"how-to/smtp-configuration/#gmail","title":"Gmail","text":"<p>Setup: Enable 2FA and create App Password at https://myaccount.google.com/apppasswords</p> <pre><code>kubectl create secret generic smtp-gmail \\\n  --from-literal=username=your-email@gmail.com \\\n  --from-literal=password=your-app-password \\\n  --namespace=my-app\n</code></pre> <pre><code>smtp:\n  host: smtp.gmail.com\n  port: 587\n  from: your-email@gmail.com\n  fromDisplayName: My Application\n  auth: true\n  starttls: true\n  credentialsSecret: smtp-gmail\n</code></pre>"},{"location":"how-to/smtp-configuration/#aws-ses","title":"AWS SES","text":"<pre><code># Get SMTP credentials from AWS SES Console\nkubectl create secret generic smtp-ses \\\n  --from-literal=username=YOUR_SMTP_USERNAME \\\n  --from-literal=password=YOUR_SMTP_PASSWORD \\\n  --namespace=my-app\n</code></pre> <pre><code>smtp:\n  host: email-smtp.us-east-1.amazonaws.com\n  port: 587\n  from: verified-sender@example.com  # Must be verified in SES\n  fromDisplayName: My Application\n  auth: true\n  starttls: true\n  credentialsSecret: smtp-ses\n</code></pre>"},{"location":"how-to/smtp-configuration/#mailgun","title":"Mailgun","text":"<pre><code>kubectl create secret generic smtp-mailgun \\\n  --from-literal=username=postmaster@mg.example.com \\\n  --from-literal=password=your-smtp-password \\\n  --namespace=my-app\n</code></pre> <pre><code>smtp:\n  host: smtp.mailgun.org\n  port: 587\n  from: noreply@mg.example.com\n  fromDisplayName: My Application\n  auth: true\n  starttls: true\n  credentialsSecret: smtp-mailgun\n</code></pre>"},{"location":"how-to/smtp-configuration/#office-365","title":"Office 365","text":"<pre><code>kubectl create secret generic smtp-o365 \\\n  --from-literal=username=your-email@company.com \\\n  --from-literal=password=your-password \\\n  --namespace=my-app\n</code></pre> <pre><code>smtp:\n  host: smtp.office365.com\n  port: 587\n  from: your-email@company.com\n  fromDisplayName: Company Name\n  auth: true\n  starttls: true\n  credentialsSecret: smtp-o365\n</code></pre>"},{"location":"how-to/smtp-configuration/#testing-smtp-configuration","title":"Testing SMTP Configuration","text":""},{"location":"how-to/smtp-configuration/#1-enable-email-verification","title":"1. Enable Email Verification","text":"<p>Update your realm to enable email verification:</p> <pre><code>apiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-app\nspec:\n  realmName: my-realm\n  operatorRef:\n    namespace: keycloak-system\n\n  security:\n    verifyEmail: true\n    registrationAllowed: true  # For testing only\n\n  smtp:\n    host: smtp.sendgrid.net\n    port: 587\n    from: noreply@example.com\n    fromDisplayName: My Application\n    auth: true\n    starttls: true\n    credentialsSecret: my-realm-smtp\n</code></pre> <p>Apply the changes: <pre><code>kubectl apply -f realm-with-smtp.yaml\n</code></pre></p>"},{"location":"how-to/smtp-configuration/#2-test-email-delivery","title":"2. Test Email Delivery","text":"<p>Option A: Self-Registration Flow (recommended for testing) 1. Navigate to your realm's account registration page:    <pre><code>https://keycloak.example.com/realms/my-realm/protocol/openid-connect/registrations?client_id=account&amp;response_type=code\n</code></pre> 2. Fill out registration form with valid email 3. Check email for verification link 4. Click link to verify account</p> <p>Option B: Password Reset Flow 1. Create a test user via Keycloak admin console or realm import 2. Navigate to password reset page:    <pre><code>https://keycloak.example.com/realms/my-realm/login-actions/reset-credentials\n</code></pre> 3. Enter test user's email 4. Check email for password reset link</p>"},{"location":"how-to/smtp-configuration/#3-check-keycloak-logs","title":"3. Check Keycloak Logs","text":"<pre><code>kubectl logs -n keycloak-system -l app=keycloak --tail=50 | grep -i smtp\n</code></pre>"},{"location":"how-to/smtp-configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/smtp-configuration/#smtp-connection-refused","title":"SMTP Connection Refused","text":"<pre><code># Test SMTP connectivity from Keycloak pod\nKEYCLOAK_POD=$(kubectl get pods -n keycloak-system -l app=keycloak -o name | head -1)\n\nkubectl exec -it -n keycloak-system ${KEYCLOAK_POD} -- \\\n  curl -v telnet://smtp.sendgrid.net:587\n</code></pre> <p>Solutions: - Verify host/port correct - Check firewall/network policies - Ensure SMTP service allows connections</p>"},{"location":"how-to/smtp-configuration/#authentication-failed","title":"Authentication Failed","text":"<p>Check: - Username/password correct in secret - API key format (some providers use \"apikey\" as username) - Account not locked/suspended</p> <pre><code># Verify secret contents\nkubectl get secret smtp-credentials -n my-app -o yaml\n</code></pre>"},{"location":"how-to/smtp-configuration/#emails-not-received","title":"Emails Not Received","text":"<p>Check: 1. Spam folder 2. Sender verification (AWS SES requires verified senders) 3. Rate limits (provider may throttle) 4. DKIM/SPF records if using custom domain</p>"},{"location":"how-to/smtp-configuration/#ssltls-issues","title":"SSL/TLS Issues","text":"<p>Port Configuration: - Port 587: Use <code>starttls: true</code>, <code>ssl: false</code> - Port 465: Use <code>ssl: true</code>, <code>starttls: false</code> - Port 25: Use <code>starttls: false</code>, <code>ssl: false</code> (not recommended)</p> <pre><code># For port 465 (SSL)\nsmtp:\n  port: 465\n  ssl: true\n  starttls: false\n</code></pre>"},{"location":"how-to/smtp-configuration/#production-best-practices","title":"Production Best Practices","text":""},{"location":"how-to/smtp-configuration/#1-use-sealedsecrets","title":"1. Use SealedSecrets","text":"<pre><code># Encrypt SMTP credentials\nkubeseal -o yaml &lt; smtp-secret.yaml &gt; smtp-secret-sealed.yaml\nkubectl apply -f smtp-secret-sealed.yaml\n</code></pre>"},{"location":"how-to/smtp-configuration/#2-dedicated-smtp-service-account","title":"2. Dedicated SMTP Service Account","text":"<p>Create dedicated account/API key for Keycloak: - Limit permissions (send-only) - Easier to rotate credentials - Better audit trail</p>"},{"location":"how-to/smtp-configuration/#3-monitor-email-delivery","title":"3. Monitor Email Delivery","text":"<p>Track metrics: - Emails sent (Keycloak events) - Bounce rate (provider dashboard) - Delivery time</p>"},{"location":"how-to/smtp-configuration/#4-configure-rate-limits","title":"4. Configure Rate Limits","text":"<p>Avoid provider throttling: - SendGrid: 100 emails/day (free), higher for paid - Gmail: 500 emails/day - AWS SES: 200 emails/day (sandbox), higher after verification</p>"},{"location":"how-to/smtp-configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>KeycloakRealm CRD Reference</li> <li>Troubleshooting Guide</li> </ul>"},{"location":"operations/migration/","title":"Migration &amp; Upgrade Guide","text":"<p>This guide covers upgrading the Keycloak operator, migrating between token systems, and comparing this operator with the official Keycloak operator.</p>"},{"location":"operations/migration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Upgrading the Operator</li> <li>Upgrading Keycloak Version</li> <li>Comparison with Official Keycloak Operator</li> <li>Backup &amp; Rollback</li> </ol>"},{"location":"operations/migration/#upgrading-the-operator","title":"Upgrading the Operator","text":""},{"location":"operations/migration/#pre-upgrade-checklist","title":"Pre-Upgrade Checklist","text":"<ul> <li> Backup current state - Export all Keycloak resources</li> <li> Review release notes - Check for breaking changes</li> <li> Test in non-production - Upgrade staging environment first</li> <li> Check database backups - Ensure recent backup exists</li> <li> Document current versions - Record operator and Keycloak versions</li> </ul>"},{"location":"operations/migration/#step-1-backup-current-state","title":"Step 1: Backup Current State","text":"<pre><code># Backup all Keycloak resources\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces -o yaml \\\n  &gt; keycloak-resources-backup-$(date +%Y%m%d).yaml\n\n# Backup operator configuration\nhelm get values keycloak-operator -n keycloak-operator-system \\\n  &gt; operator-values-backup-$(date +%Y%m%d).yaml\n\n# Backup token metadata\nkubectl get configmap keycloak-operator-token-metadata \\\n  -n keycloak-operator-system -o yaml \\\n  &gt; token-metadata-backup-$(date +%Y%m%d).yaml\n\n# Backup CRDs\nkubectl get crd -o yaml | grep -A1000 \"vriesdemichael.github.io\" \\\n  &gt; crds-backup-$(date +%Y%m%d).yaml\n</code></pre>"},{"location":"operations/migration/#step-2-check-current-version","title":"Step 2: Check Current Version","text":"<pre><code># Get current operator version\nhelm list -n keycloak-operator-system\n\n# Get operator image version\nkubectl get deployment keycloak-operator -n keycloak-operator-system \\\n  -o jsonpath='{.spec.template.spec.containers[0].image}'\n</code></pre>"},{"location":"operations/migration/#step-3-review-release-notes","title":"Step 3: Review Release Notes","text":"<p>Check the Releases Page for: - Breaking changes - New features - Bug fixes - Migration requirements</p>"},{"location":"operations/migration/#step-4-upgrade-operator-helm","title":"Step 4: Upgrade Operator (Helm)","text":"<pre><code># Update Helm repository\nhelm repo update\n\n# Check available versions\nhelm search repo keycloak-operator --versions\n\n# Upgrade operator\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --values operator-values-backup-$(date +%Y%m%d).yaml \\\n  --wait\n</code></pre> <p>Important: The <code>--wait</code> flag ensures the upgrade completes before returning.</p>"},{"location":"operations/migration/#step-5-verify-upgrade","title":"Step 5: Verify Upgrade","text":"<pre><code># Check operator pods are running new version\nkubectl get pods -n keycloak-operator-system\n\n# Check operator logs for startup\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator --tail=50\n\n# Verify CRDs updated\nkubectl get crd keycloaks.vriesdemichael.github.io -o yaml | grep -A5 version\n\n# Check all resources still healthy\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces\n</code></pre> <p>All resources should remain in <code>Ready</code> phase.</p>"},{"location":"operations/migration/#step-6-test-reconciliation","title":"Step 6: Test Reconciliation","text":"<pre><code># Trigger reconciliation on a test realm\nkubectl annotate keycloakrealm &lt;test-realm&gt; -n &lt;test-namespace&gt; \\\n  reconcile=$(date +%s) --overwrite\n\n# Watch logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator -f\n\n# Verify realm still Ready\nkubectl get keycloakrealm &lt;test-realm&gt; -n &lt;test-namespace&gt;\n</code></pre>"},{"location":"operations/migration/#rollback-procedure","title":"Rollback Procedure","text":"<p>If upgrade fails:</p> <pre><code># Rollback Helm release\nhelm rollback keycloak-operator -n keycloak-operator-system\n\n# Verify operator rolled back\nkubectl get pods -n keycloak-operator-system\n\n# Check resources still healthy\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces\n</code></pre> <p>Important: CRD changes cannot be automatically rolled back. You may need to manually restore CRDs from backup:</p> <pre><code>kubectl apply -f crds-backup-&lt;date&gt;.yaml\n</code></pre>"},{"location":"operations/migration/#upgrading-keycloak-version","title":"Upgrading Keycloak Version","text":""},{"location":"operations/migration/#supported-keycloak-versions","title":"Supported Keycloak Versions","text":"<ul> <li>Minimum: Keycloak 25.0.0 (management port 9000 requirement)</li> <li>Recommended: Keycloak 26.0.0+</li> <li>Maximum: Latest Keycloak release</li> </ul>"},{"location":"operations/migration/#pre-upgrade-checklist_1","title":"Pre-Upgrade Checklist","text":"<ul> <li> Check Keycloak release notes - Review breaking changes</li> <li> Backup database - CloudNativePG backup or manual export</li> <li> Test in non-production - Verify compatibility</li> <li> Schedule maintenance window - Plan for brief downtime</li> </ul>"},{"location":"operations/migration/#upgrade-strategy","title":"Upgrade Strategy","text":"<p>Blue-Green Deployment (Recommended): 1. Deploy new Keycloak version alongside old version 2. Switch traffic to new version 3. Keep old version for quick rollback 4. Remove old version after verification</p> <p>Rolling Update (Simpler): 1. Update Keycloak resource with new image tag 2. Operator performs rolling update 3. Brief downtime during pod restarts</p>"},{"location":"operations/migration/#rolling-update-procedure","title":"Rolling Update Procedure","text":"<pre><code># Check current Keycloak version\nkubectl get keycloak &lt;name&gt; -n &lt;namespace&gt; \\\n  -o jsonpath='{.spec.image.tag}'\n\n# Update to new version\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  image:\n    tag: \"26.0.0\"\n'\n\n# Watch rollout\nkubectl rollout status statefulset/&lt;keycloak-name&gt; -n &lt;namespace&gt;\n\n# Verify all pods running new version\nkubectl get pods -n &lt;namespace&gt; -l app=keycloak \\\n  -o jsonpath='{range .items[*]}{.metadata.name}{\"\\t\"}{.spec.containers[0].image}{\"\\n\"}{end}'\n</code></pre>"},{"location":"operations/migration/#verify-upgrade","title":"Verify Upgrade","text":"<pre><code># Check Keycloak status\nkubectl get keycloak &lt;name&gt; -n &lt;namespace&gt;\n# Should show PHASE=Ready\n\n# Check all realms still working\nkubectl get keycloakrealm --all-namespaces\n\n# Test OAuth2 flow\n# (Use test client to verify authentication)\n\n# Check database schema version\nkubectl exec -it -n &lt;namespace&gt; &lt;keycloak-pod&gt; -- \\\n  psql -h &lt;db-host&gt; -U keycloak -d keycloak \\\n  -c \"SELECT * FROM databasechangelog ORDER BY orderexecuted DESC LIMIT 5;\"\n</code></pre>"},{"location":"operations/migration/#rollback-to-previous-version","title":"Rollback to Previous Version","text":"<pre><code># Revert to previous image tag\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  image:\n    tag: \"25.0.6\"\n'\n\n# Watch rollout\nkubectl rollout status statefulset/&lt;keycloak-name&gt; -n &lt;namespace&gt;\n\n# Verify rollback\nkubectl get pods -n &lt;namespace&gt; -l app=keycloak\n</code></pre> <p>Note: Keycloak database migrations are forward-only. Rolling back may require database restore if schema was upgraded.</p>"},{"location":"operations/migration/#comparison-with-official-keycloak-operator","title":"Comparison with Official Keycloak Operator","text":""},{"location":"operations/migration/#overview","title":"Overview","text":"Aspect This Operator Official Keycloak Operator Primary Focus GitOps-native, multi-tenant General Keycloak deployment Language Python (Kopf) Go (Operator SDK) CRDs Keycloak, KeycloakRealm, KeycloakClient Keycloak, KeycloakRealmImport Authorization Namespace grant lists + RBAC RBAC + direct access Multi-tenancy First-class support Limited GitOps Compatibility Excellent Good Secret Management Kubernetes-native Kubernetes + Keycloak Database CloudNativePG (CNPG) primary External PostgreSQL"},{"location":"operations/migration/#when-to-use-this-operator","title":"When to Use This Operator","text":"<p>\u2705 Choose this operator if: - Multi-tenant environment (10+ teams) - GitOps-first workflow (ArgoCD, Flux) - Strong namespace isolation required - Declarative authorization via grant lists - CloudNativePG database management preferred</p>"},{"location":"operations/migration/#when-to-use-official-operator","title":"When to Use Official Operator","text":"<p>\u2705 Choose official operator if: - Single-tenant environment - Need Keycloak's built-in security model - Organization policy requires official/upstream operators - Integration with Red Hat/RHSSO required - Prefer Go-based operators - Need features not yet in this operator</p>"},{"location":"operations/migration/#feature-comparison","title":"Feature Comparison","text":""},{"location":"operations/migration/#realm-management","title":"Realm Management","text":"Feature This Operator Official Operator Declarative realm config \u2705 KeycloakRealm CRD \u2705 KeycloakRealmImport Live realm updates \u2705 Automatic reconciliation \u26a0\ufe0f Import-based Drift detection \u2705 Built-in \u274c Not supported Multi-namespace realms \u2705 Fully supported \u26a0\ufe0f Limited Realm deletion \u2705 Automatic \u26a0\ufe0f Manual"},{"location":"operations/migration/#client-management","title":"Client Management","text":"Feature This Operator Official Operator Declarative client config \u2705 KeycloakClient CRD \u26a0\ufe0f Via RealmImport Client secret management \u2705 Automatic Kubernetes secret \u26a0\ufe0f Via RealmImport Protocol mappers \u2705 CRD support \u2705 Via RealmImport Service accounts \u2705 CRD support \u2705 Via RealmImport Cross-namespace clients \u2705 Fully supported \u274c Not supported"},{"location":"operations/migration/#security-model","title":"Security Model","text":"Feature This Operator Official Operator Authorization method Secret-based tokens Keycloak admin credentials Token rotation \u2705 Automatic (90-day) \u274c Manual Multi-tenant isolation \u2705 Namespace-scoped tokens \u26a0\ufe0f RBAC-based Audit trail \u2705 K8s API + ConfigMap \u26a0\ufe0f Keycloak logs Secret distribution \u2705 GitOps-friendly \u26a0\ufe0f Manual"},{"location":"operations/migration/#operations","title":"Operations","text":"Feature This Operator Official Operator Database management \u2705 CNPG integration \u26a0\ufe0f External required Backup/restore \u2705 Via CNPG \u26a0\ufe0f Manual High availability \u2705 Multi-replica support \u2705 Multi-replica support Monitoring \u2705 Prometheus metrics \u2705 Prometheus metrics Rate limiting \u2705 Built-in API rate limiting \u274c Not supported"},{"location":"operations/migration/#migration-from-official-operator","title":"Migration from Official Operator","text":"<p>Not Automated - Migration requires manual steps:</p> <ol> <li> <p>Export data from existing Keycloak:    <pre><code># Export realms from existing Keycloak\nkubectl exec -it &lt;keycloak-pod&gt; -- \\\n  /opt/keycloak/bin/kc.sh export --dir /tmp/export\n</code></pre></p> </li> <li> <p>Deploy this operator alongside (different namespace)</p> </li> <li> <p>Create new Keycloak instance with this operator</p> </li> <li> <p>Import realm exports:</p> </li> <li>Create KeycloakRealm CRDs based on exports</li> <li> <p>Create KeycloakClient CRDs for each client</p> </li> <li> <p>Switch application traffic to new Keycloak</p> </li> <li> <p>Decommission old operator after verification</p> </li> </ol> <p>Note: Direct migration is complex. Recommend running both operators in parallel during transition.</p>"},{"location":"operations/migration/#backup-rollback","title":"Backup &amp; Rollback","text":""},{"location":"operations/migration/#pre-upgrade-backup","title":"Pre-Upgrade Backup","text":"<p>Always backup before major changes:</p> <pre><code># Full backup script\n#!/bin/bash\nBACKUP_DIR=\"keycloak-backup-$(date +%Y%m%d-%H%M%S)\"\nmkdir -p ${BACKUP_DIR}\n\n# Backup resources\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces -o yaml \\\n  &gt; ${BACKUP_DIR}/resources.yaml\n\n# Backup operator config\nhelm get values keycloak-operator -n keycloak-operator-system \\\n  &gt; ${BACKUP_DIR}/operator-values.yaml\n\n# Backup token metadata\nkubectl get configmap keycloak-operator-token-metadata \\\n  -n keycloak-operator-system -o yaml \\\n  &gt; ${BACKUP_DIR}/token-metadata.yaml\n\n# Backup CRDs\nkubectl get crd -o yaml | grep -A1000 \"vriesdemichael.github.io\" \\\n  &gt; ${BACKUP_DIR}/crds.yaml\n\n# Backup database (if using CNPG)\nkubectl cnpg backup keycloak-db -n keycloak-db\n\necho \"Backup complete: ${BACKUP_DIR}\"\n</code></pre>"},{"location":"operations/migration/#database-backup-cloudnativepg","title":"Database Backup (CloudNativePG)","text":"<pre><code># Trigger manual backup\nkubectl cnpg backup keycloak-db -n keycloak-db\n\n# List backups\nkubectl get backup -n keycloak-db\n\n# Verify backup succeeded\nkubectl describe backup &lt;backup-name&gt; -n keycloak-db\n</code></pre>"},{"location":"operations/migration/#restore-from-backup","title":"Restore from Backup","text":"<p>Restore Kubernetes Resources:</p> <pre><code># Restore all resources\nkubectl apply -f keycloak-backup-&lt;date&gt;/resources.yaml\n\n# Verify resources restored\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces\n</code></pre> <p>Restore Database (see Backup &amp; Restore Guide):</p> <pre><code># Restore from specific backup\nkubectl cnpg restore keycloak-db \\\n  --backup &lt;backup-name&gt; \\\n  --namespace keycloak-db\n</code></pre>"},{"location":"operations/migration/#rollback-operator","title":"Rollback Operator","text":"<pre><code># Rollback to previous Helm release\nhelm rollback keycloak-operator -n keycloak-operator-system\n\n# Or rollback to specific revision\nhelm history keycloak-operator -n keycloak-operator-system\nhelm rollback keycloak-operator &lt;revision&gt; -n keycloak-operator-system\n\n# Verify rollback\nkubectl get pods -n keycloak-operator-system\n</code></pre>"},{"location":"operations/migration/#emergency-procedures","title":"Emergency Procedures","text":"<p>Operator Completely Broken:</p> <pre><code># Uninstall operator (resources remain)\nhelm uninstall keycloak-operator -n keycloak-operator-system\n\n# Resources continue working (Keycloak still serves traffic)\n# Reinstall operator when ready:\nhelm install keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --values operator-values-backup.yaml\n</code></pre> <p>Keycloak Database Corrupted:</p> <pre><code># Restore from backup (requires downtime)\nkubectl delete cluster keycloak-db -n keycloak-db\nkubectl cnpg restore keycloak-db \\\n  --backup &lt;backup-name&gt; \\\n  --namespace keycloak-db\n\n# Wait for database to come back\nkubectl wait --for=condition=Ready cluster/keycloak-db \\\n  -n keycloak-db --timeout=10m\n\n# Restart Keycloak pods\nkubectl rollout restart statefulset/&lt;keycloak-name&gt; -n &lt;namespace&gt;\n</code></pre>"},{"location":"operations/migration/#best-practices","title":"Best Practices","text":""},{"location":"operations/migration/#upgrade-strategy_1","title":"Upgrade Strategy","text":"<ol> <li>Test First - Always test upgrades in non-production</li> <li>Backup Always - Never upgrade without recent backup</li> <li>Read Release Notes - Check for breaking changes</li> <li>Rolling Updates - Use rolling updates for zero downtime</li> <li>Verify Thoroughly - Test all critical flows after upgrade</li> <li>Monitor - Watch metrics and logs during upgrade</li> <li>Have Rollback Plan - Know how to rollback before starting</li> </ol>"},{"location":"operations/migration/#maintenance-windows","title":"Maintenance Windows","text":"<p>Schedule upgrades during low-traffic periods:</p> <pre><code># Check current traffic\nkubectl exec -n keycloak-operator-system deployment/keycloak-operator -- \\\n  curl -s localhost:8080/metrics | grep keycloak_api_requests_total\n\n# Notify users of maintenance window\n# Perform upgrade\n# Verify and re-enable traffic\n</code></pre>"},{"location":"operations/migration/#documentation","title":"Documentation","text":"<p>Document your upgrade:</p> <ul> <li>Pre-upgrade state (versions, configurations)</li> <li>Steps taken</li> <li>Issues encountered</li> <li>Resolution steps</li> <li>Post-upgrade verification</li> <li>Rollback procedure used (if any)</li> </ul>"},{"location":"operations/migration/#related-documentation","title":"Related Documentation","text":"<ul> <li>End-to-End Setup Guide</li> <li>Backup &amp; Restore Guide</li> <li>Troubleshooting Guide</li> <li>Security Model</li> </ul>"},{"location":"operations/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and resolve common issues with the Keycloak operator. Issues are organized by symptom for faster troubleshooting.</p>"},{"location":"operations/troubleshooting/#quick-diagnostic-commands","title":"Quick Diagnostic Commands","text":"<pre><code># Check all Keycloak resources at once\nkubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces\n\n# Check operator health\nkubectl get pods -n keycloak-operator-system\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator --tail=100\n\n# Check events (recent issues)\nkubectl get events --all-namespaces --sort-by='.lastTimestamp' | tail -20\n</code></pre>"},{"location":"operations/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Operator Issues</li> <li>Keycloak Instance Issues</li> <li>Realm Issues</li> <li>Client Issues</li> <li>Token &amp; Authorization Issues</li> <li>Database Issues</li> <li>Networking &amp; Ingress Issues</li> <li>Performance Issues</li> <li>Common Pitfalls</li> </ol>"},{"location":"operations/troubleshooting/#operator-issues","title":"Operator Issues","text":""},{"location":"operations/troubleshooting/#symptom-operator-pods-not-starting","title":"Symptom: Operator Pods Not Starting","text":"<p>Possible Causes: - Image pull failure - RBAC permissions missing - Resource constraints - CRD installation failure</p> <p>Diagnosis:</p> <pre><code># Check pod status\nkubectl get pods -n keycloak-operator-system\n\n# Check pod events\nkubectl describe pod -n keycloak-operator-system &lt;pod-name&gt;\n\n# Check operator logs\nkubectl logs -n keycloak-operator-system &lt;pod-name&gt;\n</code></pre> <p>Solutions:</p> <p>Image Pull Failure: <pre><code># Check imagePullSecrets configured\nkubectl get deployment -n keycloak-operator-system keycloak-operator -o yaml | grep imagePullSecrets\n\n# Verify image exists and is accessible\nkubectl run test-pull --image=&lt;operator-image&gt; --restart=Never -n keycloak-operator-system\nkubectl delete pod test-pull -n keycloak-operator-system\n</code></pre></p> <p>RBAC Issues: <pre><code># Verify ClusterRole exists\nkubectl get clusterrole keycloak-operator\n\n# Verify ClusterRoleBinding exists\nkubectl get clusterrolebinding keycloak-operator\n\n# Test operator service account permissions\nkubectl auth can-i get keycloaks \\\n  --as=system:serviceaccount:keycloak-operator-system:keycloak-operator\n</code></pre></p> <p>Resource Constraints: <pre><code># Check node resources\nkubectl top nodes\n\n# Increase operator resources\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set operator.resources.requests.cpu=200m \\\n  --set operator.resources.requests.memory=512Mi\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-operator-crashes-or-restarts-frequently","title":"Symptom: Operator Crashes or Restarts Frequently","text":"<p>Possible Causes: - Memory pressure (OOMKilled) - Unhandled exceptions - Rate limiting issues - Too many reconciliation loops</p> <p>Diagnosis:</p> <pre><code># Check restart count\nkubectl get pods -n keycloak-operator-system\n\n# Check for OOMKilled\nkubectl describe pod -n keycloak-operator-system &lt;pod-name&gt; | grep -A5 \"Last State\"\n\n# Check logs before crash\nkubectl logs -n keycloak-operator-system &lt;pod-name&gt; --previous\n\n# Check memory usage\nkubectl top pod -n keycloak-operator-system\n</code></pre> <p>Solutions:</p> <p>OOMKilled: <pre><code># Increase memory limits\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set operator.resources.limits.memory=1Gi\n</code></pre></p> <p>Reconciliation Loops: <pre><code># Check for stuck resources\nkubectl get keycloaks,keycloakrealms,keycloakclients --all-namespaces \\\n  | grep -v Ready\n\n# Check operator logs for specific resource\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"namespace/resource-name\"\n</code></pre></p> <p>Rate Limiting: <pre><code># Check rate limit metrics\nkubectl exec -n keycloak-operator-system deployment/keycloak-operator -- \\\n  curl -s localhost:8080/metrics | grep rate_limit\n\n# Increase rate limits if needed\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set 'operator.env[0].name=KEYCLOAK_API_GLOBAL_RATE_LIMIT_TPS' \\\n  --set 'operator.env[0].value=100'\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-operator-not-reconciling-resources","title":"Symptom: Operator Not Reconciling Resources","text":"<p>Possible Causes: - Operator not watching the namespace - Resource validation failures - API server connectivity issues - Rate limiting</p> <p>Diagnosis:</p> <pre><code># Check if operator sees the resource\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"namespace/resource-name\"\n\n# Check resource status\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt;\n\n# Check for validation errors\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o yaml | grep -A10 status\n</code></pre> <p>Solutions:</p> <p>Operator Not Watching Namespace: <pre><code># Verify operator is cluster-scoped (watches all namespaces)\nkubectl get clusterrole keycloak-operator -o yaml | grep namespaces\n\n# Restart operator to pick up new namespaces\nkubectl rollout restart deployment/keycloak-operator -n keycloak-operator-system\n</code></pre></p> <p>Validation Failures: <pre><code># Check resource against schema\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o yaml\n\n# Fix validation issues and reapply\nkubectl apply -f fixed-resource.yaml\n</code></pre></p>"},{"location":"operations/troubleshooting/#keycloak-instance-issues","title":"Keycloak Instance Issues","text":""},{"location":"operations/troubleshooting/#symptom-keycloak-instance-stuck-in-pendingprovisioning","title":"Symptom: Keycloak Instance Stuck in Pending/Provisioning","text":"<p>Possible Causes: - Database not ready - Image pull failure - Insufficient resources - PVC not bound</p> <p>Diagnosis:</p> <pre><code># Check Keycloak status\nkubectl describe keycloak &lt;name&gt; -n &lt;namespace&gt;\n\n# Check Keycloak pods\nkubectl get pods -n &lt;namespace&gt; -l app=keycloak\n\n# Check events\nkubectl get events -n &lt;namespace&gt; --sort-by='.lastTimestamp' | tail -20\n\n# Check database cluster\nkubectl get cluster -n &lt;db-namespace&gt;\n</code></pre> <p>Solutions:</p> <p>Database Not Ready: <pre><code># Check database cluster status\nkubectl get cluster &lt;cluster-name&gt; -n &lt;db-namespace&gt;\nkubectl get pods -n &lt;db-namespace&gt; -l cnpg.io/cluster=&lt;cluster-name&gt;\n\n# Wait for database to become ready\nkubectl wait --for=condition=Ready cluster/&lt;cluster-name&gt; \\\n  -n &lt;db-namespace&gt; --timeout=10m\n</code></pre></p> <p>Image Pull Failure: <pre><code># Check image name/tag\nkubectl get keycloak &lt;name&gt; -n &lt;namespace&gt; -o jsonpath='{.spec.image}'\n\n# Test image pull manually\nkubectl run test-keycloak --image=quay.io/keycloak/keycloak:26.0.0 \\\n  --restart=Never -n &lt;namespace&gt;\nkubectl delete pod test-keycloak -n &lt;namespace&gt;\n</code></pre></p> <p>Insufficient Resources: <pre><code># Check node resources\nkubectl top nodes\n\n# Check resource requests\nkubectl get keycloak &lt;name&gt; -n &lt;namespace&gt; -o yaml | grep -A5 resources\n\n# Reduce resource requests temporarily\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  resources:\n    requests:\n      cpu: 250m\n      memory: 512Mi\n'\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-keycloak-pods-crashloopbackoff","title":"Symptom: Keycloak Pods CrashLoopBackOff","text":"<p>Possible Causes: - Database connection failure - Invalid configuration - Port conflicts - Health check failures</p> <p>Diagnosis:</p> <pre><code># Check pod logs\nkubectl logs -n &lt;namespace&gt; &lt;keycloak-pod&gt; --tail=100\n\n# Check previous container logs\nkubectl logs -n &lt;namespace&gt; &lt;keycloak-pod&gt; --previous\n\n# Check liveness/readiness probes\nkubectl describe pod -n &lt;namespace&gt; &lt;keycloak-pod&gt; | grep -A5 \"Liveness\\|Readiness\"\n</code></pre> <p>Solutions:</p> <p>Database Connection Failure: <pre><code># Verify database credentials secret exists\nkubectl get secret &lt;db-credentials-secret&gt; -n &lt;db-namespace&gt;\n\n# Test database connection from pod\nkubectl exec -it -n &lt;namespace&gt; &lt;keycloak-pod&gt; -- \\\n  psql -h &lt;db-host&gt; -U &lt;db-user&gt; -d keycloak -c \"SELECT 1;\"\n\n# Check database credentials are correct\nkubectl get secret &lt;db-credentials-secret&gt; -n &lt;db-namespace&gt; \\\n  -o jsonpath='{.data.username}' | base64 -d &amp;&amp; echo\n</code></pre></p> <p>Port 9000 Not Available (Keycloak &lt; 25.0.0): <pre><code># Check Keycloak version\nkubectl get keycloak &lt;name&gt; -n &lt;namespace&gt; \\\n  -o jsonpath='{.spec.image.tag}'\n\n# Keycloak requires version 25.0.0+ for management port 9000\n# Upgrade to supported version:\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  image:\n    tag: \"26.0.0\"\n'\n</code></pre></p> <p>Health Check Too Aggressive: <pre><code># Increase probe delays\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  probes:\n    liveness:\n      initialDelaySeconds: 180\n      periodSeconds: 30\n    readiness:\n      initialDelaySeconds: 120\n      periodSeconds: 10\n'\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-need-to-verify-keycloak-internal-state","title":"Symptom: Need to Verify Keycloak Internal State","text":"<p>Important: You should never need to access the Keycloak admin console. All configuration and verification should be done through CRDs and Kubernetes-native tools.</p> <p>Preferred Verification Methods:</p> <pre><code># Check Keycloak instance status\nkubectl get keycloak &lt;name&gt; -n &lt;namespace&gt;\nkubectl describe keycloak &lt;name&gt; -n &lt;namespace&gt;\n\n# Check all managed resources\nkubectl get keycloakrealm,keycloakclient -n &lt;namespace&gt;\n\n# View detailed realm configuration\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o yaml\n\n# Check operator reconciliation logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator --tail=100\n</code></pre> <p>Advanced Debugging (Operator Developers Only):</p> <p>If CRD status fields are insufficient and you need to query Keycloak's internal state directly:</p> <pre><code># Port-forward to management API (port 9000, NOT UI)\nkubectl port-forward svc/&lt;keycloak-service&gt; -n &lt;namespace&gt; 9000:9000\n\n# Get admin credentials\nADMIN_USER=$(kubectl get secret &lt;name&gt;-admin-credentials -n &lt;namespace&gt; \\\n  -o jsonpath='{.data.username}' | base64 -d)\nADMIN_PASS=$(kubectl get secret &lt;name&gt;-admin-credentials -n &lt;namespace&gt; \\\n  -o jsonpath='{.data.password}' | base64 -d)\n\n# Get access token\nTOKEN=$(curl -s -X POST http://localhost:9000/realms/master/protocol/openid-connect/token \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"username=$ADMIN_USER\" \\\n  -d \"password=$ADMIN_PASS\" \\\n  -d \"grant_type=password\" \\\n  -d \"client_id=admin-cli\" | jq -r '.access_token')\n\n# Query Keycloak API (example: get realm)\ncurl -s http://localhost:9000/admin/realms/&lt;realm-name&gt; \\\n  -H \"Authorization: Bearer $TOKEN\" | jq .\n</code></pre> <p>Note: The admin console UI (port 8080) is intentionally not exposed. This operator enforces least privilege - all configuration must be done through GitOps/CRDs.</p>"},{"location":"operations/troubleshooting/#realm-issues","title":"Realm Issues","text":""},{"location":"operations/troubleshooting/#symptom-realm-stuck-in-pendingprovisioning","title":"Symptom: Realm Stuck in Pending/Provisioning","text":"<p>Possible Causes: - Authorization token invalid - Keycloak instance not ready - API connectivity issues - Rate limiting</p> <p>Diagnosis:</p> <pre><code># Check realm status\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt;\n\n# Check authorization secret exists\nkubectl get secret &lt;auth-secret-name&gt; -n &lt;namespace&gt;\n\n# Check Keycloak instance status\nkubectl get keycloak -n &lt;keycloak-namespace&gt;\n\n# Check operator logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"keycloakrealm/&lt;name&gt;\"\n</code></pre> <p>Solutions:</p> <p>Authorization Token Missing: <pre><code># Verify secret exists\nkubectl get secret &lt;auth-secret-name&gt; -n &lt;namespace&gt;\n\nkubectl get secret &lt;namespace&gt;-operator-token -n &lt;namespace&gt;\n\n# Check secret has correct labels\nkubectl get secret &lt;auth-secret-name&gt; -n &lt;namespace&gt; -o yaml | grep -A3 labels\n</code></pre></p> <p>Keycloak Instance Not Ready: <pre><code># Wait for Keycloak to become ready\nkubectl wait --for=condition=Ready keycloak/&lt;name&gt; \\\n  -n &lt;keycloak-namespace&gt; --timeout=5m\n\n# Check Keycloak pods\nkubectl get pods -n &lt;keycloak-namespace&gt; -l app=keycloak\n</code></pre></p> <p>API Connectivity: <pre><code># Test connectivity from operator to Keycloak\nkubectl exec -n keycloak-operator-system deployment/keycloak-operator -- \\\n  curl -v http://keycloak-keycloak.&lt;keycloak-namespace&gt;.svc:8080/health\n\n# Check network policies\nkubectl get networkpolicy -n &lt;keycloak-namespace&gt;\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-realm-authorization-failed","title":"Symptom: Realm Authorization Failed","text":"<p>Possible Causes: - Token mismatch - Token expired - Wrong secret referenced - Token not in metadata ConfigMap</p> <p>Diagnosis:</p> <pre><code># Check realm status for authorization error\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt; | grep -i authorization\n\n# Check which secret realm is using\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; \\\n  # Authorization no longer uses tokens\n\n# Verify secret exists\nkubectl get secret &lt;secret-name&gt; -n &lt;namespace&gt;\n\n# Check token in ConfigMap\nTOKEN=$(kubectl get secret &lt;secret-name&gt; -n &lt;namespace&gt; \\\n  -o jsonpath='{.data.token}' | base64 -d)\nTOKEN_HASH=$(echo -n \"$TOKEN\" | sha256sum | cut -d' ' -f1)\nkubectl get configmap keycloak-operator-token-metadata \\\n  -n keycloak-operator-system -o yaml | grep \"$TOKEN_HASH\"\n</code></pre> <p>Solutions:</p> <p>Using Wrong Token: <pre><code>kubectl patch keycloakrealm &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  operatorRef:\n      key: token\n'\n</code></pre></p> <p>Token Expired (Grace Period Ended): <pre><code># Check token expiry\nkubectl get secret &lt;namespace&gt;-operator-token -n &lt;namespace&gt; \\\n  -o jsonpath='{.metadata.annotations.vriesdemichael\\.github\\.io/valid-until}'\n\n# Check if during grace period\nkubectl get secret &lt;namespace&gt;-operator-token -n &lt;namespace&gt; \\\n  -o jsonpath='{.data}' | jq 'keys'\n# During grace: [\"token\", \"token-previous\"]\n# After grace: [\"token\"]\n\n# If after grace period, ensure using \"token\" key (not \"token-previous\")\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; \\\n  # Authorization no longer uses tokens\n# Should be \"token\"\n</code></pre></p> <p>Bootstrap Not Completed: <pre><code>\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-realm-configuration-not-applied","title":"Symptom: Realm Configuration Not Applied","text":"<p>Possible Causes: - Drift detection disabled - Manual changes in Keycloak admin console - Reconciliation not triggered - Invalid configuration values</p> <p>Diagnosis:</p> <pre><code># Check realm status\nkubectl get keycloakrealm &lt;name&gt; -n &lt;namespace&gt; -o yaml | grep -A20 status\n\n# Check if drift detected\nkubectl describe keycloakrealm &lt;name&gt; -n &lt;namespace&gt; | grep -i drift\n\n# Compare CRD config to Keycloak\n# (Requires admin access to Keycloak)\n\n# Check operator logs for reconciliation\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"keycloakrealm/&lt;namespace&gt;/&lt;name&gt;\"\n</code></pre> <p>Solutions:</p> <p>Force Reconciliation: <pre><code># Add/update annotation to trigger reconciliation\nkubectl annotate keycloakrealm &lt;name&gt; -n &lt;namespace&gt; \\\n  reconcile=$(date +%s) --overwrite\n\n# Watch reconciliation\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator -f \\\n  | grep \"keycloakrealm/&lt;namespace&gt;/&lt;name&gt;\"\n</code></pre></p> <p>Drift Detection: <pre><code># Check if drift detection is enabled (check operator config)\nkubectl get deployment -n keycloak-operator-system keycloak-operator \\\n  -o yaml | grep DRIFT_DETECTION\n\n# Drift detection automatically corrects manual changes\n# Manual changes in admin console will be reverted on next reconciliation\n</code></pre></p>"},{"location":"operations/troubleshooting/#client-issues","title":"Client Issues","text":""},{"location":"operations/troubleshooting/#symptom-client-creation-fails","title":"Symptom: Client Creation Fails","text":"<p>Possible Causes: - Realm not ready - Realm authorization token invalid - Invalid client configuration - Client ID already exists</p> <p>Diagnosis:</p> <pre><code># Check client status\nkubectl describe keycloakclient &lt;name&gt; -n &lt;namespace&gt;\n\n# Check realm is Ready\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;namespace&gt;\n\n# Check realm authorization secret exists\nkubectl get secret &lt;realm-name&gt;-realm-auth -n &lt;namespace&gt;\n\n# Check operator logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"keycloakclient/&lt;namespace&gt;/&lt;name&gt;\"\n</code></pre> <p>Solutions:</p> <p>Realm Not Ready: <pre><code># Wait for realm\nkubectl wait --for=condition=Ready keycloakrealm/&lt;realm-name&gt; \\\n  -n &lt;namespace&gt; --timeout=2m\n</code></pre></p> <p>Realm Token Missing: <pre><code># Realm token should be auto-created when realm becomes Ready\nkubectl get secret &lt;realm-name&gt;-realm-auth -n &lt;namespace&gt;\n\n# If missing, check realm status\nkubectl describe keycloakrealm &lt;realm-name&gt; -n &lt;namespace&gt;\n\n# Force realm reconciliation to generate token\nkubectl annotate keycloakrealm &lt;realm-name&gt; -n &lt;namespace&gt; \\\n  reconcile=$(date +%s) --overwrite\n</code></pre></p> <p>Invalid Configuration: <pre><code># Check client spec for validation errors\nkubectl get keycloakclient &lt;name&gt; -n &lt;namespace&gt; -o yaml\n\n# Common issues:\n# - Invalid redirect URIs\n# - Missing required fields for client type\n# - Invalid protocol mapper configuration\n\n# Fix and reapply\nkubectl apply -f fixed-client.yaml\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-client-credentials-not-created","title":"Symptom: Client Credentials Not Created","text":"<p>Possible Causes: - Client not Ready - Secret name conflict - RBAC issues preventing secret creation</p> <p>Diagnosis:</p> <pre><code># Check client status\nkubectl get keycloakclient &lt;name&gt; -n &lt;namespace&gt;\n\n# Check if credentials secret exists\nkubectl get secret &lt;name&gt;-credentials -n &lt;namespace&gt;\n\n# Check operator logs for secret creation\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep \"secret/&lt;namespace&gt;/&lt;name&gt;-credentials\"\n</code></pre> <p>Solutions:</p> <p>Wait for Client to become Ready: <pre><code>kubectl wait --for=condition=Ready keycloakclient/&lt;name&gt; \\\n  -n &lt;namespace&gt; --timeout=2m\n\n# Secret is created when client transitions to Ready\n</code></pre></p> <p>Secret Name Conflict: <pre><code># Check if secret already exists (from previous client)\nkubectl get secret &lt;name&gt;-credentials -n &lt;namespace&gt;\n\n# Delete old secret if safe to do so\nkubectl delete secret &lt;name&gt;-credentials -n &lt;namespace&gt;\n\n# Force client reconciliation\nkubectl annotate keycloakclient &lt;name&gt; -n &lt;namespace&gt; \\\n  reconcile=$(date +%s) --overwrite\n</code></pre></p>"},{"location":"operations/troubleshooting/#authorization-issues","title":"Authorization Issues","text":""},{"location":"operations/troubleshooting/#symptom-realm-creation-fails-with-permission-denied","title":"Symptom: Realm Creation Fails with Permission Denied","text":"<p>Possible Causes: - Missing RBAC permissions to create KeycloakRealm resources - ServiceAccount lacks necessary ClusterRole binding - Namespace doesn't exist</p> <p>Diagnosis:</p> <pre><code># Check if user/ServiceAccount can create realms\nkubectl auth can-i create keycloakrealms.vriesdemichael.github.io \\\n  --namespace=&lt;namespace&gt;\n\n# Check existing RoleBindings\nkubectl get rolebinding,clusterrolebinding -A \\\n  -o json | jq '.items[] | select(.subjects[]?.name==\"&lt;serviceaccount-name&gt;\") | {name: .metadata.name, namespace: .metadata.namespace, role: .roleRef.name}'\n\n# Check operator logs for authorization errors\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep -i \"permission\\|forbidden\\|unauthorized\"\n</code></pre> <p>Solutions:</p> <p>Grant Realm Creation Permission: <pre><code># Create RoleBinding in target namespace\nkubectl create rolebinding realm-creator \\\n  --clusterrole=keycloak-realm-manager \\\n  --serviceaccount=&lt;namespace&gt;:&lt;serviceaccount&gt; \\\n  --namespace=&lt;namespace&gt;\n\n# Or use ClusterRoleBinding for cluster-wide access\nkubectl create clusterrolebinding realm-creator-global \\\n  --clusterrole=keycloak-realm-manager \\\n  --serviceaccount=&lt;namespace&gt;:&lt;serviceaccount&gt;\n</code></pre></p> <p>Verify Permissions: <pre><code># Test as the ServiceAccount\nkubectl auth can-i create keycloakrealms.vriesdemichael.github.io \\\n  --as=system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccount&gt; \\\n  --namespace=&lt;namespace&gt;\n# Should return \"yes\"\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-client-creation-fails-namespace-not-authorized","title":"Symptom: Client Creation Fails - Namespace Not Authorized","text":"<p>Possible Causes: - Client's namespace not in realm's <code>clientAuthorizationGrants</code> list - Realm doesn't exist or isn't ready - Typo in namespace name</p> <p>Diagnosis:</p> <pre><code># Check realm's authorization grants\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants}' | jq\n\n# Check if client namespace is in the list\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants[*]}' | grep -w &lt;client-namespace&gt;\n\n# Check operator logs\nkubectl logs -n keycloak-operator-system -l app=keycloak-operator \\\n  | grep -i \"authorization\\|grant\"\n</code></pre> <p>Solutions:</p> <p>Add Namespace to Grant List: <pre><code># Add client's namespace to realm's grants\nkubectl patch keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; --type=merge -p '\nspec:\n  clientAuthorizationGrants:\n    - &lt;existing-namespace&gt;\n    - &lt;client-namespace&gt;  # Add this\n'\n\n# Verify the update\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants}' | jq\n</code></pre></p> <p>Check Realm Status: <pre><code># Ensure realm is Ready before creating clients\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.status.phase}'\n# Should be \"Ready\"\n\n# If not ready, check status\nkubectl describe keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt;\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-operator-cant-read-secrets-in-client-namespace","title":"Symptom: Operator Can't Read Secrets in Client Namespace","text":"<p>Possible Causes: - Missing RoleBinding in client's namespace - Operator ServiceAccount lacks namespace access - <code>rbac.create=false</code> in Helm chart</p> <p>Diagnosis:</p> <pre><code># Check if operator can read secrets in namespace\nkubectl auth can-i get secrets \\\n  --as=system:serviceaccount:keycloak-system:keycloak-operator \\\n  --namespace=&lt;client-namespace&gt;\n\n# Check for RoleBinding\nkubectl get rolebinding -n &lt;client-namespace&gt; \\\n  -o json | jq '.items[] | select(.subjects[]?.name==\"keycloak-operator\")'\n\n# Check operator logs\nkubectl logs -n keycloak-system -l app=keycloak-operator \\\n  | grep -i \"forbidden\\|access denied\" | grep &lt;client-namespace&gt;\n</code></pre> <p>Solutions:</p> <p>Create RoleBinding for Operator: <pre><code># Grant operator read access to secrets\nkubectl create rolebinding keycloak-operator-secret-reader \\\n  --clusterrole=keycloak-operator-namespace-access \\\n  --serviceaccount=keycloak-system:keycloak-operator \\\n  --namespace=&lt;client-namespace&gt;\n\n# Or use Helm chart with rbac.create=true\nhelm install my-client charts/keycloak-client \\\n  --set rbac.create=true \\\n  --set rbac.operatorNamespace=keycloak-system \\\n  --namespace=&lt;client-namespace&gt;\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-cross-namespace-client-creation-not-working","title":"Symptom: Cross-Namespace Client Creation Not Working","text":"<p>Possible Causes: - Realm and client in different namespaces without grant - Incorrect namespace in <code>realmRef</code> - Network policies blocking cross-namespace communication</p> <p>Diagnosis:</p> <pre><code># Verify realmRef is correct\nkubectl get keycloakclient &lt;client-name&gt; -n &lt;client-namespace&gt; \\\n  -o jsonpath='{.spec.realmRef}' | jq\n\n# Check if client namespace is authorized\nkubectl get keycloakrealm &lt;realm-name&gt; -n &lt;realm-namespace&gt; \\\n  -o jsonpath='{.spec.clientAuthorizationGrants[*]}' \\\n  | tr ' ' '\\n' | grep -w &lt;client-namespace&gt;\n\n# Check operator can access both namespaces\nfor ns in &lt;realm-namespace&gt; &lt;client-namespace&gt;; do\n  echo \"Checking namespace: $ns\"\n  kubectl auth can-i get secrets \\\n    --as=system:serviceaccount:keycloak-system:keycloak-operator \\\n    --namespace=$ns\ndone\n</code></pre> <p>Solutions:</p> <p>Ensure Proper Configuration: <pre><code># Realm in namespace \"platform\"\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: shared-realm\n  namespace: platform\nspec:\n  clientAuthorizationGrants:\n    - app-team-a\n    - app-team-b\n\n---\n# Client in namespace \"app-team-a\"\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: my-app\n  namespace: app-team-a\nspec:\n  realmRef:\n    name: shared-realm\n    namespace: platform  # Points to realm's namespace\n</code></pre></p>"},{"location":"operations/troubleshooting/#database-issues","title":"Database Issues","text":""},{"location":"operations/troubleshooting/#symptom-database-cluster-not-starting","title":"Symptom: Database Cluster Not Starting","text":"<p>Possible Causes: - Storage not available - Credentials secret missing - CNPG operator not running - Resource constraints</p> <p>Diagnosis:</p> <pre><code># Check cluster status\nkubectl get cluster &lt;name&gt; -n &lt;namespace&gt;\n\n# Check cluster events\nkubectl describe cluster &lt;name&gt; -n &lt;namespace&gt;\n\n# Check pods\nkubectl get pods -n &lt;namespace&gt; -l cnpg.io/cluster=&lt;name&gt;\n\n# Check CNPG operator\nkubectl get pods -n cnpg-system\n</code></pre> <p>Solutions:</p> <p>Storage Issues: <pre><code># Check PVCs\nkubectl get pvc -n &lt;namespace&gt;\n\n# Check StorageClass\nkubectl get storageclass\n\n# Ensure StorageClass exists and is default\nkubectl patch storageclass &lt;name&gt; \\\n  -p '{\"metadata\": {\"annotations\":{\"storageclass.kubernetes.io/is-default-class\":\"true\"}}}'\n</code></pre></p> <p>Credentials Secret Missing: <pre><code># Check secret exists\nkubectl get secret &lt;credentials-secret&gt; -n &lt;namespace&gt;\n\n# Recreate if missing\nkubectl create secret generic &lt;credentials-secret&gt; \\\n  --from-literal=username=keycloak \\\n  --from-literal=password=\"$(python3 -c 'import secrets; print(secrets.token_urlsafe(32))')\" \\\n  --namespace=&lt;namespace&gt;\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-database-connection-refused","title":"Symptom: Database Connection Refused","text":"<p>Possible Causes: - Database pods not ready - Wrong database host/port - Network policies blocking traffic - Credentials incorrect</p> <p>Diagnosis:</p> <pre><code># Check database pods\nkubectl get pods -n &lt;db-namespace&gt; -l cnpg.io/cluster=&lt;cluster-name&gt;\n\n# Identify primary pod\nkubectl get cluster &lt;cluster-name&gt; -n &lt;db-namespace&gt; \\\n  -o jsonpath='{.status.currentPrimary}'\n\n# Test connection from Keycloak pod\nkubectl exec -it -n &lt;keycloak-namespace&gt; &lt;keycloak-pod&gt; -- \\\n  psql -h &lt;cluster-name&gt;-rw.&lt;db-namespace&gt;.svc -U keycloak -d keycloak -c \"SELECT 1;\"\n</code></pre> <p>Solutions:</p> <p>Database Not Ready: <pre><code># Wait for database\nkubectl wait --for=condition=Ready cluster/&lt;cluster-name&gt; \\\n  -n &lt;db-namespace&gt; --timeout=5m\n</code></pre></p> <p>Wrong Connection String: <pre><code># Correct format for CNPG:\n# Host: &lt;cluster-name&gt;-rw.&lt;namespace&gt;.svc\n# Port: 5432\n# Database: keycloak\n\n# Update Keycloak resource with correct database config\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  database:\n    type: cnpg\n    cluster: &lt;cluster-name&gt;\n    namespace: &lt;db-namespace&gt;\n'\n</code></pre></p>"},{"location":"operations/troubleshooting/#networking-ingress-issues","title":"Networking &amp; Ingress Issues","text":""},{"location":"operations/troubleshooting/#symptom-cannot-access-keycloak-via-ingress","title":"Symptom: Cannot Access Keycloak via Ingress","text":"<p>Possible Causes: - Ingress not created - DNS not configured - TLS certificate not ready - Ingress controller not working</p> <p>Diagnosis:</p> <pre><code># Check ingress exists\nkubectl get ingress -n &lt;namespace&gt;\n\n# Check ingress details\nkubectl describe ingress &lt;name&gt; -n &lt;namespace&gt;\n\n# Check ingress controller\nkubectl get pods -n ingress-nginx\n\n# Test DNS resolution\nnslookup &lt;hostname&gt;\n\n# Check certificate\nkubectl get certificate -n &lt;namespace&gt;\n</code></pre> <p>Solutions:</p> <p>DNS Not Configured: <pre><code># Get ingress external IP\nkubectl get svc -n ingress-nginx ingress-nginx-controller\n\n# Configure DNS A record:\n# &lt;hostname&gt; \u2192 &lt;external-ip&gt;\n\n# Verify DNS propagation\nnslookup &lt;hostname&gt;\n</code></pre></p> <p>TLS Certificate Not Ready: <pre><code># Check certificate status\nkubectl describe certificate &lt;name&gt;-tls -n &lt;namespace&gt;\n\n# Check cert-manager logs\nkubectl logs -n cert-manager -l app=cert-manager\n\n# Force certificate renewal\nkubectl delete certificaterequest -n &lt;namespace&gt; --all\n</code></pre></p> <p>Ingress Not Created: <pre><code># Enable ingress in Keycloak resource\nkubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  ingress:\n    enabled: true\n    className: nginx\n    host: keycloak.example.com\n'\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-port-forward-not-working","title":"Symptom: Port-Forward Not Working","text":"<p>Possible Causes: - Service not found - Pods not ready - kubectl not configured correctly - Port already in use</p> <p>Diagnosis:</p> <pre><code># Check service exists\nkubectl get svc -n &lt;namespace&gt;\n\n# Check pods are running\nkubectl get pods -n &lt;namespace&gt;\n\n# Check port not already in use\nlsof -i :8080  # On macOS/Linux\nnetstat -ano | findstr :8080  # On Windows\n</code></pre> <p>Solutions:</p> <p>Use Different Local Port: <pre><code># Use different local port\nkubectl port-forward svc/&lt;service-name&gt; -n &lt;namespace&gt; 8888:8080\n\n# Access at http://localhost:8888\n</code></pre></p> <p>Port-Forward to Pod Directly: <pre><code># If service not working, port-forward to pod\nkubectl port-forward -n &lt;namespace&gt; &lt;pod-name&gt; 8080:8080\n</code></pre></p>"},{"location":"operations/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"operations/troubleshooting/#symptom-slow-reconciliation","title":"Symptom: Slow Reconciliation","text":"<p>Possible Causes: - Rate limiting too aggressive - High API latency - Resource constraints on operator - Large number of resources</p> <p>Diagnosis:</p> <pre><code># Check rate limit metrics\nkubectl exec -n keycloak-operator-system deployment/keycloak-operator -- \\\n  curl -s localhost:8080/metrics | grep rate_limit\n\n# Check operator resource usage\nkubectl top pod -n keycloak-operator-system\n\n# Check reconciliation metrics\nkubectl exec -n keycloak-operator-system deployment/keycloak-operator -- \\\n  curl -s localhost:8080/metrics | grep reconcile\n</code></pre> <p>Solutions:</p> <p>Increase Rate Limits: <pre><code># Increase global and namespace rate limits\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set env.KEYCLOAK_API_GLOBAL_RATE_LIMIT_TPS=100 \\\n  --set env.KEYCLOAK_API_NAMESPACE_RATE_LIMIT_TPS=10\n</code></pre></p> <p>Increase Operator Resources: <pre><code># Increase CPU/memory for operator\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set resources.requests.cpu=500m \\\n  --set resources.requests.memory=512Mi\n</code></pre></p>"},{"location":"operations/troubleshooting/#symptom-high-memory-usage","title":"Symptom: High Memory Usage","text":"<p>Possible Causes: - Memory leak in operator - Too many reconciliation loops - Large resource specifications - Not enough replicas</p> <p>Diagnosis:</p> <pre><code># Check memory usage\nkubectl top pod -n keycloak-operator-system\n\n# Check for OOMKills\nkubectl describe pod -n keycloak-operator-system &lt;pod-name&gt; | grep -i oom\n\n# Check operator logs for memory errors\nkubectl logs -n keycloak-operator-system &lt;pod-name&gt; | grep -i memory\n</code></pre> <p>Solutions:</p> <p>Increase Memory Limits: <pre><code>helm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set resources.limits.memory=1Gi\n</code></pre></p> <p>Scale Operator Replicas: <pre><code># Distribute load across multiple replicas\nhelm upgrade keycloak-operator ./charts/keycloak-operator \\\n  --namespace keycloak-operator-system \\\n  --set replicas=3\n</code></pre></p>"},{"location":"operations/troubleshooting/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"operations/troubleshooting/#pitfall-1-using-operator-token-in-production","title":"Pitfall 1: Using Operator Token in Production","text":"<ol> <li>Tokens rotate automatically every 90 days</li> </ol> <p>See: Multi-Tenant Guide</p>"},{"location":"operations/troubleshooting/#pitfall-2-wrong-keycloak-version-2500","title":"Pitfall 2: Wrong Keycloak Version (&lt; 25.0.0)","text":"<p>Problem: Using Keycloak version &lt; 25.0.0 which doesn't support management port 9000.</p> <p>Impact: Health checks fail, pods crash</p> <p>Solution: Upgrade to Keycloak 25.0.0+: <pre><code>kubectl patch keycloak &lt;name&gt; -n &lt;namespace&gt; --type=merge -p '\nspec:\n  image:\n    tag: \"26.0.0\"\n'\n</code></pre></p>"},{"location":"operations/troubleshooting/#pitfall-3-forgetting-to-bootstrap-namespace","title":"Pitfall 3: Forgetting to Bootstrap Namespace","text":"<ol> <li>Operational token generated automatically</li> <li>Create subsequent realms</li> </ol>"},{"location":"operations/troubleshooting/#pitfall-4-manual-changes-in-keycloak-admin-console","title":"Pitfall 4: Manual Changes in Keycloak Admin Console","text":"<p>Problem: Making configuration changes directly in Keycloak admin console instead of updating CRDs.</p> <p>Impact: Changes reverted on next reconciliation (drift detection)</p> <p>Solution: Always update CRDs, not admin console: <pre><code>kubectl edit keycloakrealm &lt;name&gt; -n &lt;namespace&gt;\n# Changes apply automatically via reconciliation\n</code></pre></p>"},{"location":"operations/troubleshooting/#pitfall-5-port-8080-vs-port-9000-confusion","title":"Pitfall 5: Port 8080 vs Port 9000 Confusion","text":"<p>Problem: Trying to access management endpoints on port 8080 or user endpoints on port 9000.</p> <p>Ports: - 8080: User-facing (realms, OAuth2, admin console) - 9000: Management only (health checks, metrics) - internal use</p> <p>Solution: Always use port 8080 for user/admin access: <pre><code>kubectl port-forward svc/&lt;keycloak-service&gt; -n &lt;namespace&gt; 8080:8080\n</code></pre></p>"},{"location":"operations/troubleshooting/#pitfall-6-rbac-in-multi-namespace-setup","title":"Pitfall 6: RBAC in Multi-Namespace Setup","text":"<p>Problem: Not configuring RBAC for application teams to read authorization secrets.</p> <p>Impact: Teams can't create realms/clients</p> <p>Solution: Create Role allowing secret read access: <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: keycloak-realm-manager\n  namespace: &lt;team-namespace&gt;\nrules:\n  - apiGroups: [\"vriesdemichael.github.io\"]\n    resources: [\"keycloakrealms\", \"keycloakclients\"]\n    verbs: [\"create\", \"update\", \"patch\", \"delete\", \"get\", \"list\", \"watch\"]\n  - apiGroups: [\"\"]\n    resources: [\"secrets\"]\n    resourceNames: [\"&lt;namespace&gt;-operator-token\", \"*-realm-auth\"]\n    verbs: [\"get\"]\nEOF\n</code></pre></p>"},{"location":"operations/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you've tried the solutions above and still have issues:</p> <ol> <li> <p>Check Operator Logs:    <pre><code>kubectl logs -n keycloak-operator-system -l app=keycloak-operator --tail=200\n</code></pre></p> </li> <li> <p>Gather Diagnostics:    <pre><code>kubectl get keycloak,keycloakrealm,keycloakclient --all-namespaces -o yaml &gt; diagnostics.yaml\nkubectl get events --all-namespaces --sort-by='.lastTimestamp' &gt; events.txt\n</code></pre></p> </li> <li> <p>Report Issue:</p> </li> <li>GitHub Issues</li> <li> <p>Include operator logs, resource YAML, and error messages</p> </li> <li> <p>Community Support:</p> </li> <li>GitHub Discussions</li> </ol>"},{"location":"operations/troubleshooting/#see-also","title":"See Also","text":"<p>Problem-Specific Guides:</p> <ul> <li>Security Model - Authorization and access control</li> <li>Migration Guide - Troubleshooting migration from official Keycloak operator</li> <li>FAQ: Troubleshooting - Quick answers to frequent problems</li> </ul> <p>Configuration Reference:</p> <ul> <li>Keycloak CRD Reference - Valid configuration for Keycloak instances</li> <li>KeycloakRealm CRD Reference - Valid realm configurations</li> <li>KeycloakClient CRD Reference - Valid client configurations</li> </ul> <p>Setup Guides:</p> <ul> <li>End-to-End Setup - Complete production deployment walkthrough</li> <li>Database Setup - PostgreSQL configuration and troubleshooting</li> <li>High Availability Deployment - HA-specific troubleshooting</li> <li>Multi-Tenant Setup - Multi-tenant configuration issues</li> </ul> <p>Architecture:</p> <ul> <li>Architecture Overview - Understanding reconciliation flow and token system</li> <li>Security Model - Authorization model and token types</li> <li>Observability - Metrics and monitoring for proactive issue detection</li> </ul>"},{"location":"operations/troubleshooting/#related-documentation","title":"Related Documentation","text":"<ul> <li>End-to-End Setup Guide</li> <li>Multi-Tenant Configuration</li> <li>Security Model</li> <li>FAQ</li> </ul>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>Get started with the Keycloak Operator in 10 minutes using the 3-helm-chart approach!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ul> <li>\u2705 Kubernetes cluster (v1.26+)</li> <li>\u2705 <code>kubectl</code> configured to access your cluster</li> <li>\u2705 Helm 3.8+ installed (required for OCI registry support)</li> <li>\u2705 Cluster admin permissions (for CRD installation)</li> </ul>"},{"location":"quickstart/#storage-class-configuration","title":"Storage Class Configuration","text":"<p>If using CloudNativePG for the database, ensure your cluster has a suitable StorageClass:</p> <pre><code># Check available storage classes\nkubectl get storageclass\n\n# If your cluster doesn't have a 'standard' storageClass, configure it during install:\n--set keycloak.database.cnpg.storage.storageClass=&lt;your-storage-class&gt;\n</code></pre>"},{"location":"quickstart/#the-3-helm-chart-approach","title":"The 3-Helm-Chart Approach","text":"<p>This operator uses a modular helm chart structure:</p> <ol> <li>Database (<code>cloudnative-pg/cloudnative-pg</code>) - PostgreSQL cluster</li> <li>Operator + Keycloak (<code>keycloak-operator/keycloak-operator</code>) - Operator and instance</li> <li>Application Resources (<code>keycloak-realm</code>, <code>keycloak-client</code>) - Your realms and clients</li> </ol> <p>This separation enables: - \u2705 Shared Database - Multiple Keycloak instances can use one PostgreSQL cluster - \u2705 GitOps Friendly - Each chart in separate Helm release/ArgoCD application - \u2705 Namespace Isolation - Realms and clients in their own namespaces - \u2705 Modular Upgrades - Update components independently</p>"},{"location":"quickstart/#step-1-install-postgresql-database","title":"Step 1: Install PostgreSQL Database","text":"<p>Install CloudNativePG operator and create a PostgreSQL cluster:</p> <pre><code># Install CloudNativePG operator\nhelm repo add cnpg https://cloudnative-pg.github.io/charts\nhelm repo update\nhelm install cnpg cnpg/cloudnative-pg \\\n  --namespace cnpg-system \\\n  --create-namespace \\\n  --wait\n</code></pre> <p>The Keycloak operator chart can create the PostgreSQL cluster automatically using <code>keycloak.database.cnpg.enabled=true</code>.</p>"},{"location":"quickstart/#step-2-install-operator-keycloak-instance","title":"Step 2: Install Operator + Keycloak Instance","text":"<p>Install the operator with Keycloak instance enabled:</p> <pre><code># Install operator + Keycloak with CloudNativePG database (using OCI registry)\nhelm install keycloak-operator oci://ghcr.io/vriesdemichael/charts/keycloak-operator \\\n  --namespace keycloak-system \\\n  --set keycloak.enabled=true \\\n  --set keycloak.database.cnpg.enabled=true \\\n  --set keycloak.database.cnpg.clusterName=keycloak-postgres \\\n  --set keycloak.replicas=3 \\\n  --wait\n</code></pre> <p>Note: Namespace Creation The chart creates the namespace by default (<code>namespace.create=true</code>). Do not use <code>--create-namespace</code> flag with the default settings. If you prefer to create the namespace yourself, set <code>--set namespace.create=false</code> and use <code>--create-namespace</code>.</p> <p>What this installs: - \u2705 Keycloak operator (2 replicas for HA) - \u2705 Keycloak instance (3 replicas) - \u2705 PostgreSQL cluster (via CloudNativePG) - \u2705 Admission webhooks with cert-manager certificates - \u2705 Service accounts and RBAC</p> <p>Verify everything is running:</p> <pre><code># Check operator\nkubectl get pods -n keycloak-system -l app.kubernetes.io/name=keycloak-operator\n\n# Check Keycloak instance\nkubectl get keycloak -n keycloak-system\n\n# Check PostgreSQL cluster\nkubectl get cluster -n keycloak-system\n\n# Expected output:\n# NAME       PHASE   AGE\n# keycloak   Ready   2m\n</code></pre> <p>Using External Database:</p> <p>If you have an existing PostgreSQL database:</p> <pre><code>helm install keycloak-operator oci://ghcr.io/vriesdemichael/charts/keycloak-operator \\\n  --namespace keycloak-system \\\n  --set namespace.create=false \\\n  --set keycloak.enabled=true \\\n  --set keycloak.database.host=postgresql.database.svc \\\n  --set keycloak.database.port=5432 \\\n  --set keycloak.database.database=keycloak \\\n  --set keycloak.database.username=keycloak \\\n  --set keycloak.database.passwordSecret.name=db-password \\\n  --set keycloak.database.passwordSecret.key=password\n</code></pre>"},{"location":"quickstart/#step-3-create-application-realm","title":"Step 3: Create Application Realm","text":"<p>Create a realm for your application using the realm Helm chart:</p> <pre><code># Create namespace for your app\nkubectl create namespace my-app\n\n# Install realm chart\nhelm install my-app-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace my-app \\\n  --set realmName=my-app \\\n  --set displayName=\"My Application\" \\\n  --set operatorRef.namespace=keycloak-system \\\n  --set 'clientAuthorizationGrants={my-app}'\n</code></pre> <p>Wait for the realm to become ready:</p> <pre><code>kubectl wait --for=condition=Ready keycloakrealm/my-app-realm \\\n  -n my-app \\\n  --timeout=2m\n\n# Check status\nkubectl get keycloakrealm -n my-app\n# Expected output:\n# NAME            PHASE   AGE\n# my-app-realm    Ready   45s\n</code></pre>"},{"location":"quickstart/#step-4-create-oauth2oidc-client","title":"Step 4: Create OAuth2/OIDC Client","text":"<p>Create an OAuth2/OIDC client for your application:</p> <pre><code>helm install my-app-client oci://ghcr.io/vriesdemichael/charts/keycloak-client \\\n  --namespace my-app \\\n  --set clientId=my-app \\\n  --set name=\"My Application\" \\\n  --set realmRef.name=my-app-realm \\\n  --set realmRef.namespace=my-app \\\n  --set publicClient=false \\\n  --set standardFlowEnabled=true \\\n  --set directAccessGrantsEnabled=true \\\n  --set 'redirectUris={https://my-app.example.com/callback,http://localhost:3000/callback}' \\\n  --set 'webOrigins={https://my-app.example.com,http://localhost:3000}'\n</code></pre> <p>Wait for the client to become ready:</p> <pre><code>kubectl wait --for=condition=Ready keycloakclient/my-app-client \\\n  -n my-app \\\n  --timeout=2m\n\n# Check status\nkubectl get keycloakclient -n my-app\n# Expected output:\n# NAME             PHASE   AGE\n# my-app-client    Ready   30s\n</code></pre>"},{"location":"quickstart/#step-5-retrieve-client-credentials","title":"Step 5: Retrieve Client Credentials","text":"<p>The operator automatically creates a Kubernetes secret with OAuth2 credentials:</p> <pre><code># View all credentials\nkubectl get secret my-app-client-credentials -n my-app -o yaml\n\n# Extract specific values\nCLIENT_ID=$(kubectl get secret my-app-client-credentials -n my-app \\\n  -o jsonpath='{.data.client_id}' | base64 -d)\n\nCLIENT_SECRET=$(kubectl get secret my-app-client-credentials -n my-app \\\n  -o jsonpath='{.data.client_secret}' | base64 -d)\n\nISSUER_URL=$(kubectl get secret my-app-client-credentials -n my-app \\\n  -o jsonpath='{.data.issuer_url}' | base64 -d)\n\necho \"Client ID: $CLIENT_ID\"\necho \"Client Secret: $CLIENT_SECRET\"\necho \"Issuer URL: $ISSUER_URL\"\n</code></pre> <p>Create an environment file for your application:</p> <pre><code>kubectl get secret my-app-client-credentials -n my-app -o json | \\\n  jq -r '.data | to_entries[] | \"\\(.key | ascii_upcase)=\\(.value | @base64d)\"' &gt; .env\n\ncat .env\n</code></pre>"},{"location":"quickstart/#step-6-integrate-with-your-application","title":"Step 6: Integrate with Your Application","text":""},{"location":"quickstart/#example-nodejs","title":"Example: Node.js","text":"<pre><code>const { Issuer } = require('openid-client');\n\nconst issuer = await Issuer.discover(process.env.ISSUER_URL);\nconst client = new issuer.Client({\n  client_id: process.env.CLIENT_ID,\n  client_secret: process.env.CLIENT_SECRET,\n  redirect_uris: ['http://localhost:3000/callback'],\n  response_types: ['code'],\n});\n</code></pre>"},{"location":"quickstart/#example-python","title":"Example: Python","text":"<pre><code>from authlib.integrations.flask_client import OAuth\n\noauth = OAuth(app)\noauth.register(\n    name='keycloak',\n    client_id=os.getenv('CLIENT_ID'),\n    client_secret=os.getenv('CLIENT_SECRET'),\n    server_metadata_url=os.getenv('ISSUER_URL') + '/.well-known/openid-configuration',\n    client_kwargs={'scope': 'openid profile email'}\n)\n</code></pre>"},{"location":"quickstart/#example-spring-boot","title":"Example: Spring Boot","text":"<pre><code>spring:\n  security:\n    oauth2:\n      client:\n        registration:\n          keycloak:\n            client-id: ${CLIENT_ID}\n            client-secret: ${CLIENT_SECRET}\n            scope: openid,profile,email\n        provider:\n          keycloak:\n            issuer-uri: ${ISSUER_URL}\n</code></pre>"},{"location":"quickstart/#verify-installation","title":"Verify Installation","text":"<p>Check that all components are healthy:</p> <pre><code># Operator\nkubectl get pods -n keycloak-system -l app.kubernetes.io/name=keycloak-operator\n\n# Keycloak instance\nkubectl get keycloak -n keycloak-system\n\n# PostgreSQL\nkubectl get cluster -n keycloak-system\n\n# Realm\nkubectl get keycloakrealm -n my-app\n\n# Client\nkubectl get keycloakclient -n my-app\n</code></pre> <p>All resources should show <code>PHASE=Ready</code>.</p>"},{"location":"quickstart/#clean-up","title":"Clean Up","text":"<pre><code># Delete application resources\nhelm uninstall my-app-client -n my-app\nhelm uninstall my-app-realm -n my-app\nkubectl delete namespace my-app\n\n# Delete operator and Keycloak\nhelm uninstall keycloak-operator -n keycloak-system\n\n# Delete database (optional - will delete all data!)\nhelm uninstall cnpg -n cnpg-system\n</code></pre>"},{"location":"quickstart/#advanced-using-with-argocd","title":"Advanced: Using with ArgoCD","text":"<p>Structure your GitOps repository:</p> <pre><code>apps/\n\u251c\u2500\u2500 database/\n\u2502   \u2514\u2500\u2500 cloudnative-pg.yaml        # wave: 0\n\u251c\u2500\u2500 keycloak-operator/\n\u2502   \u2514\u2500\u2500 operator-with-instance.yaml # wave: 1\n\u2514\u2500\u2500 my-app/\n    \u251c\u2500\u2500 realm.yaml                  # wave: 2\n    \u2514\u2500\u2500 client.yaml                 # wave: 3\n</code></pre> <p>Example ArgoCD Application:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: keycloak-operator\n  annotations:\n    argocd.argoproj.io/sync-wave: \"1\"\nspec:\n  project: default\n  source:\n    repoURL: ghcr.io/vriesdemichael/charts\n    chart: keycloak-operator\n    targetRevision: 0.3.x\n    helm:\n      values: |\n        keycloak:\n          enabled: true\n          database:\n            cnpg:\n              enabled: true\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: keycloak-system\n  syncPolicy:\n    automated:\n      prune: true\n      selfHeal: true\n    syncOptions:\n      - CreateNamespace=true\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Configuration: - SMTP Configuration - Email notifications - Identity Providers - Google, GitHub, Azure AD SSO - High Availability - Production HA setup</p> <p>Understanding the System: - Architecture - How the operator works - Security Model - Authorization and RBAC - Drift Detection - Orphan detection</p> <p>CRD References: - KeycloakRealm - All realm options - KeycloakClient - All client options</p>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"quickstart/#operator-not-starting","title":"Operator not starting","text":"<pre><code>kubectl logs -n keycloak-system -l app.kubernetes.io/name=keycloak-operator\nkubectl describe clusterrolebinding keycloak-operator\nkubectl get certificate -n keycloak-system\n</code></pre>"},{"location":"quickstart/#keycloak-stuck-in-pending","title":"Keycloak stuck in Pending","text":"<pre><code>kubectl describe keycloak keycloak -n keycloak-system\nkubectl get cluster -n keycloak-system  # Check PostgreSQL\nkubectl get events -n keycloak-system --sort-by='.lastTimestamp'\n</code></pre>"},{"location":"quickstart/#realm-creation-fails","title":"Realm creation fails","text":"<pre><code>kubectl describe keycloakrealm my-app-realm -n my-app\nkubectl get keycloakrealm my-app-realm -n my-app -o jsonpath='{.status.conditions}' | jq\nkubectl logs -n keycloak-system -l app.kubernetes.io/name=keycloak-operator | grep my-app-realm\n</code></pre>"},{"location":"quickstart/#client-authorization-error","title":"Client authorization error","text":"<p>Symptom: Client shows \"namespace not authorized\"</p> <pre><code># Check realm's authorization grants\nkubectl get keycloakrealm my-app-realm -n my-app \\\n  -o jsonpath='{.spec.clientAuthorizationGrants}' | jq\n\n# Add your namespace to the grant list\nhelm upgrade my-app-realm oci://ghcr.io/vriesdemichael/charts/keycloak-realm \\\n  --namespace my-app \\\n  --reuse-values \\\n  --set 'clientAuthorizationGrants={my-app,my-new-namespace}'\n</code></pre>"},{"location":"quickstart/#webhook-timeout-during-fresh-install","title":"Webhook timeout during fresh install","text":"<p>Symptom: <code>Error: failed calling webhook: context deadline exceeded</code></p> <p>This is expected behavior on fresh install - the webhook configuration is created before operator pods are ready.</p> <p>Solutions: 1. Wait and retry - The operator will be ready shortly, retry your operation 2. Use fail-open during install - Set <code>--set webhooks.failurePolicy=Ignore</code> during initial install, then upgrade to <code>Fail</code> after operator is running 3. Remove --wait flag - Let helm complete without waiting for all resources</p> <pre><code># Option 2: Fail-open install, then upgrade to fail-closed\nhelm install keycloak-operator oci://ghcr.io/vriesdemichael/charts/keycloak-operator \\\n  --namespace keycloak-system \\\n  --set webhooks.failurePolicy=Ignore\n\n# Wait for operator to be ready\nkubectl wait --for=condition=ready pod -l app.kubernetes.io/name=keycloak-operator \\\n  -n keycloak-system --timeout=120s\n\n# Upgrade to fail-closed\nhelm upgrade keycloak-operator oci://ghcr.io/vriesdemichael/charts/keycloak-operator \\\n  --namespace keycloak-system \\\n  --set webhooks.failurePolicy=Fail\n</code></pre>"},{"location":"quickstart/#support","title":"Support","text":"<ul> <li>\ud83d\udcda Full Documentation</li> <li>\ud83d\udc1b Report Issues</li> <li>\ud83d\udcac Discussions</li> </ul>"},{"location":"reference/keycloak-client-crd/","title":"KeycloakClient CRD Reference","text":"<p>Complete reference for the <code>KeycloakClient</code> Custom Resource Definition.</p>"},{"location":"reference/keycloak-client-crd/#overview","title":"Overview","text":"<p>The <code>KeycloakClient</code> CRD defines a Keycloak client - an OAuth2/OIDC application that uses Keycloak for authentication and authorization. Clients can be web applications, mobile apps, APIs, or service-to-service integrations.</p> <p>API Version: <code>vriesdemichael.github.io/v1</code> Kind: <code>KeycloakClient</code> Plural: <code>keycloakclients</code> Singular: <code>keycloakclient</code> Short Names: <code>kcc</code></p>"},{"location":"reference/keycloak-client-crd/#minimal-example","title":"Minimal Example","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: my-app\n  namespace: my-team\nspec:\n  clientId: my-app\n  realmRef:\n    name: my-realm\n    namespace: my-team\n</code></pre>"},{"location":"reference/keycloak-client-crd/#spec-fields","title":"Spec Fields","text":""},{"location":"reference/keycloak-client-crd/#core-configuration","title":"Core Configuration","text":"Field Type Required Default Description <code>clientId</code> <code>string</code> Yes - Unique client identifier (1-255 characters) <code>clientName</code> <code>string</code> No - Human-readable client name <code>description</code> <code>string</code> No - Client description <p>Example: <pre><code>spec:\n  clientId: webapp-production\n  clientName: \"Production Web Application\"\n  description: \"Customer-facing web application\"\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#realm-reference-required","title":"Realm Reference (Required)","text":"<p>Reference to the parent KeycloakRealm and authorization token.</p> Field Type Required Default Description <code>realmRef.name</code> <code>string</code> Yes - Name of the KeycloakRealm CR <code>realmRef.namespace</code> <code>string</code> Yes - Namespace of the KeycloakRealm CR <p>Example: <pre><code>spec:\n  realmRef:\n    name: production-realm\n    namespace: production\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#client-type-configuration","title":"Client Type Configuration","text":"<p>Configure the basic client type and protocol.</p> Field Type Required Default Description <code>publicClient</code> boolean No <code>false</code> Whether this is a public client (no client secret). Use <code>true</code> for SPAs and mobile apps. <code>bearerOnly</code> boolean No <code>false</code> Bearer-only client (for APIs that only verify tokens, don't initiate login) <code>protocol</code> <code>string</code> No <code>openid-connect</code> Client protocol. Options: <code>openid-connect</code>, <code>saml</code>, <code>docker-v2</code> <p>Client Types:</p> <ul> <li>Confidential Client (<code>publicClient: false</code>): Server-side applications that can securely store client secrets (traditional web apps, backend services)</li> <li>Public Client (<code>publicClient: true</code>): Applications that cannot securely store secrets (SPAs, mobile apps, CLIs)</li> <li>Bearer-Only (<code>bearerOnly: true</code>): APIs that only validate tokens, don't initiate login flows</li> </ul> <p>Example - Confidential: <pre><code>spec:\n  publicClient: false  # Server-side web app\n</code></pre></p> <p>Example - Public: <pre><code>spec:\n  publicClient: true  # Single Page Application\n</code></pre></p> <p>Example - Bearer-Only: <pre><code>spec:\n  bearerOnly: true  # Resource server / API\n  publicClient: false\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#oauth2oidc-configuration","title":"OAuth2/OIDC Configuration","text":"<p>Configure redirect URIs and web origins for OAuth2/OIDC flows.</p> Field Type Required Default Description <code>redirectUris</code> []<code>string</code> No <code>[]</code> Valid redirect URIs (callback URLs). Use <code>*</code> for local development only. <code>webOrigins</code> []<code>string</code> No <code>[]</code> Valid web origins for CORS. Use <code>*</code> for local development only. <code>postLogoutRedirectUris</code> []<code>string</code> No <code>[]</code> Valid post-logout redirect URIs <p>Example - Web Application: <pre><code>spec:\n  redirectUris:\n    - \"https://app.example.com/callback\"\n    - \"https://app.example.com/silent-renew\"\n  webOrigins:\n    - \"https://app.example.com\"\n  postLogoutRedirectUris:\n    - \"https://app.example.com\"\n</code></pre></p> <p>Example - Development (\u26a0\ufe0f Do not use in production): <pre><code>spec:\n  redirectUris:\n    - \"http://localhost:3000/*\"\n  webOrigins:\n    - \"*\"  # Allow all origins\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#client-settings","title":"Client Settings","text":"<p>Advanced client configuration options.</p>"},{"location":"reference/keycloak-client-crd/#basic-settings","title":"Basic Settings","text":"Field Type Required Default Description <code>settings.enabled</code> boolean No <code>true</code> Enable/disable the client <code>settings.alwaysDisplayInConsole</code> boolean No <code>false</code> Always display in admin console <code>settings.clientAuthenticatorType</code> <code>string</code> No <code>client-secret</code> Client authentication type. Options: <code>client-secret</code>, <code>client-jwt</code>, <code>client-secret-jwt</code>, <code>client-x509</code>"},{"location":"reference/keycloak-client-crd/#oauth2-flow-configuration","title":"OAuth2 Flow Configuration","text":"Field Type Required Default Description <code>settings.standardFlowEnabled</code> boolean No <code>true</code> Enable standard flow (authorization code flow) - recommended for web apps <code>settings.implicitFlowEnabled</code> boolean No <code>false</code> Enable implicit flow (deprecated, use PKCE instead) <code>settings.directAccessGrantsEnabled</code> boolean No <code>true</code> Enable direct access grants (resource owner password credentials flow) <code>settings.serviceAccountsEnabled</code> boolean No <code>false</code> Enable service accounts (client credentials flow) for M2M <p>OAuth2 Flow Guide:</p> <ul> <li>Authorization Code Flow (<code>standardFlowEnabled: true</code>): Best for traditional web apps with backend</li> <li>Authorization Code + PKCE (<code>standardFlowEnabled: true</code>, <code>publicClient: true</code>): Best for SPAs and mobile apps</li> <li>Client Credentials (<code>serviceAccountsEnabled: true</code>): Best for machine-to-machine (service accounts)</li> <li>Resource Owner Password (<code>directAccessGrantsEnabled: true</code>): Only use when other flows are not possible</li> </ul> <p>Example - Web App: <pre><code>spec:\n  publicClient: false\n  settings:\n    standardFlowEnabled: true\n    implicitFlowEnabled: false\n    directAccessGrantsEnabled: false\n    serviceAccountsEnabled: false\n</code></pre></p> <p>Example - SPA with PKCE: <pre><code>spec:\n  publicClient: true\n  settings:\n    standardFlowEnabled: true\n    implicitFlowEnabled: false\n    directAccessGrantsEnabled: false\n</code></pre></p> <p>Example - Service Account (M2M): <pre><code>spec:\n  publicClient: false\n  settings:\n    standardFlowEnabled: false\n    directAccessGrantsEnabled: false\n    serviceAccountsEnabled: true\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#consent-and-token-settings","title":"Consent and Token Settings","text":"Field Type Required Default Description <code>settings.consentRequired</code> boolean No <code>false</code> Require user consent <code>settings.displayOnConsentScreen</code> boolean No <code>true</code> Display on consent screen <code>settings.includeInTokenScope</code> boolean No <code>true</code> Include in token scope <code>settings.accessTokenLifespan</code> integer No - Access token lifespan in seconds (overrides realm default) <code>settings.refreshTokenLifespan</code> integer No - Refresh token lifespan in seconds (overrides realm default) <p>Example: <pre><code>spec:\n  settings:\n    consentRequired: true  # Require user consent\n    accessTokenLifespan: 600  # 10 minutes\n    refreshTokenLifespan: 86400  # 24 hours\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#authentication-flows","title":"Authentication Flows","text":"<p>Override default authentication flows for this client.</p> Field Type Required Default Description <code>authenticationFlows.browserFlow</code> <code>string</code> No - Browser authentication flow override <code>authenticationFlows.directGrantFlow</code> <code>string</code> No - Direct grant authentication flow override <code>authenticationFlows.clientAuthenticationFlow</code> <code>string</code> No - Client authentication flow override <p>Example: <pre><code>spec:\n  authenticationFlows:\n    browserFlow: browser-with-mfa\n    directGrantFlow: direct-grant-with-otp\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#scopes-and-mappers","title":"Scopes and Mappers","text":"<p>Configure client scopes and protocol mappers for claims customization.</p> Field Type Required Default Description <code>defaultClientScopes</code> []<code>string</code> No <code>[]</code> Default client scopes (always included) <code>optionalClientScopes</code> []<code>string</code> No <code>[]</code> Optional client scopes (user can opt-in) <code>protocolMappers</code> []object No <code>[]</code> Protocol mappers for custom claims <code>protocolMappers[].name</code> <code>string</code> Yes - Mapper name <code>protocolMappers[].protocol</code> <code>string</code> No <code>openid-connect</code> Protocol (e.g., <code>openid-connect</code>, <code>saml</code>) <code>protocolMappers[].protocolMapper</code> <code>string</code> Yes - Mapper type <code>protocolMappers[].config</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Mapper configuration <p>Common Protocol Mappers:</p> <ul> <li><code>oidc-usermodel-attribute-mapper</code>: Map user attribute to claim</li> <li><code>oidc-usermodel-property-mapper</code>: Map user property to claim</li> <li><code>oidc-group-membership-mapper</code>: Map group memberships to claim</li> <li><code>oidc-audience-mapper</code>: Add audience to token</li> <li><code>oidc-hardcoded-claim-mapper</code>: Add static claim</li> </ul> <p>Example - User Attribute Mapper: <pre><code>spec:\n  protocolMappers:\n    - name: department-mapper\n      protocol: openid-connect\n      protocolMapper: oidc-usermodel-attribute-mapper\n      config:\n        user.attribute: department\n        claim.name: department\n        jsonType.label: String\n        id.token.claim: \"true\"\n        access.token.claim: \"true\"\n        userinfo.token.claim: \"true\"\n</code></pre></p> <p>Example - Audience Mapper: <pre><code>spec:\n  protocolMappers:\n    - name: api-audience\n      protocol: openid-connect\n      protocolMapper: oidc-audience-mapper\n      config:\n        included.client.audience: api-server\n        access.token.claim: \"true\"\n</code></pre></p> <p>Example - Hardcoded Claim: <pre><code>spec:\n  protocolMappers:\n    - name: environment-claim\n      protocol: openid-connect\n      protocolMapper: oidc-hardcoded-claim-mapper\n      config:\n        claim.name: environment\n        claim.value: production\n        access.token.claim: \"true\"\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#roles-and-permissions","title":"Roles and Permissions","text":"<p>Configure client-specific roles and service account permissions.</p> Field Type Required Default Description <code>clientRoles</code> []<code>string</code> No <code>[]</code> Client-specific roles to create <code>serviceAccountRoles.realmRoles</code> []<code>string</code> No <code>[]</code> Realm roles to assign to service account <code>serviceAccountRoles.clientRoles</code> map<code>string</code><code>string</code> No <code>{}</code> Client roles to assign to service account (by client ID) <p>Example - Client Roles: <pre><code>spec:\n  clientRoles:\n    - admin\n    - editor\n    - viewer\n</code></pre></p> <p>Example - Service Account with Permissions: <pre><code>spec:\n  settings:\n    serviceAccountsEnabled: true\n  serviceAccountRoles:\n    realmRoles:\n      - offline_access\n      - uma_authorization\n    clientRoles:\n      api-server:\n        - read:data\n        - write:data\n      admin-console:\n        - view-users\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#advanced-configuration","title":"Advanced Configuration","text":"Field Type Required Default Description <code>attributes</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Additional client attributes <p>Example: <pre><code>spec:\n  attributes:\n    pkce.code.challenge.method: S256  # Require PKCE with SHA-256\n    post.logout.redirect.uris: \"+\"  # Allow any registered redirect URI\n</code></pre></p>"},{"location":"reference/keycloak-client-crd/#secret-management","title":"Secret Management","text":"<p>Configure how client credentials are managed.</p> Field Type Required Default Description <code>regenerateSecret</code> boolean No <code>false</code> Regenerate client secret on update <code>secretName</code> <code>string</code> No <code>&lt;client-name&gt;-client-secret</code> Name of Kubernetes secret for client credentials <code>manageSecret</code> boolean No <code>true</code> Create and manage Kubernetes secret for credentials <code>secretMetadata.labels</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Labels to add to the managed secret <code>secretMetadata.annotations</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Annotations to add to the managed secret <p>Automatic Features: - Recreation: If the managed secret is deleted, the operator automatically recreates it. - Garbage Collection: Secrets have an <code>OwnerReference</code> to the Client CR, ensuring they are deleted when the client is deleted.</p> <p>Example: <pre><code>spec:\n  manageSecret: true\n  secretName: webapp-credentials\n  regenerateSecret: false  # Only regenerate manually\n  secretMetadata:\n    labels:\n      app: webapp\n    annotations:\n      description: \"Credentials for webapp\"\n</code></pre></p> <p>The operator creates a secret with the following keys: - <code>client-id</code>: Client ID - <code>client-secret</code>: Client secret (confidential clients only) - <code>issuer</code>: OIDC issuer URL - <code>token-endpoint</code>: Token endpoint URL - <code>auth-endpoint</code>: Authorization endpoint URL</p>"},{"location":"reference/keycloak-client-crd/#status-fields","title":"Status Fields","text":"Field Type Description <code>phase</code> <code>string</code> Current phase: <code>Pending</code>, <code>Provisioning</code>, <code>Ready</code>, <code>Failed</code>, <code>Updating</code>, <code>Degraded</code> <code>message</code> <code>string</code> Human-readable status message <code>reason</code> <code>string</code> Reason for current phase <code>observedGeneration</code> integer Generation of spec that was last processed <code>clientId</code> <code>string</code> Client ID in Keycloak <code>internalId</code> <code>string</code> Internal Keycloak client ID (UUID) <code>realm</code> <code>string</code> Realm name <code>publicClient</code> boolean Whether this is a public client <code>keycloakInstance</code> <code>string</code> Keycloak instance managing this client <code>credentialsSecret</code> <code>string</code> Name of secret containing client credentials <code>endpoints.auth</code> <code>string</code> OIDC authorization endpoint <code>endpoints.token</code> <code>string</code> OIDC token endpoint <code>endpoints.userinfo</code> <code>string</code> OIDC userinfo endpoint <code>endpoints.jwks</code> <code>string</code> OIDC JWKS endpoint <code>endpoints.issuer</code> <code>string</code> OIDC issuer <code>endpoints.endSession</code> <code>string</code> OIDC end session endpoint <code>createdRoles</code> []<code>string</code> List of created client roles <code>appliedMappers</code> []<code>string</code> List of applied protocol mappers <code>lastHealthCheck</code> <code>string</code> (datetime) Last health check timestamp <code>lastUpdated</code> <code>string</code> (datetime) Last update timestamp"},{"location":"reference/keycloak-client-crd/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/keycloak-client-crd/#web-application-confidential","title":"Web Application (Confidential)","text":"<p>Traditional server-side web application with backend.</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: webapp\n  namespace: production\nspec:\n  clientId: webapp-production\n  clientName: \"Production Web App\"\n\n  realmRef:\n    name: production-realm\n    namespace: production\n\n  publicClient: false  # Confidential client\n\n  redirectUris:\n    - \"https://app.example.com/callback\"\n    - \"https://app.example.com/silent-renew\"\n  webOrigins:\n    - \"https://app.example.com\"\n  postLogoutRedirectUris:\n    - \"https://app.example.com\"\n\n  settings:\n    standardFlowEnabled: true  # Authorization code flow\n    implicitFlowEnabled: false\n    directAccessGrantsEnabled: false\n    serviceAccountsEnabled: false\n    consentRequired: false\n\n  defaultClientScopes:\n    - profile\n    - email\n    - roles\n</code></pre>"},{"location":"reference/keycloak-client-crd/#single-page-application-public-with-pkce","title":"Single Page Application (Public with PKCE)","text":"<p>Modern SPA using authorization code flow with PKCE.</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: spa\n  namespace: production\nspec:\n  clientId: spa-production\n\n  realmRef:\n    name: production-realm\n    namespace: production\n\n  publicClient: true  # Public client (no secret)\n\n  redirectUris:\n    - \"https://app.example.com/callback\"\n    - \"https://app.example.com/silent-renew.html\"\n  webOrigins:\n    - \"https://app.example.com\"\n\n  settings:\n    standardFlowEnabled: true  # Auth code + PKCE\n    implicitFlowEnabled: false\n    directAccessGrantsEnabled: false\n\n  attributes:\n    pkce.code.challenge.method: S256  # Require PKCE with SHA-256\n</code></pre>"},{"location":"reference/keycloak-client-crd/#mobile-application-public-with-pkce","title":"Mobile Application (Public with PKCE)","text":"<p>Mobile app using custom URI schemes.</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: mobile-app\n  namespace: production\nspec:\n  clientId: mobile-app\n\n  realmRef:\n    name: production-realm\n    namespace: production\n\n  publicClient: true\n\n  redirectUris:\n    - \"myapp://callback\"  # Custom URI scheme\n    - \"com.example.myapp://callback\"  # Reverse domain notation\n\n  settings:\n    standardFlowEnabled: true  # Auth code + PKCE\n    implicitFlowEnabled: false\n    directAccessGrantsEnabled: false\n\n  attributes:\n    pkce.code.challenge.method: S256\n</code></pre>"},{"location":"reference/keycloak-client-crd/#api-resource-server-bearer-only","title":"API / Resource Server (Bearer-Only)","text":"<p>Backend API that only validates tokens.</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: api-server\n  namespace: production\nspec:\n  clientId: api-server\n\n  realmRef:\n    name: production-realm\n    namespace: production\n\n  bearerOnly: true  # Only validates tokens, doesn't initiate login\n  publicClient: false\n</code></pre>"},{"location":"reference/keycloak-client-crd/#service-account-machine-to-machine","title":"Service Account (Machine-to-Machine)","text":"<p>Backend service using client credentials flow.</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: backend-service\n  namespace: production\nspec:\n  clientId: backend-service\n\n  realmRef:\n    name: production-realm\n    namespace: production\n\n  publicClient: false\n\n  settings:\n    standardFlowEnabled: false  # No interactive flows\n    directAccessGrantsEnabled: false\n    serviceAccountsEnabled: true  # Client credentials flow\n\n  serviceAccountRoles:\n    realmRoles:\n      - offline_access\n    clientRoles:\n      api-server:\n        - read:data\n        - write:data\n</code></pre>"},{"location":"reference/keycloak-client-crd/#client-with-custom-claims","title":"Client with Custom Claims","text":"<p>Client with custom protocol mappers for additional claims.</p> <pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakClient\nmetadata:\n  name: webapp-with-claims\n  namespace: production\nspec:\n  clientId: webapp\n\n  realmRef:\n    name: production-realm\n    namespace: production\n\n  redirectUris:\n    - \"https://app.example.com/callback\"\n\n  protocolMappers:\n    # Map user department to claim\n    - name: department\n      protocolMapper: oidc-usermodel-attribute-mapper\n      config:\n        user.attribute: department\n        claim.name: department\n        jsonType.label: String\n        id.token.claim: \"true\"\n        access.token.claim: \"true\"\n        userinfo.token.claim: \"true\"\n\n    # Map groups to claim\n    - name: groups\n      protocolMapper: oidc-group-membership-mapper\n      config:\n        claim.name: groups\n        full.path: \"false\"\n        id.token.claim: \"true\"\n        access.token.claim: \"true\"\n        userinfo.token.claim: \"true\"\n\n    # Add static environment claim\n    - name: environment\n      protocolMapper: oidc-hardcoded-claim-mapper\n      config:\n        claim.name: env\n        claim.value: production\n        access.token.claim: \"true\"\n\n    # Add audience\n    - name: api-audience\n      protocolMapper: oidc-audience-mapper\n      config:\n        included.client.audience: api-server\n        access.token.claim: \"true\"\n</code></pre>"},{"location":"reference/keycloak-client-crd/#retrieving-client-credentials","title":"Retrieving Client Credentials","text":"<p>For confidential clients, credentials are stored in a Kubernetes secret:</p> <pre><code># Get client secret\nkubectl get secret webapp-client-secret \\\n  -n production \\\n  -o jsonpath='{.data.client-secret}' | base64 -d\n\n# Get all credentials\nkubectl get secret webapp-client-secret \\\n  -n production \\\n  -o json | jq '.data | map_values(@base64d)'\n</code></pre>"},{"location":"reference/keycloak-client-crd/#see-also","title":"See Also","text":"<p>Related CRD References:</p> <ul> <li>Keycloak CRD Reference - Configure Keycloak instances</li> <li>KeycloakRealm CRD Reference - Configure realms</li> </ul> <p>Configuration Guides:</p> <ul> <li>End-to-End Setup - Complete client configuration with OAuth2 testing</li> <li>Quick Start Guide - Create your first client</li> </ul> <p>Examples:</p> <ul> <li>Client Examples - Production-ready client configurations</li> <li>Web Applications - Authorization Code Flow with PKCE</li> <li>Single Page Applications - Implicit/Authorization Code Flow</li> <li>Service Accounts - Client Credentials Flow</li> <li>Mobile Apps - Authorization Code Flow with PKCE</li> </ul> <p>Architecture &amp; Operations:</p> <ul> <li>Architecture - How client reconciliation works</li> <li>Security Model - How clients authenticate</li> <li>Troubleshooting: Client Issues - Common client problems</li> </ul>"},{"location":"reference/keycloak-crd/","title":"Keycloak CRD Reference","text":"<p>Complete reference for the <code>Keycloak</code> Custom Resource Definition.</p>"},{"location":"reference/keycloak-crd/#overview","title":"Overview","text":"<p>The <code>Keycloak</code> CRD defines a Keycloak instance - an identity and access management server. This resource allows you to declaratively manage Keycloak deployments with database connections, TLS configuration, ingress settings, and more.</p> <p>API Version: <code>vriesdemichael.github.io/v1</code> Kind: <code>Keycloak</code> Plural: <code>keycloaks</code> Singular: <code>keycloak</code> Short Names: <code>kc</code></p>"},{"location":"reference/keycloak-crd/#minimal-example","title":"Minimal Example","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/Keycloak.json\napiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: my-keycloak\n  namespace: keycloak-system\nspec:\n  database:\n    type: postgresql\n    host: postgres-postgresql\n    database: keycloak\n    username: keycloak\n    passwordSecret:\n      name: postgres-password\n      key: password\n</code></pre>"},{"location":"reference/keycloak-crd/#spec-fields","title":"Spec Fields","text":""},{"location":"reference/keycloak-crd/#core-configuration","title":"Core Configuration","text":"Field Type Required Default Description <code>image</code> string No Uses operator default Container image for Keycloak (e.g., <code>quay.io/keycloak/keycloak:26.4.1</code>) <code>replicas</code> integer No <code>1</code> Number of Keycloak replicas (minimum: 1) <p>Example: <pre><code>spec:\n  image: quay.io/keycloak/keycloak:26.4.1\n  replicas: 3\n</code></pre></p>"},{"location":"reference/keycloak-crd/#database-configuration","title":"Database Configuration","text":"<p>The database configuration is required. The operator supports PostgreSQL, MySQL, MariaDB, Oracle, and Microsoft SQL Server.</p>"},{"location":"reference/keycloak-crd/#basic-fields","title":"Basic Fields","text":"Field Type Required Default Description <code>database.type</code> string Yes <code>postgresql</code> Database type. Options: <code>postgresql</code>, <code>mysql</code>, <code>mariadb</code>, <code>oracle</code>, <code>mssql</code> <code>database.host</code> string Yes - Database hostname or IP address <code>database.port</code> integer No Auto-detected Database port (1-65535). Auto-detected based on database type if not specified <code>database.database</code> string Yes - Database name <code>database.username</code> string No* - Database username (*required if not using <code>credentialsSecret</code>) <code>database.passwordSecret</code> object No* - Secret reference for database password (*required if using <code>username</code>) <code>database.passwordSecret.name</code> string Yes - Name of the secret containing the password <code>database.passwordSecret.key</code> string No <code>password</code> Key in the secret <code>database.credentialsSecret</code> string No - Alternative: Kubernetes secret name with complete database credentials <code>database.connectionParams</code> map[string]string No <code>{}</code> Additional database connection parameters <p>Example - PostgreSQL with username/password: <pre><code>spec:\n  database:\n    type: postgresql\n    host: postgres-postgresql.default.svc.cluster.local\n    port: 5432\n    database: keycloak\n    username: keycloak\n    passwordSecret:\n      name: postgres-password\n      key: password\n</code></pre></p> <p>Example - CloudNativePG: <pre><code>spec:\n  database:\n    type: postgresql\n    host: keycloak-postgres-rw  # CNPG read-write service\n    database: keycloak\n    username: keycloak\n    passwordSecret:\n      name: keycloak-postgres-app\n      key: password\n</code></pre></p> <p>Example - Using credentialsSecret: <pre><code>spec:\n  database:\n    type: postgresql\n    host: postgres-postgresql\n    database: keycloak\n    credentialsSecret: db-credentials  # Secret with keys: username, password\n</code></pre></p>"},{"location":"reference/keycloak-crd/#connection-pool","title":"Connection Pool","text":"Field Type Required Default Description <code>database.connectionPool.maxConnections</code> integer No <code>20</code> Maximum number of database connections <code>database.connectionPool.minConnections</code> integer No <code>5</code> Minimum number of database connections <code>database.connectionPool.connectionTimeout</code> string No <code>30s</code> Connection timeout duration <p>Example: <pre><code>spec:\n  database:\n    # ... other fields ...\n    connectionPool:\n      maxConnections: 50\n      minConnections: 10\n      connectionTimeout: \"60s\"\n</code></pre></p>"},{"location":"reference/keycloak-crd/#ssltls","title":"SSL/TLS","text":"Field Type Required Default Description <code>database.sslMode</code> string No <code>require</code> SSL mode for database connections. Options: <code>disable</code>, <code>allow</code>, <code>prefer</code>, <code>require</code>, <code>verify-ca</code>, <code>verify-full</code> <p>Example: <pre><code>spec:\n  database:\n    # ... other fields ...\n    sslMode: verify-full  # Strict SSL with certificate verification\n</code></pre></p>"},{"location":"reference/keycloak-crd/#migration","title":"Migration","text":"Field Type Required Default Description <code>database.migrationStrategy</code> string No <code>auto</code> Database migration strategy. Options: <code>auto</code> (automatic), <code>manual</code> (skip migrations), <code>skip</code> <p>Example: <pre><code>spec:\n  database:\n    # ... other fields ...\n    migrationStrategy: auto  # Automatically run schema migrations\n</code></pre></p>"},{"location":"reference/keycloak-crd/#tls-configuration","title":"TLS Configuration","text":"<p>Configure TLS/SSL termination for Keycloak.</p> Field Type Required Default Description <code>tls.enabled</code> boolean No <code>false</code> Enable TLS/SSL <code>tls.secretName</code> string No - Secret containing TLS certificate (keys: <code>tls.crt</code>, <code>tls.key</code>) <code>tls.hostname</code> string No - Hostname for TLS certificate (Server Name Indication) <p>Example: <pre><code>spec:\n  tls:\n    enabled: true\n    secretName: keycloak-tls\n    hostname: keycloak.example.com\n</code></pre></p>"},{"location":"reference/keycloak-crd/#service-configuration","title":"Service Configuration","text":"<p>Configure the Kubernetes service for Keycloak.</p> Field Type Required Default Description <code>service.type</code> string No <code>ClusterIP</code> Service type. Options: <code>ClusterIP</code>, <code>NodePort</code>, <code>LoadBalancer</code> <code>service.httpPort</code> integer No <code>8080</code> HTTP port (1-65535) <code>service.httpsPort</code> integer No <code>8443</code> HTTPS port (1-65535) <code>service.annotations</code> map[string]string No <code>{}</code> Service annotations (e.g., for cloud load balancers) <p>Example: <pre><code>spec:\n  service:\n    type: LoadBalancer\n    httpPort: 8080\n    httpsPort: 8443\n    annotations:\n      service.beta.kubernetes.io/aws-load-balancer-type: \"nlb\"\n</code></pre></p>"},{"location":"reference/keycloak-crd/#ingress-configuration","title":"Ingress Configuration","text":"<p>Configure ingress for external access to Keycloak.</p> Field Type Required Default Description <code>ingress.enabled</code> boolean No <code>false</code> Enable ingress <code>ingress.host</code> string No - Ingress hostname (e.g., <code>keycloak.example.com</code>) <code>ingress.path</code> string No <code>/</code> Ingress path <code>ingress.tlsEnabled</code> boolean No <code>true</code> Enable TLS for ingress <code>ingress.tlsSecretName</code> string No - Secret name for ingress TLS certificate <code>ingress.className</code> string No - Ingress class name (e.g., <code>nginx</code>, <code>traefik</code>) <code>ingress.annotations</code> map[string]string No <code>{}</code> Ingress annotations <p>Example: <pre><code>spec:\n  ingress:\n    enabled: true\n    host: keycloak.example.com\n    path: /\n    tlsEnabled: true\n    tlsSecretName: keycloak-ingress-tls\n    className: nginx\n    annotations:\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n      nginx.ingress.kubernetes.io/proxy-buffer-size: \"128k\"\n</code></pre></p>"},{"location":"reference/keycloak-crd/#resource-requirements","title":"Resource Requirements","text":"<p>Configure CPU and memory limits for Keycloak pods.</p> Field Type Required Default Description <code>resources.requests</code> map[string]string No - Resource requests (e.g., <code>cpu: \"500m\"</code>, <code>memory: \"1Gi\"</code>) <code>resources.limits</code> map[string]string No - Resource limits <p>Example: <pre><code>spec:\n  resources:\n    requests:\n      cpu: \"1000m\"\n      memory: \"2Gi\"\n    limits:\n      cpu: \"2000m\"\n      memory: \"4Gi\"\n</code></pre></p>"},{"location":"reference/keycloak-crd/#environment-variables","title":"Environment Variables","text":"<p>Inject custom environment variables into Keycloak containers.</p> Field Type Required Default Description <code>env</code> map[string]string No <code>{}</code> Environment variables as key-value pairs <p>Example: <pre><code>spec:\n  env:\n    KC_LOG_LEVEL: \"INFO\"\n    KC_FEATURES: \"token-exchange,admin-fine-grained-authz\"\n</code></pre></p> <p>Common Keycloak environment variables: - <code>KC_LOG_LEVEL</code> - Logging level (<code>INFO</code>, <code>DEBUG</code>, <code>WARN</code>, <code>ERROR</code>) - <code>KC_FEATURES</code> - Enable preview features - <code>KC_PROXY</code> - Proxy mode (<code>edge</code>, <code>reencrypt</code>, <code>passthrough</code>) - <code>KC_HTTP_RELATIVE_PATH</code> - Context path for Keycloak</p>"},{"location":"reference/keycloak-crd/#jvm-configuration","title":"JVM Configuration","text":"<p>Configure JVM options for performance tuning.</p> Field Type Required Default Description <code>jvmOptions</code> []string No <code>[]</code> JVM options (e.g., heap size, GC settings) <p>Example: <pre><code>spec:\n  jvmOptions:\n    - \"-Xms2048m\"\n    - \"-Xmx4096m\"\n    - \"-XX:+UseG1GC\"\n    - \"-XX:MaxGCPauseMillis=200\"\n    - \"-XX:+DisableExplicitGC\"\n</code></pre></p> <p>Common JVM options: - <code>-Xms&lt;size&gt;</code> - Initial heap size - <code>-Xmx&lt;size&gt;</code> - Maximum heap size - <code>-XX:+UseG1GC</code> - Use G1 garbage collector (recommended) - <code>-XX:MaxGCPauseMillis=&lt;ms&gt;</code> - Target GC pause time - <code>-Djava.net.preferIPv4Stack=true</code> - Prefer IPv4</p>"},{"location":"reference/keycloak-crd/#service-account","title":"Service Account","text":"<p>Assign a Kubernetes service account for workload identity.</p> Field Type Required Default Description <code>serviceAccount</code> string No - Service account name for Keycloak pods (for GCP Workload Identity, AWS IRSA, etc.) <p>Example: <pre><code>spec:\n  serviceAccount: keycloak-workload-identity\n</code></pre></p>"},{"location":"reference/keycloak-crd/#health-probes","title":"Health Probes","text":"<p>Override default health probe configurations.</p> Field Type Required Default Description <code>startupProbe</code> object No Operator defaults Kubernetes startup probe configuration <code>livenessProbe</code> object No Operator defaults Kubernetes liveness probe configuration <code>readinessProbe</code> object No Operator defaults Kubernetes readiness probe configuration <p>Example: <pre><code>spec:\n  startupProbe:\n    httpGet:\n      path: /health/started\n      port: 9000\n    initialDelaySeconds: 30\n    periodSeconds: 10\n    failureThreshold: 30\n  livenessProbe:\n    httpGet:\n      path: /health/live\n      port: 9000\n    periodSeconds: 30\n  readinessProbe:\n    httpGet:\n      path: /health/ready\n      port: 9000\n    periodSeconds: 10\n</code></pre></p>"},{"location":"reference/keycloak-crd/#security-context","title":"Security Context","text":"<p>Configure pod and container security contexts.</p> Field Type Required Default Description <code>podSecurityContext</code> object No - Pod-level security context (fsGroup, runAsUser, etc.) <code>securityContext</code> object No - Container-level security context (capabilities, privileged, etc.) <p>Example: <pre><code>spec:\n  podSecurityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    fsGroup: 1000\n  securityContext:\n    allowPrivilegeEscalation: false\n    capabilities:\n      drop:\n        - ALL\n    readOnlyRootFilesystem: false\n</code></pre></p>"},{"location":"reference/keycloak-crd/#status-fields","title":"Status Fields","text":"<p>The operator populates the <code>status</code> subresource with the current state of the Keycloak instance.</p> Field Type Description <code>phase</code> string Current phase: <code>Pending</code>, <code>Provisioning</code>, <code>Ready</code>, <code>Failed</code>, <code>Updating</code>, <code>Degraded</code> <code>message</code> string Human-readable status message <code>reason</code> string Reason for current phase <code>observedGeneration</code> integer Generation of spec that was last processed <code>adminUsername</code> string Keycloak admin username <code>adminSecret</code> string Name of secret containing admin password <code>internalUrl</code> string Internal cluster URL <code>externalUrl</code> string External URL (if ingress enabled) <code>endpoints.admin</code> string Admin console endpoint <code>endpoints.public</code> string Public endpoint for OIDC/SAML <code>endpoints.management</code> string Management endpoint (health, metrics) <code>deployment</code> string Name of the Keycloak deployment <code>service</code> string Name of the Keycloak service <code>readyReplicas</code> integer Number of ready replicas <code>lastHealthCheck</code> string (datetime) Last health check timestamp <code>databaseStatus</code> string Database connection status: <code>Connected</code>, <code>Connecting</code>, <code>Failed</code>, <code>Unknown</code> <p>Example status: <pre><code>status:\n  phase: Ready\n  message: \"Keycloak instance is healthy and ready\"\n  observedGeneration: 1\n  adminUsername: admin\n  adminSecret: my-keycloak-admin-password\n  internalUrl: http://my-keycloak:8080\n  externalUrl: https://keycloak.example.com\n  endpoints:\n    admin: https://keycloak.example.com/admin\n    public: https://keycloak.example.com\n    management: http://my-keycloak:9000\n  deployment: my-keycloak\n  service: my-keycloak\n  readyReplicas: 3\n  databaseStatus: Connected\n</code></pre></p>"},{"location":"reference/keycloak-crd/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/keycloak-crd/#production-setup-with-ha","title":"Production Setup with HA","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/Keycloak.json\napiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak-prod\n  namespace: keycloak-system\nspec:\n  image: quay.io/keycloak/keycloak:26.4.1\n  replicas: 3\n\n  database:\n    type: postgresql\n    host: postgres-ha-rw.database.svc.cluster.local\n    port: 5432\n    database: keycloak\n    username: keycloak\n    passwordSecret:\n      name: postgres-password\n      key: password\n    sslMode: verify-full\n    connectionPool:\n      maxConnections: 100\n      minConnections: 20\n      connectionTimeout: \"30s\"\n\n  service:\n    type: ClusterIP\n    httpPort: 8080\n    httpsPort: 8443\n\n  ingress:\n    enabled: true\n    host: auth.example.com\n    tlsEnabled: true\n    tlsSecretName: keycloak-tls\n    className: nginx\n    annotations:\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n      nginx.ingress.kubernetes.io/proxy-buffer-size: \"128k\"\n      nginx.ingress.kubernetes.io/affinity: \"cookie\"\n\n  resources:\n    requests:\n      cpu: \"2000m\"\n      memory: \"4Gi\"\n    limits:\n      cpu: \"4000m\"\n      memory: \"8Gi\"\n\n  jvmOptions:\n    - \"-Xms4g\"\n    - \"-Xmx6g\"\n    - \"-XX:+UseG1GC\"\n    - \"-XX:MaxGCPauseMillis=200\"\n\n  env:\n    KC_LOG_LEVEL: \"INFO\"\n    KC_PROXY: \"edge\"\n    KC_FEATURES: \"token-exchange,admin-fine-grained-authz\"\n</code></pre>"},{"location":"reference/keycloak-crd/#development-setup","title":"Development Setup","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/Keycloak.json\napiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak-dev\n  namespace: keycloak-dev\nspec:\n  replicas: 1\n\n  database:\n    type: postgresql\n    host: postgres\n    database: keycloak\n    username: keycloak\n    passwordSecret:\n      name: postgres-password\n\n  service:\n    type: NodePort\n\n  env:\n    KC_LOG_LEVEL: \"DEBUG\"\n</code></pre>"},{"location":"reference/keycloak-crd/#with-cloudnativepg","title":"With CloudNativePG","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/Keycloak.json\napiVersion: vriesdemichael.github.io/v1\nkind: Keycloak\nmetadata:\n  name: keycloak\n  namespace: keycloak-system\nspec:\n  image: quay.io/keycloak/keycloak:26.4.1\n  replicas: 3\n\n  database:\n    type: postgresql\n    host: keycloak-postgres-rw  # CloudNativePG read-write service\n    database: keycloak\n    username: keycloak\n    passwordSecret:\n      name: keycloak-postgres-app  # CNPG generates this secret\n      key: password\n    sslMode: require\n\n  ingress:\n    enabled: true\n    host: keycloak.example.com\n    className: nginx\n</code></pre>"},{"location":"reference/keycloak-crd/#see-also","title":"See Also","text":"<p>Related CRD References:</p> <ul> <li>KeycloakRealm CRD Reference - Configure realms on Keycloak instances</li> <li>KeycloakClient CRD Reference - Configure OAuth2/OIDC clients</li> </ul> <p>Deployment Guides:</p> <ul> <li>End-to-End Setup - Deploy Keycloak instance with operator</li> <li>Database Setup - Configure PostgreSQL for production</li> <li>High Availability Deployment - Multi-replica Keycloak setup</li> <li>Quick Start Guide - Basic Keycloak instance deployment</li> </ul> <p>Architecture &amp; Operations:</p> <ul> <li>Architecture - Operator design and reconciliation flow</li> <li>Troubleshooting: Keycloak Instance Issues - Common deployment problems</li> <li>Observability - Monitoring Keycloak instances</li> </ul>"},{"location":"reference/keycloak-realm-crd/","title":"KeycloakRealm CRD Reference","text":"<p>Complete reference for the <code>KeycloakRealm</code> Custom Resource Definition.</p>"},{"location":"reference/keycloak-realm-crd/#overview","title":"Overview","text":"<p>The <code>KeycloakRealm</code> CRD defines a Keycloak realm - an identity domain with users, authentication settings, and access control. Realms are isolated from each other and provide complete separation of users, clients, roles, and configuration.</p> <p>API Version: <code>vriesdemichael.github.io/v1</code> Kind: <code>KeycloakRealm</code> Plural: <code>keycloakrealms</code> Singular: <code>keycloakrealm</code> Short Names: <code>kcr</code></p>"},{"location":"reference/keycloak-realm-crd/#minimal-example","title":"Minimal Example","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: my-realm\n  namespace: my-team\nspec:\n  realmName: my-team\n  displayName: \"My Team\"\n  operatorRef:\n    namespace: keycloak-system\n</code></pre>"},{"location":"reference/keycloak-realm-crd/#spec-fields","title":"Spec Fields","text":""},{"location":"reference/keycloak-realm-crd/#core-configuration","title":"Core Configuration","text":"Field Type Required Default Description <code>realmName</code> <code>string</code> Yes - Realm name (must be unique in Keycloak, 1-255 characters) <code>displayName</code> <code>string</code> No - Human-readable realm name <code>description</code> <code>string</code> No - Realm description <code>loginPageTitle</code> <code>string</code> No - HTML title for login pages <p>Example: <pre><code>spec:\n  realmName: production\n  displayName: \"Production Environment\"\n  description: \"Production realm for customer-facing applications\"\n  loginPageTitle: \"Production Login\"\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#operator-reference-required","title":"Operator Reference (Required)","text":"<p>Reference to the Keycloak operator and authorization token.</p> Field Type Required Default Description <code>operatorRef.namespace</code> <code>string</code> Yes - Namespace where the operator is running (e.g., <code>keycloak-system</code>) <p>Example: <pre><code>spec:\n  operatorRef:\n    namespace: keycloak-system\n</code></pre></p> <p>Example - Additional realms (auto-discovery): <pre><code>spec:\n  operatorRef:\n    namespace: keycloak-system\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#security-settings","title":"Security Settings","text":"<p>Comprehensive security and authentication configuration.</p>"},{"location":"reference/keycloak-realm-crd/#registration-and-email","title":"Registration and Email","text":"Field Type Required Default Description <code>security.registrationAllowed</code> boolean No <code>false</code> Allow user self-registration <code>security.registrationEmailAsUsername</code> boolean No <code>false</code> Use email as username for registration <code>security.editUsernameAllowed</code> boolean No <code>false</code> Allow users to edit their username <code>security.resetPasswordAllowed</code> boolean No <code>true</code> Allow password reset <code>security.rememberMe</code> boolean No <code>false</code> Show \"Remember Me\" checkbox on login <code>security.verifyEmail</code> boolean No <code>false</code> Require email verification <code>security.loginWithEmailAllowed</code> boolean No <code>true</code> Allow login with email address <code>security.duplicateEmailsAllowed</code> boolean No <code>false</code> Allow multiple users with same email <p>Example: <pre><code>spec:\n  security:\n    registrationAllowed: true\n    registrationEmailAsUsername: true\n    verifyEmail: true\n    resetPasswordAllowed: true\n    loginWithEmailAllowed: true\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#ssltls-requirements","title":"SSL/TLS Requirements","text":"Field Type Required Default Description <code>security.sslRequired</code> <code>string</code> No <code>external</code> SSL requirement level. Options: <code>all</code>, <code>external</code>, <code>none</code> <ul> <li><code>all</code>: HTTPS required for all connections</li> <li><code>external</code>: HTTPS required for external connections only</li> <li><code>none</code>: HTTPS not required</li> </ul>"},{"location":"reference/keycloak-realm-crd/#brute-force-protection","title":"Brute Force Protection","text":"Field Type Required Default Description <code>security.bruteForceProtected</code> boolean No <code>false</code> Enable brute force attack protection <code>security.permanentLockout</code> boolean No <code>false</code> Permanently lock out users after max failures <code>security.maxFailureWait</code> integer No - Max wait time after login failures (seconds) <code>security.minimumQuickLoginWait</code> integer No - Minimum wait for quick login attempts (seconds) <code>security.waitIncrement</code> integer No - Incremental wait time (seconds) <code>security.quickLoginCheckMillis</code> integer No - Time window for quick login detection (milliseconds) <code>security.maxDeltaTime</code> integer No - Maximum time delta between login attempts (seconds) <code>security.failureFactor</code> integer No - Multiplier for wait time after failures <p>Example: <pre><code>spec:\n  security:\n    bruteForceProtected: true\n    permanentLockout: false\n    maxFailureWait: 900  # 15 minutes\n    minimumQuickLoginWait: 60\n    waitIncrement: 60\n    quickLoginCheckMillis: 1000\n    maxDeltaTime: 43200  # 12 hours\n    failureFactor: 30\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#token-and-session-settings","title":"Token and Session Settings","text":"Field Type Required Default Description <code>security.revokeRefreshToken</code> boolean No <code>false</code> Revoke refresh tokens after use <code>security.refreshTokenMaxReuse</code> integer No - Max times a refresh token can be reused (min: 0)"},{"location":"reference/keycloak-realm-crd/#token-settings","title":"Token Settings","text":"<p>Configure token lifespans and session timeouts.</p> Field Type Required Default Description <code>tokenSettings.accessTokenLifespan</code> integer No - Access token lifespan in seconds <code>tokenSettings.accessTokenLifespanForImplicitFlow</code> integer No - Access token lifespan for implicit flow in seconds <code>tokenSettings.ssoSessionIdleTimeout</code> integer No - SSO session idle timeout in seconds <code>tokenSettings.ssoSessionMaxLifespan</code> integer No - SSO session max lifespan in seconds <code>tokenSettings.offlineSessionIdleTimeout</code> integer No - Offline session idle timeout in seconds <code>tokenSettings.offlineSessionMaxLifespanEnabled</code> boolean No <code>false</code> Enable offline session max lifespan <code>tokenSettings.offlineSessionMaxLifespan</code> integer No - Offline session max lifespan in seconds <code>tokenSettings.clientSessionIdleTimeout</code> integer No - Client session idle timeout in seconds <code>tokenSettings.clientSessionMaxLifespan</code> integer No - Client session max lifespan in seconds <code>tokenSettings.clientOfflineSessionIdleTimeout</code> integer No - Client offline session idle timeout in seconds <code>tokenSettings.clientOfflineSessionMaxLifespan</code> integer No - Client offline session max lifespan in seconds <p>Example: <pre><code>spec:\n  tokenSettings:\n    accessTokenLifespan: 300  # 5 minutes\n    ssoSessionIdleTimeout: 1800  # 30 minutes\n    ssoSessionMaxLifespan: 36000  # 10 hours\n    offlineSessionIdleTimeout: 2592000  # 30 days\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#theme-configuration","title":"Theme Configuration","text":"<p>Customize the appearance of Keycloak pages.</p> Field Type Required Default Description <code>themes.login</code> <code>string</code> No - Login page theme <code>themes.admin</code> <code>string</code> No - Admin console theme <code>themes.account</code> <code>string</code> No - Account management theme <code>themes.email</code> <code>string</code> No - Email template theme <p>Example: <pre><code>spec:\n  themes:\n    login: keycloak\n    admin: keycloak\n    account: keycloak\n    email: keycloak\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#smtp-server-configuration","title":"SMTP Server Configuration","text":"<p>Configure email sending for registration, password reset, and notifications.</p> Field Type Required Default Description <code>smtpServer.host</code> <code>string</code> No - SMTP server hostname <code>smtpServer.port</code> integer No - SMTP server port (1-65535) <code>smtpServer.from</code> <code>string</code> No - From email address <code>smtpServer.fromDisplayName</code> <code>string</code> No - From display name <code>smtpServer.replyTo</code> <code>string</code> No - Reply-to email address <code>smtpServer.envelopeFrom</code> <code>string</code> No - Envelope from address <code>smtpServer.ssl</code> boolean No <code>false</code> Use SSL <code>smtpServer.starttls</code> boolean No <code>false</code> Use STARTTLS <code>smtpServer.auth</code> boolean No <code>false</code> Require authentication <code>smtpServer.user</code> <code>string</code> No - SMTP username <code>smtpServer.password</code> <code>string</code> No - SMTP password (use <code>passwordSecret</code> instead) <code>smtpServer.passwordSecret.name</code> <code>string</code> No - Secret name containing SMTP password (recommended) <code>smtpServer.passwordSecret.key</code> <code>string</code> No <code>password</code> Key in secret data <p>Example - Gmail: <pre><code>spec:\n  smtpServer:\n    host: smtp.gmail.com\n    port: 587\n    from: noreply@example.com\n    fromDisplayName: \"My App\"\n    starttls: true\n    auth: true\n    user: noreply@example.com\n    passwordSecret:\n      name: smtp-credentials\n      key: password\n</code></pre></p> <p>Example - SendGrid: <pre><code>spec:\n  smtpServer:\n    host: smtp.sendgrid.net\n    port: 587\n    from: noreply@example.com\n    fromDisplayName: \"My Team\"\n    starttls: true\n    auth: true\n    user: apikey\n    passwordSecret:\n      name: sendgrid-credentials\n      key: api-key\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#localization","title":"Localization","text":"<p>Configure internationalization (i18n) support.</p> Field Type Required Default Description <code>localization.enabled</code> boolean No <code>false</code> Enable internationalization <code>localization.supportedLocales</code> []<code>string</code> No - List of supported locales (e.g., <code>en</code>, <code>de</code>, <code>fr</code>) <code>localization.defaultLocale</code> <code>string</code> No - Default locale <p>Example: <pre><code>spec:\n  localization:\n    enabled: true\n    supportedLocales:\n      - en\n      - de\n      - fr\n      - es\n    defaultLocale: en\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#authentication-flows","title":"Authentication Flows","text":"<p>Define custom authentication flows with executions.</p>"},{"location":"reference/keycloak-realm-crd/#flow-configuration","title":"Flow Configuration","text":"Field Type Required Default Description <code>authenticationFlows[].alias</code> <code>string</code> Yes - Flow alias (unique identifier) <code>authenticationFlows[].description</code> <code>string</code> No - Flow description <code>authenticationFlows[].providerId</code> <code>string</code> No <code>basic-flow</code> Provider ID for the flow <code>authenticationFlows[].topLevel</code> boolean No <code>true</code> Whether this is a top-level flow <code>authenticationFlows[].builtIn</code> boolean No <code>false</code> Whether this is a built-in flow <code>authenticationFlows[].executions</code> []object No - List of executions in this flow"},{"location":"reference/keycloak-realm-crd/#execution-configuration","title":"Execution Configuration","text":"<p>Executions define the individual steps within an authentication flow. Each execution must specify either an <code>authenticator</code> (for built-in authenticators) or a <code>flowAlias</code> (to reference a sub-flow).</p> Field Type Required Default Description <code>executions[].authenticator</code> <code>string</code> No* - Authenticator provider ID (e.g., <code>auth-username-password-form</code>) <code>executions[].flowAlias</code> <code>string</code> No* - Reference to a sub-flow by its alias <code>executions[].requirement</code> <code>string</code> No <code>DISABLED</code> Execution requirement: <code>REQUIRED</code>, <code>ALTERNATIVE</code>, <code>CONDITIONAL</code>, <code>DISABLED</code> <code>executions[].priority</code> integer No <code>0</code> Order of execution (lower = first) <code>executions[].authenticatorFlow</code> boolean No <code>false</code> True if this execution references a sub-flow <code>executions[].authenticatorConfig</code> object No - Configuration for the authenticator <p>* Either <code>authenticator</code> or <code>flowAlias</code> must be specified, but not both.</p>"},{"location":"reference/keycloak-realm-crd/#authenticator-config","title":"Authenticator Config","text":"Field Type Required Default Description <code>authenticatorConfig.alias</code> <code>string</code> Yes - Configuration alias (unique identifier) <code>authenticatorConfig.config</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Key-value configuration parameters"},{"location":"reference/keycloak-realm-crd/#common-authenticators","title":"Common Authenticators","text":"Authenticator ID Description <code>auth-cookie</code> Cookie-based authentication <code>auth-username-password-form</code> Username/password form <code>auth-otp-form</code> One-time password (OTP) form <code>identity-provider-redirector</code> Redirect to identity provider <code>reset-credentials-choose-user</code> Password reset: choose user <code>reset-credential-email</code> Password reset: send email <code>reset-password</code> Password reset: set new password <code>conditional-user-configured</code> Conditional: check if user has authenticator configured <code>auth-conditional-otp-form</code> Conditional OTP form <p>Example - Simple Flow: <pre><code>spec:\n  authenticationFlows:\n    - alias: my-browser-flow\n      description: \"Custom browser flow\"\n      providerId: basic-flow\n      topLevel: true\n      builtIn: false\n      executions:\n        - authenticator: auth-cookie\n          requirement: ALTERNATIVE\n          priority: 10\n        - authenticator: auth-username-password-form\n          requirement: REQUIRED\n          priority: 20\n</code></pre></p> <p>Example - Flow with OTP: <pre><code>spec:\n  authenticationFlows:\n    - alias: browser-with-otp\n      description: \"Browser flow with mandatory OTP\"\n      providerId: basic-flow\n      topLevel: true\n      executions:\n        - authenticator: auth-cookie\n          requirement: ALTERNATIVE\n          priority: 10\n        - authenticator: auth-username-password-form\n          requirement: REQUIRED\n          priority: 20\n        - authenticator: auth-otp-form\n          requirement: REQUIRED\n          priority: 30\n</code></pre></p> <p>Example - Flow with Sub-flow: <pre><code>spec:\n  authenticationFlows:\n    # Main browser flow\n    - alias: custom-browser\n      description: \"Custom browser flow with conditional OTP\"\n      providerId: basic-flow\n      topLevel: true\n      executions:\n        - authenticator: auth-cookie\n          requirement: ALTERNATIVE\n          priority: 10\n        - authenticator: auth-username-password-form\n          requirement: REQUIRED\n          priority: 20\n        - flowAlias: conditional-otp-subflow\n          requirement: CONDITIONAL\n          priority: 30\n          authenticatorFlow: true\n\n    # Sub-flow for conditional OTP\n    - alias: conditional-otp-subflow\n      description: \"Conditional OTP sub-flow\"\n      providerId: basic-flow\n      topLevel: false\n      executions:\n        - authenticator: conditional-user-configured\n          requirement: REQUIRED\n          priority: 10\n        - authenticator: auth-otp-form\n          requirement: REQUIRED\n          priority: 20\n</code></pre></p> <p>Example - Identity Provider Redirector with Config: <pre><code>spec:\n  authenticationFlows:\n    - alias: idp-redirector-flow\n      description: \"Auto-redirect to Azure AD\"\n      providerId: basic-flow\n      topLevel: true\n      executions:\n        - authenticator: identity-provider-redirector\n          requirement: REQUIRED\n          priority: 10\n          authenticatorConfig:\n            alias: azure-redirector-config\n            config:\n              defaultProvider: azure-ad\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#identity-providers","title":"Identity Providers","text":"<p>Configure external identity providers (social login, SAML, OIDC).</p> Field Type Required Default Description <code>identityProviders[].alias</code> <code>string</code> Yes - Provider alias (unique identifier) <code>identityProviders[].providerId</code> <code>string</code> Yes - Provider ID (e.g., <code>google</code>, <code>github</code>, <code>oidc</code>, <code>saml</code>) <code>identityProviders[].enabled</code> boolean No <code>true</code> Enable this provider <code>identityProviders[].trustEmail</code> boolean No <code>false</code> Trust email from provider <code>identityProviders[].storeToken</code> boolean No <code>false</code> Store provider tokens <code>identityProviders[].addReadTokenRoleOnCreate</code> boolean No <code>false</code> Add read token role on create <code>identityProviders[].authenticateByDefault</code> boolean No <code>false</code> Authenticate by default <code>identityProviders[].linkOnly</code> boolean No <code>false</code> Only allow linking <code>identityProviders[].firstBrokerLoginFlowAlias</code> <code>string</code> No - First broker login flow <code>identityProviders[].postBrokerLoginFlowAlias</code> <code>string</code> No - Post broker login flow <code>identityProviders[].config</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Provider-specific configuration <p>Example - Google: <pre><code>spec:\n  identityProviders:\n    - alias: google\n      providerId: google\n      enabled: true\n      trustEmail: true\n      config:\n        clientId: \"your-client-id.apps.googleusercontent.com\"\n        clientSecret: \"your-client-secret\"\n        hostedDomain: \"example.com\"\n</code></pre></p> <p>Example - Azure AD: <pre><code>spec:\n  identityProviders:\n    - alias: azure-ad\n      providerId: oidc\n      enabled: true\n      trustEmail: true\n      config:\n        clientId: \"azure-client-id\"\n        clientSecret: \"azure-client-secret\"\n        authorizationUrl: \"https://login.microsoftonline.com/tenant-id/oauth2/v2.0/authorize\"\n        tokenUrl: \"https://login.microsoftonline.com/tenant-id/oauth2/v2.0/token\"\n        jwksUrl: \"https://login.microsoftonline.com/tenant-id/discovery/v2.0/keys\"\n        issuer: \"https://login.microsoftonline.com/tenant-id/v2.0\"\n</code></pre></p> <p>See examples/ directory for complete identity provider configurations.</p>"},{"location":"reference/keycloak-realm-crd/#user-federation","title":"User Federation","text":"<p>Configure user federation providers (LDAP, Active Directory).</p> Field Type Required Default Description <code>userFederation[].displayName</code> <code>string</code> Yes - Display name for the provider <code>userFederation[].providerName</code> <code>string</code> Yes - Provider name (e.g., <code>ldap</code>, <code>kerberos</code>) <code>userFederation[].priority</code> integer No - Provider priority (min: 0) <code>userFederation[].config</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Provider-specific configuration <p>Example - LDAP: <pre><code>spec:\n  userFederation:\n    - displayName: \"Corporate LDAP\"\n      providerName: ldap\n      priority: 0\n      config:\n        connectionUrl: \"ldap://ldap.example.com:389\"\n        usersDn: \"ou=users,dc=example,dc=com\"\n        bindDn: \"cn=admin,dc=example,dc=com\"\n        bindCredential: \"admin-password\"\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#client-scopes","title":"Client Scopes","text":"<p>Define reusable protocol mappers and claims.</p> Field Type Required Default Description <code>clientScopes[].name</code> <code>string</code> Yes - Scope name <code>clientScopes[].description</code> <code>string</code> No - Scope description <code>clientScopes[].protocol</code> <code>string</code> No <code>openid-connect</code> Protocol (e.g., <code>openid-connect</code>, <code>saml</code>) <code>clientScopes[].attributes</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Scope attributes <code>clientScopes[].protocolMappers</code> []object No - Protocol mappers for this scope <p>Example: <pre><code>spec:\n  clientScopes:\n    - name: department\n      description: \"Department information\"\n      protocol: openid-connect\n      protocolMappers:\n        - name: department-mapper\n          protocol: openid-connect\n          protocolMapper: oidc-usermodel-attribute-mapper\n          config:\n            user.attribute: department\n            claim.name: department\n            jsonType.label: String\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#roles","title":"Roles","text":"<p>Define realm-level roles.</p> Field Type Required Default Description <code>roles.realmRoles[].name</code> <code>string</code> Yes - Role name <code>roles.realmRoles[].description</code> <code>string</code> No - Role description <code>roles.realmRoles[].composite</code> boolean No <code>false</code> Whether this is a composite role <code>roles.realmRoles[].compositeRoles</code> []<code>string</code> No - Names of roles to include in this composite role <code>roles.realmRoles[].clientRole</code> boolean No <code>false</code> Whether this is a client role <code>roles.realmRoles[].containerId</code> <code>string</code> No - Container ID (for composite roles) <code>roles.realmRoles[].attributes</code> mapstringstring No - Role attributes as key-value pairs where values are arrays <p>Example - Basic Roles: <pre><code>spec:\n  roles:\n    realmRoles:\n      - name: admin\n        description: \"Administrator role\"\n        attributes:\n          department: [\"IT\"]\n          level: [\"senior\"]\n      - name: user\n        description: \"Standard user role\"\n      - name: viewer\n        description: \"Read-only viewer role\"\n</code></pre></p> <p>Example - Composite Roles: <pre><code>spec:\n  roles:\n    realmRoles:\n      # Base roles\n      - name: user\n        description: \"Standard user role\"\n      - name: developer\n        description: \"Developer role with code access\"\n      - name: reviewer\n        description: \"Code reviewer role\"\n      # Composite role that includes other roles\n      - name: senior-developer\n        description: \"Senior developer with all developer permissions\"\n        composite: true\n        compositeRoles:\n          - developer\n          - reviewer\n      # Manager composite role\n      - name: engineering-manager\n        description: \"Engineering manager with full access\"\n        composite: true\n        compositeRoles:\n          - user\n          - senior-developer\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#groups","title":"Groups","text":"<p>Define user groups with role assignments and hierarchical subgroups.</p> Field Type Required Default Description <code>groups[].name</code> <code>string</code> Yes - Group name <code>groups[].path</code> <code>string</code> No - Group path (auto-generated if not specified) <code>groups[].attributes</code> map<code>string</code><code>string</code> No <code>{}</code> Group attributes <code>groups[].realmRoles</code> []<code>string</code> No - Realm roles assigned to group members <code>groups[].clientRoles</code> map<code>string</code><code>string</code> No <code>{}</code> Client roles assigned to group members <code>groups[].subGroups</code> []group No - Nested subgroups <p>Example - Basic Groups: <pre><code>spec:\n  groups:\n    - name: engineering\n      attributes:\n        department: [\"Engineering\"]\n      realmRoles:\n        - user\n    - name: admins\n      realmRoles:\n        - admin\n</code></pre></p> <p>Example - Nested Groups: <pre><code>spec:\n  groups:\n    - name: engineering\n      attributes:\n        department: [\"Engineering\"]\n      realmRoles:\n        - user\n      subGroups:\n        - name: backend\n          attributes:\n            team: [\"Backend\"]\n          realmRoles:\n            - developer\n        - name: frontend\n          attributes:\n            team: [\"Frontend\"]\n          realmRoles:\n            - developer\n        - name: platform\n          attributes:\n            team: [\"Platform\"]\n          realmRoles:\n            - developer\n            - admin  # Platform team has admin access\n    - name: product\n      attributes:\n        department: [\"Product\"]\n      realmRoles:\n        - user\n      subGroups:\n        - name: managers\n          realmRoles:\n            - reviewer\n</code></pre></p> <p>Example - Groups with Client Roles: <pre><code>spec:\n  groups:\n    - name: api-consumers\n      clientRoles:\n        my-api-client:\n          - api-read\n          - api-write\n        admin-portal:\n          - view-dashboard\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#default-groups","title":"Default Groups","text":"<p>Specify groups that are automatically assigned to new users when they register or are created.</p> Field Type Required Default Description <code>defaultGroups</code> []<code>string</code> No <code>[]</code> Group names or paths to automatically assign to new users <p>Example: <pre><code>spec:\n  # Define groups first\n  groups:\n    - name: users\n      realmRoles:\n        - user\n    - name: engineering\n      subGroups:\n        - name: new-hires\n          realmRoles:\n            - trainee\n\n  # Assign default groups\n  defaultGroups:\n    - /users                    # All new users get the 'users' group\n    - /engineering/new-hires    # New engineering users start in new-hires\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#custom-attributes","title":"Custom Attributes","text":"<p>Add custom realm attributes.</p> Field Type Required Default Description <code>attributes</code> map[<code>string</code>]<code>string</code> No <code>{}</code> Custom attributes as key-value pairs <p>Example: <pre><code>spec:\n  attributes:\n    organization: \"ACME Corp\"\n    environment: \"production\"\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#events-configuration","title":"Events Configuration","text":"<p>Configure event logging and auditing.</p> Field Type Required Default Description <code>eventsConfig.eventsEnabled</code> boolean No <code>false</code> Enable user event logging <code>eventsConfig.eventsListeners</code> []<code>string</code> No - Event listener implementations <code>eventsConfig.enabledEventTypes</code> []<code>string</code> No - Enabled event types <code>eventsConfig.eventsExpiration</code> integer No - Event expiration time in seconds <code>eventsConfig.adminEventsEnabled</code> boolean No <code>false</code> Enable admin event logging <code>eventsConfig.adminEventsDetailsEnabled</code> boolean No <code>false</code> Include details in admin events <p>Example: <pre><code>spec:\n  eventsConfig:\n    eventsEnabled: true\n    eventsListeners:\n      - jboss-logging\n    enabledEventTypes:\n      - LOGIN\n      - LOGOUT\n      - REGISTER\n      - UPDATE_PASSWORD\n    eventsExpiration: 2592000  # 30 days\n    adminEventsEnabled: true\n    adminEventsDetailsEnabled: true\n</code></pre></p>"},{"location":"reference/keycloak-realm-crd/#status-fields","title":"Status Fields","text":"Field Type Description <code>phase</code> <code>string</code> Current phase: <code>Pending</code>, <code>Provisioning</code>, <code>Ready</code>, <code>Failed</code>, <code>Updating</code>, <code>Degraded</code> <code>message</code> <code>string</code> Human-readable status message <code>reason</code> <code>string</code> Reason for current phase <code>observedGeneration</code> integer Generation of spec that was last processed <code>realmName</code> <code>string</code> Name of the realm in Keycloak <code>internalId</code> <code>string</code> Internal Keycloak realm ID <code>keycloakInstance</code> <code>string</code> Keycloak instance managing this realm"},{"location":"reference/keycloak-realm-crd/#oidc-endpoints-automatically-populated","title":"OIDC Endpoints (Automatically Populated)","text":"<p>The operator automatically discovers and populates all standard OIDC/OAuth2 endpoints based on the Keycloak instance URL and realm name:</p> Field Type Description <code>endpoints.issuer</code> <code>string</code> OIDC issuer endpoint <code>endpoints.auth</code> <code>string</code> OIDC authorization endpoint <code>endpoints.token</code> <code>string</code> OIDC token endpoint <code>endpoints.userinfo</code> <code>string</code> OIDC userinfo endpoint <code>endpoints.jwks</code> <code>string</code> OIDC JWKS endpoint <code>endpoints.endSession</code> <code>string</code> OIDC end session endpoint <code>endpoints.registration</code> <code>string</code> OIDC dynamic client registration endpoint <p>These endpoints are automatically constructed using the Keycloak instance's base URL (from public/internal endpoints or service DNS) and follow the standard OIDC discovery specification.</p>"},{"location":"reference/keycloak-realm-crd/#additional-status-fields","title":"Additional Status Fields","text":"Field Type Description <code>features.userRegistration</code> boolean Whether user registration is enabled <code>features.passwordReset</code> boolean Whether password reset is enabled <code>features.identityProviders</code> integer Number of configured identity providers <code>features.userFederationProviders</code> integer Number of user federation providers <code>features.customThemes</code> boolean Whether custom themes are configured <code>activeUsers</code> integer Number of active users <code>totalClients</code> integer Number of clients in realm <code>realmRolesCount</code> integer Number of realm roles <code>lastHealthCheck</code> <code>string</code> (datetime) Last health check timestamp <code>lastUpdated</code> <code>string</code> (datetime) Last update timestamp"},{"location":"reference/keycloak-realm-crd/#complete-examples","title":"Complete Examples","text":""},{"location":"reference/keycloak-realm-crd/#basic-realm","title":"Basic Realm","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: basic-realm\n  namespace: my-team\nspec:\n  realmName: basic\n  displayName: \"Basic Realm\"\n  operatorRef:\n    namespace: keycloak-system\n</code></pre>"},{"location":"reference/keycloak-realm-crd/#production-realm-with-security","title":"Production Realm with Security","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: production\n  namespace: production\nspec:\n  realmName: production\n  displayName: \"Production Environment\"\n\n  operatorRef:\n    namespace: keycloak-system\n\n  security:\n    registrationAllowed: false\n    verifyEmail: true\n    resetPasswordAllowed: true\n    loginWithEmailAllowed: true\n    sslRequired: all\n    bruteForceProtected: true\n    permanentLockout: false\n    maxFailureWait: 900\n    minimumQuickLoginWait: 60\n\n  tokenSettings:\n    accessTokenLifespan: 300\n    ssoSessionIdleTimeout: 1800\n    ssoSessionMaxLifespan: 36000\n\n  smtpServer:\n    host: smtp.sendgrid.net\n    port: 587\n    from: noreply@example.com\n    fromDisplayName: \"Production System\"\n    starttls: true\n    auth: true\n    user: apikey\n    passwordSecret:\n      name: smtp-credentials\n\n  eventsConfig:\n    eventsEnabled: true\n    eventsListeners:\n      - jboss-logging\n    adminEventsEnabled: true\n</code></pre>"},{"location":"reference/keycloak-realm-crd/#realm-with-google-sso","title":"Realm with Google SSO","text":"<pre><code># yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json\napiVersion: vriesdemichael.github.io/v1\nkind: KeycloakRealm\nmetadata:\n  name: realm-with-google\n  namespace: my-team\nspec:\n  realmName: myteam\n  displayName: \"My Team\"\n\n  operatorRef:\n    namespace: keycloak-system\n\n  security:\n    registrationAllowed: true\n    verifyEmail: true\n\n  identityProviders:\n    - alias: google\n      providerId: google\n      enabled: true\n      trustEmail: true\n      config:\n        clientId: \"your-client-id.apps.googleusercontent.com\"\n        clientSecret: \"your-client-secret\"\n        hostedDomain: \"example.com\"\n</code></pre>"},{"location":"reference/keycloak-realm-crd/#see-also","title":"See Also","text":"<p>Related CRD References:</p> <ul> <li>Keycloak CRD Reference - Configure Keycloak instances</li> <li>KeycloakClient CRD Reference - Configure OAuth2/OIDC clients</li> </ul> <p>Configuration Guides:</p> <ul> <li>End-to-End Setup - Complete realm deployment example</li> <li>SMTP Configuration - Email server setup for realms</li> <li>Multi-Tenant Setup - Configuring multiple realms with authorization grants</li> <li>Identity Providers - Integrate Google, GitHub, Azure AD, and other SSO</li> </ul> <p>Examples:</p> <ul> <li>Realm Examples - Production-ready realm configurations</li> <li>Identity Provider Examples - SSO integration examples</li> </ul> <p>Architecture &amp; Security:</p> <ul> <li>Architecture: Token System - How realm tokens work</li> <li>Security Model - Authorization and token security</li> <li>Security Model - Authorization model</li> </ul>"}]}