# Security Model

This document explains the security model of the Keycloak operator, with a focus on the secret-based authorization system that enables secure, scalable delegation of Keycloak resource management.

## Overview

The Keycloak operator implements a capability-based authorization model using Kubernetes secrets as bearer tokens. This design choice prioritizes **scalability** and **operational simplicity** over traditional RBAC-based approaches.

### Design Philosophy

**Key principle**: Application teams should be able to manage their own Keycloak realms and clients without requiring platform team intervention or operator RBAC changes.

Traditional RBAC approaches create bottlenecks:
- ‚ùå Adding a new team requires updating operator ClusterRole
- ‚ùå Cross-namespace access requires complex RoleBinding configurations
- ‚ùå GitOps workflows are blocked on RBAC updates
- ‚ùå Doesn't scale beyond ~10 teams

Secret-based authorization solves these problems:
- ‚úÖ Delegate to 100+ teams without touching operator configuration
- ‚úÖ Self-service: Platform team shares a secret, app team can proceed
- ‚úÖ GitOps-friendly: Secrets are just another Kubernetes resource
- ‚úÖ Audit trail: Secret access is logged by Kubernetes API server

## Authorization Model

### Three-Level Token System

The operator uses three types of authorization tokens:

#### 1. Operator Authorization Token

**Purpose**: Allows realms to be created on a Keycloak instance

**Generated by**: Operator when it starts
**Stored in**: `keycloak-operator-auth-token` secret in operator namespace
**Used by**: KeycloakRealm resources to validate they have permission to create realms

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-operator-auth-token
  namespace: keycloak-operator-system
type: Opaque
data:
  token: <base64-encoded-random-token>
```

**Workflow**:
```bash
# Platform team creates Keycloak instance
kubectl apply -f keycloak.yaml

# Operator generates operator token automatically
# Platform team shares this token with application teams
kubectl get secret keycloak-operator-auth-token -n keycloak-operator-system -o yaml | \
  kubectl apply -n app-team-namespace -f -
```

#### 2. Realm Authorization Token

**Purpose**: Allows clients to be created within a specific realm

**Generated by**: Operator when a KeycloakRealm is created
**Stored in**: `<realm-name>-realm-auth` secret in realm's namespace
**Used by**: KeycloakClient resources to validate they have permission to create clients in that realm

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-realm-realm-auth
  namespace: app-team-namespace
  ownerReferences:
    - apiVersion: vriesdemichael.github.io/v1
      kind: KeycloakRealm
      name: my-realm
type: Opaque
data:
  token: <base64-encoded-random-token>
```

**Workflow**:
```bash
# App team creates realm (using operator token)
kubectl apply -f realm.yaml

# Operator generates realm token automatically
# App team can now create clients in this realm
kubectl apply -f client.yaml
```

#### 3. Admin Credentials

**Purpose**: Keycloak admin console access
**Generated by**: Operator when Keycloak instance is created
**Stored in**: `<keycloak-name>-admin-credentials` secret

These are standard Keycloak admin credentials and are separate from the operator's authorization system.

## How It Works

### Token Generation

All tokens are generated using cryptographically secure random number generation:

```python
import secrets
token = secrets.token_urlsafe(32)  # 256 bits of entropy
```

### Token Validation

When a resource references another resource cross-namespace, the operator:

1. Reads the authorization secret from the **source namespace** (where the requesting resource lives)
2. Reads the expected token from the **target namespace** (where the referenced resource lives)
3. Compares the tokens using constant-time comparison to prevent timing attacks
4. Grants or denies access based on the comparison

Example for KeycloakRealm ‚Üí Keycloak:

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: my-realm
  namespace: app-team
spec:
  realmName: my-realm
  operatorRef:
    namespace: platform-team  # Target namespace
    authorizationSecretRef:
      name: keycloak-operator-auth-token  # Secret in app-team namespace
```

The operator will:
1. Read `keycloak-operator-auth-token` from `app-team` namespace
2. Read `keycloak-operator-auth-token` from `platform-team` namespace (or operator namespace)
3. Compare the tokens
4. Allow realm creation if they match

## Security Properties

### Cryptographic Security

- **Token generation**: Uses `secrets.token_urlsafe()` from Python's secrets module
- **Entropy**: 256 bits per token (same as a good password)
- **Comparison**: Constant-time to prevent timing attacks
- **Storage**: Tokens stored as Kubernetes secrets (encrypted at rest if cluster configured)

### Kubernetes-Native Security

Leverages existing Kubernetes security primitives:

- **Secret RBAC**: Teams need `get` permission on secrets to use them
- **Namespace isolation**: Secrets don't leak across namespaces without explicit sharing
- **Audit logging**: Kubernetes API server logs all secret access
- **Encryption at rest**: If cluster has encryption enabled, tokens are encrypted

### Namespace Isolation

The token system enforces namespace boundaries:

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
# This works (token in same namespace as realm)
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: my-realm
  namespace: team-a
spec:
  realmName: my-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: operator-token  # Secret exists in team-a namespace
```

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
# This fails (token not present in team-b namespace)
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: malicious-realm
  namespace: team-b
spec:
  realmName: malicious-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: operator-token  # Secret doesn't exist in team-b namespace
```

## Delegation Workflow

### Platform Team Workflow

1. **Create Keycloak instance** in platform namespace:

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/Keycloak.json
apiVersion: vriesdemichael.github.io/v1
kind: Keycloak
metadata:
  name: keycloak
  namespace: platform
spec:
  replicas: 3
  database:
    type: cnpg
    cluster: keycloak-db
```

2. **Operator automatically generates** `keycloak-operator-auth-token` secret

3. **Share the operator token** with application teams:

```bash
# Export operator token
kubectl get secret keycloak-operator-auth-token \
  -n keycloak-operator-system -o yaml > operator-token.yaml

# Application team applies it to their namespace
kubectl apply -f operator-token.yaml -n app-team
```

### Application Team Workflow

1. **Receive operator token** from platform team (via GitOps, secret management, etc.)

2. **Create realm** referencing the operator token:

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: my-app-realm
  namespace: app-team
spec:
  realmName: my-app-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: keycloak-operator-auth-token
  security:
    registrationAllowed: false
    resetPasswordAllowed: true
```

3. **Operator generates realm token** automatically: `my-app-realm-realm-auth`

4. **Create clients** using the realm token (no additional secrets needed):

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakClient.json
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakClient
metadata:
  name: my-app-client
  namespace: app-team
spec:
  clientId: my-app
  realmRef:
    name: my-app-realm
    namespace: app-team
    authorizationSecretRef:
      name: my-app-realm-realm-auth
  settings:
    publicClient: false
    standardFlowEnabled: true
```

## Best Practices

### Token Distribution

**Use GitOps for secret distribution:**

```yaml
# Git repository structure
secrets/
  platform/
    keycloak-operator-token.yaml  # Platform team manages
  teams/
    team-a/
      keycloak-operator-token.yaml  # Copy of platform token
    team-b/
      keycloak-operator-token.yaml  # Copy of platform token
```

**Use External Secrets Operator** for enterprise secret management:

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: keycloak-operator-auth-token
  namespace: app-team
spec:
  secretStoreRef:
    name: vault-backend
    kind: ClusterSecretStore
  target:
    name: keycloak-operator-auth-token
  data:
    - secretKey: token
      remoteRef:
        key: keycloak/operator-token
        property: token
```

### Token Rotation

**üÜï AUTOMATIC TOKEN ROTATION SYSTEM**

The operator now features automatic token rotation to enhance security without requiring manual intervention. This system ensures long-lived operational tokens are regularly refreshed while maintaining zero-downtime for applications.

#### Overview

The operator implements a **two-phase token system**:

1. **Admission Tokens** (One-time use)
   - Created by platform teams
   - Used only for bootstrapping
   - Trigger creation of operational tokens

2. **Operational Tokens** (Auto-rotating)
   - Generated automatically by the operator
   - Rotate every 90 days
   - Support graceful transition (7-day grace period)

#### Token Lifecycle

```
Day 1:   Platform team creates admission token
         ‚Üì
         First realm created ‚Üí Operational token generated
         ‚Üì
Day 2-82: All realms in namespace use operational token
         ‚Üì
Day 83:  Operator detects token expires in 7 days
         ‚Üí Generates new token (version N+1)
         ‚Üí Stores BOTH tokens (grace period)
         ‚Üì
Day 84-90: Applications can use either token
         ‚Üì
Day 90:  Grace period ends
         ‚Üí Old token removed automatically
         ‚Üí Only new token remains
```

#### How It Works

##### 1. Bootstrap Flow (First Realm)

When the **first** realm is created in a namespace:

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: first-realm
  namespace: team-a
spec:
  realmName: first-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: admission-token-team-a  # One-time admission token
      key: token
```

**What happens:**
1. Operator validates the admission token
2. Generates a new operational token (version 1)
3. Stores operational token in `team-a-operator-token` secret
4. Records metadata in ConfigMap for persistence
5. Realm uses operational token going forward

##### 2. Subsequent Realms (Use Operational Token)

All subsequent realms in the same namespace use the operational token:

```yaml
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: second-realm
  namespace: team-a
spec:
  realmName: second-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: team-a-operator-token  # Operational token (auto-rotating)
      key: token
```

**Benefits:**
- ‚úÖ No manual token management needed
- ‚úÖ Tokens rotate automatically every 90 days
- ‚úÖ Zero downtime during rotation (grace period)
- ‚úÖ Audit trail in ConfigMap metadata

##### 3. Automatic Rotation

The operator runs rotation handlers automatically:

**Daily Check (00:00 UTC)**:
- Scans all operational tokens
- Identifies tokens expiring within 7 days
- Generates new tokens (version increment)
- Updates secrets with dual-token data:
  ```yaml
  data:
    token: <new-token>           # Version N+1
    token-previous: <old-token>  # Version N (for grace period)
  ```

**Hourly Cleanup**:
- Checks for expired grace periods
- Removes `token-previous` from secrets
- Cleans up old metadata

#### Token Secret Structure

##### Operational Token Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: team-a-operator-token
  namespace: team-a
  labels:
    vriesdemichael.github.io/token-type: operational
    vriesdemichael.github.io/managed-by: keycloak-operator
    vriesdemichael.github.io/allow-operator-read: "true"
  annotations:
    vriesdemichael.github.io/version: "2"
    vriesdemichael.github.io/valid-until: "2025-04-15T00:00:00Z"
    vriesdemichael.github.io/created-by-realm: "first-realm"
    vriesdemichael.github.io/grace-period-ends: "2025-04-22T00:00:00Z"  # During rotation
  ownerReferences:
    - apiVersion: vriesdemichael.github.io/v1
      kind: KeycloakRealm
      name: first-realm
      uid: <realm-uid>
type: Opaque
data:
  token: <base64-new-token>      # Current token (version 2)
  token-previous: <base64-old>   # Previous token (version 1, during grace period)
```

##### Token Metadata ConfigMap

Token metadata persists in a ConfigMap for operator restarts:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: keycloak-operator-token-metadata
  namespace: keycloak-operator-system
data:
  <token-hash-1>: |
    {
      "namespace": "team-a",
      "token_type": "operational",
      "token_hash": "<sha256-hash>",
      "issued_at": "2025-01-15T00:00:00Z",
      "valid_until": "2025-04-15T00:00:00Z",
      "version": 2,
      "created_by_realm": "first-realm",
      "revoked": false
    }
```

#### Platform Team Setup

##### 1. Create Admission Token (One-time)

```bash
# Generate admission token
ADMISSION_TOKEN=$(python3 -c 'import secrets; print(secrets.token_urlsafe(32))')

# Create admission token secret in team namespace
kubectl create secret generic admission-token-team-a \
  --from-literal=token="$ADMISSION_TOKEN" \
  --namespace=team-a

# Add required labels
kubectl label secret admission-token-team-a \
  vriesdemichael.github.io/token-type=admission \
  vriesdemichael.github.io/allow-operator-read=true \
  --namespace=team-a

# Store token metadata
TOKEN_HASH=$(echo -n "$ADMISSION_TOKEN" | sha256sum | cut -d' ' -f1)
kubectl patch configmap keycloak-operator-token-metadata \
  --namespace=keycloak-operator-system \
  --type=merge \
  --patch "{
    \"data\": {
      \"$TOKEN_HASH\": \"{\\\"namespace\\\": \\\"team-a\\\", \\\"token_type\\\": \\\"admission\\\", \\\"token_hash\\\": \\\"$TOKEN_HASH\\\", \\\"issued_at\\\": \\\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\\\", \\\"valid_until\\\": \\\"$(date -u -d '+1 year' +%Y-%m-%dT%H:%M:%SZ)\\\", \\\"version\\\": 1, \\\"created_by_realm\\\": null, \\\"revoked\\\": false}\"
    }
  }"
```

##### 2. Share Token with Team

```bash
# Export admission token for GitOps
kubectl get secret admission-token-team-a \
  -n team-a -o yaml > team-a-admission-token.yaml

# Team applies to their namespace
kubectl apply -f team-a-admission-token.yaml -n team-a
```

##### 3. Team Creates First Realm

Team applies realm manifest (see example above). Operator automatically:
- Validates admission token
- Generates operational token
- Stores it in `team-a-operator-token` secret
- Sets up automatic rotation

#### Monitoring Token Rotation

##### Metrics

The operator exposes Prometheus metrics for monitoring:

```promql
# Token rotations performed
keycloak_operator_token_rotations_total

# Bootstrap operations (admission ‚Üí operational)
keycloak_operator_token_bootstraps_total

# Tokens expiring soon (within 7 days)
keycloak_operator_tokens_expiring_soon

# Active operational tokens
keycloak_operator_active_tokens

# Rotation failures
keycloak_operator_token_rotation_failures_total
```

##### Kubernetes Events

Watch for rotation events:

```bash
# Watch all token-related events
kubectl get events --all-namespaces \
  --field-selector involvedObject.kind=Secret \
  -w | grep -i token

# Example events:
# Normal  TokenRotated     Secret/team-a-operator-token  Token rotated: version 1 ‚Üí 2
# Normal  GracePeriodStart Secret/team-a-operator-token  Grace period started, expires 2025-04-22
# Normal  TokenCleanup     Secret/team-a-operator-token  Previous token removed after grace period
```

##### Manual Inspection

```bash
# Check operational token status
kubectl get secret team-a-operator-token -n team-a -o yaml

# Check token metadata
kubectl get configmap keycloak-operator-token-metadata \
  -n keycloak-operator-system -o yaml

# Check realm authorization status (if CRD updated)
kubectl get keycloakrealm first-realm -n team-a -o jsonpath='{.status.authorizationStatus}'
```

#### Token Revocation

To revoke a token immediately (e.g., security incident):

```bash
# Method 1: Delete operational token (operator will detect unauthorized realms)
kubectl delete secret team-a-operator-token -n team-a

# Method 2: Mark token as revoked in metadata
TOKEN_HASH="<your-token-hash>"
kubectl patch configmap keycloak-operator-token-metadata \
  --namespace=keycloak-operator-system \
  --type=json \
  -p "[{\"op\": \"replace\", \"path\": \"/data/$TOKEN_HASH\", \"value\": \"$(kubectl get configmap keycloak-operator-token-metadata -n keycloak-operator-system -o jsonpath="{.data.$TOKEN_HASH}" | jq '.revoked = true')\"}]"

# Realms using revoked token will fail authorization
# You must provide new admission token to re-bootstrap
```

#### Troubleshooting

##### Realm Fails Authorization After Rotation

**Symptom**: Realm shows "Authorization failed" in status

**Cause**: Application is using old token after grace period expired

**Solution**: Update realm to use operational token (not admission token)

```bash
# Check if realm is using admission token (wrong)
kubectl get keycloakrealm my-realm -n team-a -o yaml | grep authorizationSecretRef

# Should reference operational token:
# name: team-a-operator-token  ‚úÖ Correct
# name: admission-token-team-a  ‚ùå Wrong (one-time use only)
```

##### Operational Token Not Generated

**Symptom**: First realm fails, no operational token secret created

**Possible causes**:
1. Admission token not found in namespace
2. Admission token not in ConfigMap metadata
3. Admission token already used (must be one-time per namespace)

**Solution**:
```bash
# Verify admission token exists
kubectl get secret admission-token-team-a -n team-a

# Verify admission token in metadata
kubectl get configmap keycloak-operator-token-metadata \
  -n keycloak-operator-system -o yaml | grep team-a

# Check operator logs
kubectl logs -n keycloak-operator-system \
  deployment/keycloak-operator | grep -i "bootstrap\|admission"
```

##### Token Rotation Stuck

**Symptom**: Token shows expired but not rotated

**Check rotation handler status**:
```bash
# Check operator logs for rotation handler
kubectl logs -n keycloak-operator-system \
  deployment/keycloak-operator | grep -i "rotation\|timer"

# Verify ConfigMap is accessible
kubectl auth can-i get configmap \
  --as=system:serviceaccount:keycloak-operator-system:keycloak-operator \
  --namespace=keycloak-operator-system

# Manually trigger rotation (if needed)
# Delete the secret, operator will recreate on next reconciliation
kubectl delete secret team-a-operator-token -n team-a
```

#### Security Best Practices

##### 1. Protect Admission Tokens

Admission tokens are sensitive - protect them like root credentials:

```yaml
# Use SealedSecrets for GitOps
apiVersion: bitnami.com/v1alpha1
kind: SealedSecret
metadata:
  name: admission-token-team-a
  namespace: team-a
spec:
  encryptedData:
    token: AgBB9j6FnMU5z...  # Encrypted token
```

##### 2. Monitor Token Expiry

Set up alerts for expiring tokens:

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: keycloak-token-alerts
spec:
  groups:
    - name: keycloak-tokens
      rules:
        - alert: KeycloakTokenExpiryWarning
          expr: keycloak_operator_tokens_expiring_soon > 0
          for: 24h
          labels:
            severity: warning
          annotations:
            summary: "Keycloak operational token expiring soon"
            description: "Token in {{ $labels.namespace }} expires in less than 7 days"

        - alert: KeycloakTokenRotationFailed
          expr: increase(keycloak_operator_token_rotation_failures_total[1h]) > 0
          labels:
            severity: critical
          annotations:
            summary: "Keycloak token rotation failed"
            description: "Token rotation failed, check operator logs"
```

##### 3. Audit Token Access

Enable audit logging for token access:

```yaml
# Kubernetes audit policy
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
  - level: Metadata
    resources:
      - group: ""
        resources: ["secrets"]
    namespaces: ["team-a", "team-b"]
    verbs: ["get", "list"]
    omitStages:
      - RequestReceived
```

##### 4. Namespace Isolation

Operational tokens are namespace-scoped:

```bash
# ‚úÖ This works (token in same namespace)
kubectl apply -f realm.yaml -n team-a  # Uses team-a-operator-token

# ‚ùå This fails (token not in namespace)
kubectl apply -f realm.yaml -n team-b  # No access to team-a-operator-token
```

##### 5. Principle of Least Privilege

Application teams only need to read operational tokens:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: keycloak-realm-manager
  namespace: team-a
rules:
  - apiGroups: ["vriesdemichael.github.io"]
    resources: ["keycloakrealms", "keycloakclients"]
    verbs: ["create", "update", "patch", "delete", "get", "list", "watch"]
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["team-a-operator-token", "*-realm-auth"]
    verbs: ["get"]  # Read-only access to tokens
```

#### Migration from Manual Tokens

If you're currently using manual operator tokens, migrate to the new system:

##### Step 1: Create Admission Token

```bash
# Generate admission token
ADMISSION_TOKEN=$(python3 -c 'import secrets; print(secrets.token_urlsafe(32))')

# Create secret
kubectl create secret generic admission-token-team-a \
  --from-literal=token="$ADMISSION_TOKEN" \
  --namespace=team-a

# Add required labels
kubectl label secret admission-token-team-a \
  vriesdemichael.github.io/token-type=admission \
  vriesdemichael.github.io/allow-operator-read=true \
  --namespace=team-a

# Store metadata
# (See "Platform Team Setup" section above for full command)
```

##### Step 2: Update First Realm to Bootstrap

```yaml
# Update the first realm in namespace to use admission token
# yaml-language-server: $schema=https://vriesdemichael.github.io/keycloak-operator/schemas/v1/KeycloakRealm.json
apiVersion: vriesdemichael.github.io/v1
kind: KeycloakRealm
metadata:
  name: first-realm
  namespace: team-a
spec:
  realmName: first-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: admission-token-team-a  # Changed from manual token
      key: token
```

```bash
kubectl apply -f first-realm.yaml
```

**Operator will:**
1. Detect admission token
2. Generate operational token (`team-a-operator-token`)
3. Store metadata in ConfigMap

##### Step 3: Update Other Realms

```bash
# Update all other realms in namespace to use operational token
for realm in $(kubectl get keycloakrealm -n team-a -o name); do
  kubectl patch $realm -n team-a --type=merge -p '
spec:
  operatorRef:
    authorizationSecretRef:
      name: team-a-operator-token
  '
done
```

##### Step 4: Cleanup Old Token

```bash
# After migration complete, delete old manual token
kubectl delete secret keycloak-operator-auth-token -n team-a

# Operational token now rotates automatically
```

#### Configuration

Token rotation parameters can be configured (if needed) via operator environment variables:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: keycloak-operator
  namespace: keycloak-operator-system
spec:
  template:
    spec:
      containers:
        - name: operator
          env:
            # Token validity period (default: 90 days)
            - name: TOKEN_VALIDITY_DAYS
              value: "90"
            # Grace period for dual tokens (default: 7 days)
            - name: TOKEN_GRACE_PERIOD_DAYS
              value: "7"
            # Rotation check interval (default: daily at 00:00 UTC)
            - name: ROTATION_CHECK_HOUR
              value: "0"
            # Cleanup check interval (default: hourly)
            - name: CLEANUP_CHECK_INTERVAL_HOURS
              value: "1"
```

**Note**: These are operator-wide settings. Changing them requires operator restart.

### Network Security

Combine token-based authorization with NetworkPolicies:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: keycloak-realm-access
  namespace: platform
spec:
  podSelector:
    matchLabels:
      app: keycloak
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              team: authorized  # Only authorized namespaces
      ports:
        - protocol: TCP
          port: 8080
```

### Audit Logging

Enable Kubernetes audit logging to track secret access:

```yaml
# Audit policy
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
  - level: Metadata
    resources:
      - group: ""
        resources: ["secrets"]
    namespaces: ["platform", "app-team"]
```

### Least Privilege

Application teams only need minimal RBAC:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: keycloak-user
  namespace: app-team
rules:
  # Create and manage own Keycloak resources
  - apiGroups: ["vriesdemichael.github.io"]
    resources: ["keycloakrealms", "keycloakclients"]
    verbs: ["create", "update", "patch", "delete", "get", "list", "watch"]
  # Read authorization secrets
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["keycloak-operator-auth-token", "*-realm-auth"]
    verbs: ["get"]
```

## Comparison with RBAC Approaches

### Why Not Traditional RBAC?

Other operators often use RBAC for cross-namespace access:

```yaml
# Traditional approach: requires platform team intervention
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: keycloak-realm-creator
rules:
  - apiGroups: ["vriesdemichael.github.io"]
    resources: ["keycloaks"]
    verbs: ["get"]
    resourceNames: ["keycloak"]  # Must list every Keycloak!
```

**Problems**:
- ClusterRole must be updated for every new Keycloak instance
- Doesn't scale to many teams (100+ ClusterRoleBindings)
- Requires cluster-admin privileges to manage
- Breaks GitOps self-service model

### Secret-Based Authorization Benefits

| Aspect | Traditional RBAC | Secret-Based |
|--------|------------------|--------------|
| **Scalability** | Limited (~10 teams) | Unlimited (100+ teams) |
| **Self-service** | ‚ùå Requires cluster admin | ‚úÖ Platform team shares secret |
| **GitOps-friendly** | ‚ùå ClusterRole not namespaced | ‚úÖ Secrets are standard resources |
| **Delegation speed** | Hours/days (RBAC review) | Minutes (share secret) |
| **Audit trail** | RBAC changes only | Every secret access |
| **Revocation** | Delete RoleBinding | Delete secret |
| **Fine-grained control** | Resource-level | Instance-level |

## Security Considerations

### Threat Model

**Protected against**:
‚úÖ Unauthorized realm creation (requires operator token)
‚úÖ Unauthorized client creation (requires realm token)
‚úÖ Cross-namespace access without permission (tokens don't leak)
‚úÖ Timing attacks (constant-time comparison)
‚úÖ Token prediction (cryptographically random)

**Not protected against**:
‚ùå Compromised namespace (if namespace compromised, secrets are accessible)
‚ùå Cluster admin abuse (cluster admin can read all secrets)
‚ùå Kubernetes API server compromise (same as any K8s secret)

### When to Use

**Secret-based authorization is ideal when**:
- Multiple teams need to create Keycloak resources independently
- Platform team wants to enable self-service
- GitOps workflows are primary deployment method
- Organization has 10+ teams using Keycloak

**Consider alternatives when**:
- Single team manages all Keycloak resources
- Strict security compliance requires RBAC audit trail only
- Organization policy forbids secret-based authorization
- Integration with external IAM systems required

## Implemented Features

### ‚úÖ Automatic Token Rotation

The operator now features automatic token rotation (implemented):

- ‚úÖ **Token expiration**: Operational tokens expire after 90 days with automatic rotation
- ‚úÖ **Zero-downtime rotation**: 7-day grace period with dual-token support
- ‚úÖ **Audit trail**: Complete token lifecycle tracked in ConfigMap metadata
- ‚úÖ **Bootstrap system**: One-time admission tokens for secure initialization

See the [Token Rotation](#token-rotation) section for complete documentation.

## Future Enhancements

Potential future additions to the security model:

- **External token validation**: Integrate with external authorization systems (OPA, Kyverno)
- **mTLS authentication**: Use client certificates instead of/alongside tokens
- **Token scoping**: Limit tokens to specific operations (read-only tokens, realm-specific tokens)
- **Custom rotation schedules**: Per-namespace rotation policies
- **Token revocation webhooks**: External notification of token revocation events

## Glossary

### Token Types

| Term | Definition | Lifecycle | Usage | Rotation |
|------|------------|-----------|-------|----------|
| **Operator Token** | Internal token generated by the operator on startup. Used for single-tenant/dev mode where all teams share one token. | Created with operator deployment | Direct use in `operatorRef.authorizationSecretRef` | Manual only |
| **Admission Token** | One-time bootstrap token created by platform teams to initialize a namespace. Triggers generation of operational token when first realm is created. | Platform team creates, used once per namespace | First realm in namespace | N/A (one-time use) |
| **Operational Token** | Auto-generated namespace-scoped token for day-to-day operations. Created when first realm uses admission token. All subsequent realms auto-discover it. | Auto-generated from admission token | All realms after first in namespace | Every 90 days (automatic) |
| **Realm Token** | Auto-generated per-realm token for client creation. Created when realm becomes Ready. | Created with realm | KeycloakClient resources referencing parent realm | Tied to realm lifecycle |
| **Authorization Secret** | Generic term for any secret containing a token used for authorization (`operatorRef.authorizationSecretRef` or `realmRef.authorizationSecretRef`) | Varies by token type | All CRD resource references | Varies by token type |

### Terminology Clarification

| Term | Also Known As | What It Is | What It's Not |
|------|---------------|------------|---------------|
| **Operator Token** | Internal token, bootstrap token (dev mode) | Token for simple single-tenant setups | ‚ùå NOT the same as operational token |
| **Admission Token** | Bootstrap token (production), initialization token | One-time token to set up a namespace | ‚ùå NOT for ongoing operations |
| **Operational Token** | Auto-rotating token, namespace token | Long-lived token with automatic rotation | ‚ùå NOT manually managed |
| **Realm Token** | Realm authorization token | Per-realm token for client management | ‚ùå NOT used for realm creation |

### Token Flow Modes

#### Single-Tenant / Development Mode

```
Operator Deployment
        ‚Üì
Operator Token Generated (keycloak-operator-auth-token)
        ‚Üì
All Realms Use Operator Token Directly
        ‚Üì
Manual Token Management
```

**Characteristics:**
- ‚úÖ Simple: One token for everything
- ‚úÖ Fast setup: No token management needed
- ‚ùå No multi-tenancy: All teams share one token
- ‚ùå No automatic rotation: Must rotate manually
- ‚ùå Not production-ready: Token compromise affects all realms

#### Multi-Tenant / Production Mode

```
Platform Team Creates Admission Token
        ‚Üì
Team Creates First Realm (uses admission token)
        ‚Üì
Operator Generates Operational Token (namespace-scoped)
        ‚Üì
All Subsequent Realms Auto-Discover Operational Token
        ‚Üì
Automatic Token Rotation (every 90 days)
```

**Characteristics:**
- ‚úÖ Multi-tenant: Each namespace has independent token
- ‚úÖ Auto-rotation: Tokens rotate automatically
- ‚úÖ Namespace isolation: Token compromise limited to one namespace
- ‚úÖ Production-ready: Security best practices
- ‚ö†Ô∏è More complex: Requires initial admission token setup

### Key Concepts

| Concept | Explanation | Example |
|---------|-------------|---------|
| **Token Discovery** | Operator searches namespace for operational token using labels instead of explicit reference. Simplifies realm creation after bootstrap. | Realm spec omits `authorizationSecretRef` ‚Üí operator finds `team-a-operator-token` via labels |
| **Grace Period** | 7-day window during token rotation where both old and new tokens are valid. Enables zero-downtime rotation. | Day 83-90: Both `token` and `token-previous` in secret are valid |
| **Bootstrap** | Process of converting admission token to operational token when first realm is created. | First realm uses admission token ‚Üí operator generates operational token |
| **Token Metadata** | Persistent storage of token lifecycle info in ConfigMap. Survives operator restarts. | Token version, expiry date, created-by realm, revocation status |
| **Token Hash** | SHA-256 hash of token for indexing in metadata without storing plaintext. | Used as key in `keycloak-operator-token-metadata` ConfigMap |

### Security Terms

| Term | Definition |
|------|------------|
| **Constant-time comparison** | Token comparison algorithm that takes same time regardless of match/mismatch. Prevents timing attacks. |
| **Cryptographic entropy** | Amount of randomness in token (256 bits). Higher entropy = harder to guess. |
| **Bearer token** | Token that grants access to whoever possesses it (like a key). Must be kept secret. |
| **Capability-based security** | Security model where possession of token grants access (vs checking permissions list). |
| **Token revocation** | Immediately invalidating a token before its natural expiration. Used in security incidents. |
| **Namespace isolation** | Security boundary where tokens don't leak between Kubernetes namespaces. |

### Common Confusion Points

#### "What's the difference between operator token and operational token?"

- **Operator Token**: Created once by operator at startup. Used in single-tenant dev mode. Never rotates automatically.
- **Operational Token**: Created per-namespace during bootstrap. Auto-rotates every 90 days. Production use.

**Rule of thumb**: If it says "operator token", it's for dev. If it says "operational token", it's for production.

#### "When do I use admission token vs operational token?"

- **Admission Token**: Only for the **first realm** in a namespace (bootstrap)
- **Operational Token**: For **all other realms** in that namespace (auto-discovered)

**Rule of thumb**: Platform team uses admission once. App team uses operational forever.

#### "Why do I need tokens at all? Can't I just use RBAC?"

Traditional RBAC doesn't scale to 100+ teams. Token-based authorization:
- ‚úÖ Scales to unlimited teams (no ClusterRole updates)
- ‚úÖ Self-service (platform team shares secret, team proceeds)
- ‚úÖ GitOps-native (secrets are standard K8s resources)

See [Comparison with RBAC Approaches](#comparison-with-rbac-approaches) for details.

#### "Is the realm token the same as the realm authorization token?"

Yes, they're the same thing:
- **Realm token** = Short form
- **Realm authorization token** = Full descriptive name
- **`<realm-name>-realm-auth` secret** = Actual Kubernetes resource name

#### "What happens if I use the wrong token?"

The operator will reject the operation with an authorization error. Check operator logs and resource status for details.

## See Also

**Related Documentation:**

- [Token Management Operations](operations/token-management.md) - Operational procedures for token rotation, revocation, and troubleshooting
- [Architecture: Token System](architecture.md#token-system-architecture) - Technical architecture and token flow diagrams
- [Multi-Tenant Setup Guide](how-to/multi-tenant.md) - Production setup with admission and operational tokens
- [Troubleshooting: Token & Authorization Issues](operations/troubleshooting.md#token-authorization-issues) - Debugging common token problems
- [FAQ: Token System](faq.md#token-system) - Quick answers to token-related questions

**Operational Guides:**

- [How to set up a production multi-tenant environment](how-to/multi-tenant.md)
- [How to rotate operational tokens](operations/token-management.md#operational-token-rotation)
- [How to recover from token compromise](operations/token-management.md#token-compromise-recovery)

**For Platform Teams:**

- [Creating admission tokens for new teams](operations/token-management.md#creating-admission-tokens)
- [Auditing token usage](operations/token-management.md#token-audit-procedures)
- [Revoking access for departing teams](operations/token-management.md#token-revocation)

## References

- [Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)
- [External Secrets Operator](https://external-secrets.io/)
- [Capability-based security](https://en.wikipedia.org/wiki/Capability-based_security)
- [NIST Password Guidelines](https://pages.nist.gov/800-63-3/sp800-63b.html)
