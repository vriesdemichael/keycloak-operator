# Security Model

This document explains the security model of the Keycloak operator, with a focus on the secret-based authorization system that enables secure, scalable delegation of Keycloak resource management.

## Overview

The Keycloak operator implements a capability-based authorization model using Kubernetes secrets as bearer tokens. This design choice prioritizes **scalability** and **operational simplicity** over traditional RBAC-based approaches.

### Design Philosophy

**Key principle**: Application teams should be able to manage their own Keycloak realms and clients without requiring platform team intervention or operator RBAC changes.

Traditional RBAC approaches create bottlenecks:
- ❌ Adding a new team requires updating operator ClusterRole
- ❌ Cross-namespace access requires complex RoleBinding configurations
- ❌ GitOps workflows are blocked on RBAC updates
- ❌ Doesn't scale beyond ~10 teams

Secret-based authorization solves these problems:
- ✅ Delegate to 100+ teams without touching operator configuration
- ✅ Self-service: Platform team shares a secret, app team can proceed
- ✅ GitOps-friendly: Secrets are just another Kubernetes resource
- ✅ Audit trail: Secret access is logged by Kubernetes API server

## Authorization Model

### Three-Level Token System

The operator uses three types of authorization tokens:

#### 1. Operator Authorization Token

**Purpose**: Allows realms to be created on a Keycloak instance

**Generated by**: Operator when it starts
**Stored in**: `keycloak-operator-auth-token` secret in operator namespace
**Used by**: KeycloakRealm resources to validate they have permission to create realms

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: keycloak-operator-auth-token
  namespace: keycloak-operator-system
type: Opaque
data:
  token: <base64-encoded-random-token>
```

**Workflow**:
```bash
# Platform team creates Keycloak instance
kubectl apply -f keycloak.yaml

# Operator generates operator token automatically
# Platform team shares this token with application teams
kubectl get secret keycloak-operator-auth-token -n keycloak-operator-system -o yaml | \
  kubectl apply -n app-team-namespace -f -
```

#### 2. Realm Authorization Token

**Purpose**: Allows clients to be created within a specific realm

**Generated by**: Operator when a KeycloakRealm is created
**Stored in**: `<realm-name>-realm-auth` secret in realm's namespace
**Used by**: KeycloakClient resources to validate they have permission to create clients in that realm

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-realm-realm-auth
  namespace: app-team-namespace
  ownerReferences:
    - apiVersion: keycloak.mdvr.nl/v1
      kind: KeycloakRealm
      name: my-realm
type: Opaque
data:
  token: <base64-encoded-random-token>
```

**Workflow**:
```bash
# App team creates realm (using operator token)
kubectl apply -f realm.yaml

# Operator generates realm token automatically
# App team can now create clients in this realm
kubectl apply -f client.yaml
```

#### 3. Admin Credentials

**Purpose**: Keycloak admin console access
**Generated by**: Operator when Keycloak instance is created
**Stored in**: `<keycloak-name>-admin-credentials` secret

These are standard Keycloak admin credentials and are separate from the operator's authorization system.

## How It Works

### Token Generation

All tokens are generated using cryptographically secure random number generation:

```python
import secrets
token = secrets.token_urlsafe(32)  # 256 bits of entropy
```

### Token Validation

When a resource references another resource cross-namespace, the operator:

1. Reads the authorization secret from the **source namespace** (where the requesting resource lives)
2. Reads the expected token from the **target namespace** (where the referenced resource lives)
3. Compares the tokens using constant-time comparison to prevent timing attacks
4. Grants or denies access based on the comparison

Example for KeycloakRealm → Keycloak:

```yaml
apiVersion: keycloak.mdvr.nl/v1
kind: KeycloakRealm
metadata:
  name: my-realm
  namespace: app-team
spec:
  realmName: my-realm
  operatorRef:
    namespace: platform-team  # Target namespace
    authorizationSecretRef:
      name: keycloak-operator-auth-token  # Secret in app-team namespace
```

The operator will:
1. Read `keycloak-operator-auth-token` from `app-team` namespace
2. Read `keycloak-operator-auth-token` from `platform-team` namespace (or operator namespace)
3. Compare the tokens
4. Allow realm creation if they match

## Security Properties

### Cryptographic Security

- **Token generation**: Uses `secrets.token_urlsafe()` from Python's secrets module
- **Entropy**: 256 bits per token (same as a good password)
- **Comparison**: Constant-time to prevent timing attacks
- **Storage**: Tokens stored as Kubernetes secrets (encrypted at rest if cluster configured)

### Kubernetes-Native Security

Leverages existing Kubernetes security primitives:

- **Secret RBAC**: Teams need `get` permission on secrets to use them
- **Namespace isolation**: Secrets don't leak across namespaces without explicit sharing
- **Audit logging**: Kubernetes API server logs all secret access
- **Encryption at rest**: If cluster has encryption enabled, tokens are encrypted

### Namespace Isolation

The token system enforces namespace boundaries:

```yaml
# This works (token in same namespace as realm)
apiVersion: keycloak.mdvr.nl/v1
kind: KeycloakRealm
metadata:
  name: my-realm
  namespace: team-a
spec:
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: operator-token  # Secret exists in team-a namespace
```

```yaml
# This fails (token not present in team-b namespace)
apiVersion: keycloak.mdvr.nl/v1
kind: KeycloakRealm
metadata:
  name: malicious-realm
  namespace: team-b
spec:
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: operator-token  # Secret doesn't exist in team-b namespace
```

## Delegation Workflow

### Platform Team Workflow

1. **Create Keycloak instance** in platform namespace:

```yaml
apiVersion: keycloak.mdvr.nl/v1
kind: Keycloak
metadata:
  name: keycloak
  namespace: platform
spec:
  replicas: 3
  database:
    type: cnpg
    cluster: keycloak-db
```

2. **Operator automatically generates** `keycloak-operator-auth-token` secret

3. **Share the operator token** with application teams:

```bash
# Export operator token
kubectl get secret keycloak-operator-auth-token \
  -n keycloak-operator-system -o yaml > operator-token.yaml

# Application team applies it to their namespace
kubectl apply -f operator-token.yaml -n app-team
```

### Application Team Workflow

1. **Receive operator token** from platform team (via GitOps, secret management, etc.)

2. **Create realm** referencing the operator token:

```yaml
apiVersion: keycloak.mdvr.nl/v1
kind: KeycloakRealm
metadata:
  name: my-app-realm
  namespace: app-team
spec:
  realmName: my-app-realm
  operatorRef:
    namespace: platform
    authorizationSecretRef:
      name: keycloak-operator-auth-token
  security:
    registrationAllowed: false
    resetPasswordAllowed: true
```

3. **Operator generates realm token** automatically: `my-app-realm-realm-auth`

4. **Create clients** using the realm token (no additional secrets needed):

```yaml
apiVersion: keycloak.mdvr.nl/v1
kind: KeycloakClient
metadata:
  name: my-app-client
  namespace: app-team
spec:
  clientId: my-app
  realmRef:
    name: my-app-realm
    namespace: app-team
    authorizationSecretRef:
      name: my-app-realm-realm-auth
  settings:
    publicClient: false
    standardFlowEnabled: true
```

## Best Practices

### Token Distribution

**Use GitOps for secret distribution:**

```yaml
# Git repository structure
secrets/
  platform/
    keycloak-operator-token.yaml  # Platform team manages
  teams/
    team-a/
      keycloak-operator-token.yaml  # Copy of platform token
    team-b/
      keycloak-operator-token.yaml  # Copy of platform token
```

**Use External Secrets Operator** for enterprise secret management:

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: keycloak-operator-auth-token
  namespace: app-team
spec:
  secretStoreRef:
    name: vault-backend
    kind: ClusterSecretStore
  target:
    name: keycloak-operator-auth-token
  data:
    - secretKey: token
      remoteRef:
        key: keycloak/operator-token
        property: token
```

### Token Rotation

Tokens should be rotated periodically for security:

```bash
# 1. Generate new token
kubectl create secret generic keycloak-operator-auth-token-new \
  --from-literal=token=$(python -c 'import secrets; print(secrets.token_urlsafe(32))') \
  -n keycloak-operator-system

# 2. Update all realms to reference new token
# (This requires updating the operatorRef.authorizationSecretRef in each realm)

# 3. Delete old token after migration
kubectl delete secret keycloak-operator-auth-token -n keycloak-operator-system
```

### Network Security

Combine token-based authorization with NetworkPolicies:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: keycloak-realm-access
  namespace: platform
spec:
  podSelector:
    matchLabels:
      app: keycloak
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              team: authorized  # Only authorized namespaces
      ports:
        - protocol: TCP
          port: 8080
```

### Audit Logging

Enable Kubernetes audit logging to track secret access:

```yaml
# Audit policy
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
  - level: Metadata
    resources:
      - group: ""
        resources: ["secrets"]
    namespaces: ["platform", "app-team"]
```

### Least Privilege

Application teams only need minimal RBAC:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: keycloak-user
  namespace: app-team
rules:
  # Create and manage own Keycloak resources
  - apiGroups: ["keycloak.mdvr.nl"]
    resources: ["keycloakrealms", "keycloakclients"]
    verbs: ["create", "update", "patch", "delete", "get", "list", "watch"]
  # Read authorization secrets
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["keycloak-operator-auth-token", "*-realm-auth"]
    verbs: ["get"]
```

## Comparison with RBAC Approaches

### Why Not Traditional RBAC?

Other operators often use RBAC for cross-namespace access:

```yaml
# Traditional approach: requires platform team intervention
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: keycloak-realm-creator
rules:
  - apiGroups: ["keycloak.mdvr.nl"]
    resources: ["keycloaks"]
    verbs: ["get"]
    resourceNames: ["keycloak"]  # Must list every Keycloak!
```

**Problems**:
- ClusterRole must be updated for every new Keycloak instance
- Doesn't scale to many teams (100+ ClusterRoleBindings)
- Requires cluster-admin privileges to manage
- Breaks GitOps self-service model

### Secret-Based Authorization Benefits

| Aspect | Traditional RBAC | Secret-Based |
|--------|------------------|--------------|
| **Scalability** | Limited (~10 teams) | Unlimited (100+ teams) |
| **Self-service** | ❌ Requires cluster admin | ✅ Platform team shares secret |
| **GitOps-friendly** | ❌ ClusterRole not namespaced | ✅ Secrets are standard resources |
| **Delegation speed** | Hours/days (RBAC review) | Minutes (share secret) |
| **Audit trail** | RBAC changes only | Every secret access |
| **Revocation** | Delete RoleBinding | Delete secret |
| **Fine-grained control** | Resource-level | Instance-level |

## Security Considerations

### Threat Model

**Protected against**:
✅ Unauthorized realm creation (requires operator token)
✅ Unauthorized client creation (requires realm token)
✅ Cross-namespace access without permission (tokens don't leak)
✅ Timing attacks (constant-time comparison)
✅ Token prediction (cryptographically random)

**Not protected against**:
❌ Compromised namespace (if namespace compromised, secrets are accessible)
❌ Cluster admin abuse (cluster admin can read all secrets)
❌ Kubernetes API server compromise (same as any K8s secret)

### When to Use

**Secret-based authorization is ideal when**:
- Multiple teams need to create Keycloak resources independently
- Platform team wants to enable self-service
- GitOps workflows are primary deployment method
- Organization has 10+ teams using Keycloak

**Consider alternatives when**:
- Single team manages all Keycloak resources
- Strict security compliance requires RBAC audit trail only
- Organization policy forbids secret-based authorization
- Integration with external IAM systems required

## Future Enhancements

Potential future additions to the security model:

- **Token expiration**: Add TTL to tokens with automatic rotation
- **External token validation**: Integrate with external authorization systems (OPA, Kyverno)
- **mTLS authentication**: Use client certificates instead of tokens
- **Token scoping**: Limit tokens to specific operations (read-only tokens)
- **Audit events**: Emit custom events for authorization decisions

## References

- [Kubernetes Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)
- [External Secrets Operator](https://external-secrets.io/)
- [Capability-based security](https://en.wikipedia.org/wiki/Capability-based_security)
- [NIST Password Guidelines](https://pages.nist.gov/800-63-3/sp800-63b.html)
